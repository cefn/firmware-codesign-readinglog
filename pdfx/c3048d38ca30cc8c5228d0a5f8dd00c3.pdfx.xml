<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>f1b6e4ff9c21911b3904fc2c135c7e3fcaac716d4273523536640e3ddd063e6f</job>
    <base_name>62pa</base_name>
    <doi confidence="possible" alt_doi="http://dx.doi.org/10.4271/2006-01-1457">http://dx.doi.org/10.1016/0920-5489(87)90045-6</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">OOPSLA 2001 Workshop: Towards Patterns and Pattern Languages for OO Distributed Real-time and Embedded Systems</outsider>
      <title-group>
        <article-title class="DoCO:Title" id="2">A Proposal for an Embedded Systems Pattern Language</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="3">David E. DeLano</name>
        </contrib>
      </contrib-group>
      <region class="DoCO:TextChunk" id="5" confidence="possible">Object Technology International, Inc. <email id="4">David_DeLano@oti.com</email></region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Background">
        <h1 class="DoCO:SectionTitle" id="6" page="1" column="1">Background</h1>
      </section>
      <region class="DoCO:TextChunk" id="7" page="1" column="1">I consider myself an embedded systems developer. The first 20+ years of my career were spent working on telephony systems, definitely qualifying as distributed embedded real-time systems. I have been active in the Patterns community for around six years. After two rounds at AG Communication Systems that totaled fifteen years, and the rest with a small telephony startup, I made a career change earlier this year. I am now employed with OTI, working on Java Virtual Machines for embedded systems. Part of that work consists of supporting extensions that implement the Java real-time specification.</region>
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="8" page="1" column="1">Introduction</h1>
      </section>
      <region class="DoCO:TextChunk" id="12" page="1" column="1">Most of the current Patterns and Pattern Language work on real-time embedded systems has centered on resolving specific problems, or specifying architectures. A Pattern Language for Distributed Real-time and Embedded Systems should be more encompassing and more general. It should start from ground zero, and build a system up from scratch. This is not to say that the existing Patterns and Pattern Languages are bad. They usually start somewhere in the middle, and the user must know a great deal about real-time embedded systems before these Patterns and Pattern Languages make sense and become useable. <marker type="block"/> On the other hand, I’m confronted with The Real-Time Specification for Java, which essentially is a specification for an interface for a real-time system. This specification has been implemented in Virtual Machines destined for embedded systems, whether or not the specification intended this. The design of the specification could have benefited greatly from the existence of a Pattern Language for real-time embedded systems.<marker type="block"/> Then there is the debate of whether or not to use the Object Oriented paradigm when developing embedded system. The last few projects I worked on used C++, though I must admit that most designers only used it as a better C. A project before that used a homegrown object oriented C, before cross-compilers for C++ were available. My current work is in Java. I think the Object Oriented paradigm is here to stay, but one must always remember to use all the tools available when solving a problem, and not use OO where it is not appropriate.<marker type="block"/> So what has Object Oriented embedded real-time development given us? When done correctly, it has given us reusable architectures, reusable designs, frameworks, and better understood code. When misused it often gives us bigger messes than we had before. Object code can be more difficult to test and, especially, debug. Inheritance hierarchies can be so deep that it is difficult to figure anything out. The good, however, most likely outweighs the bad. Object Oriented design and implementation have been especially helpful in the handling of data. Data in Structured Programming usually lies naked to the world with only agreements between developers to protect it.</region>
      <outsider class="DoCO:TextBox" type="header" id="13" page="2" column="1">OOPSLA 2001 Workshop</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="14" page="2" column="1">Page 2</outsider>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="15" page="2" column="1">The Beginnings of a Pattern Language</h1>
        <region class="DoCO:TextChunk" id="16" page="2" column="1">This proposal for the beginnings of a Pattern Language is by no means complete. It only starts things in the direction that I think they should go. It starts as a Pattern Language for Embedded Systems. It extends into distributed systems and real-time systems. It is not inherently Object Oriented, at least at first, but Object Oriented architectures would come into play as the language matures. To tie this language into the work I am currently involved in, I will pull in the relationship of the Java Real-Time Specification to the Pattern Language, including the proposal of one Pattern for the Pattern Language.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="17" page="2" column="1">Hardware/Software</h1>
        <region class="DoCO:TextChunk" id="29" page="2" column="1">Pattern Languages are about defining and dividing space. In most Pattern Languages, it is the definition of “space” that causes the most problems. I view “space” as a broad, generic term. It can even be time based, or action based. In this problem space, though, things look to be fairly self-explanatory, at least in the initial phases. The most obvious separation of space is Hardware and Software. We can divide that part of the problem space which we can see and touch as Hardware, and the part that we know is there but can’t prove it as Software. It is a division between that which is more or less permanent, and that which is usually changeable. <marker type="block"/> Whenever something is divided, tension occurs along the borders. It is in the resolution of this tension, or forces, that Patterns appear and the Pattern Language is pushed forward. Obvious tension occurs in the decisions as to what goes into Hardware and what belongs in Software. Forces also exist in the individual Patterns themselves, causing more sub-divisions, which further fill in the Pattern Language. For example, we could have a Pattern, Firmware, that resolves the issues of having software that we really want to make a more permanent part of the problem space. We can still probably change it, but it is very tightly coupled to the Hardware.<marker type="block"/> As divisions of the problem space are made and the forces are resolved, places will be made for existing Patterns and Pattern Languages in the embedded systems domain. This includes many of the Patterns in Pattern-Oriented Software Architecture: A System of Patterns [<xref ref-type="bibr" rid="R1" id="20" class="deo:Reference">1</xref>], Design Patterns [<xref ref-type="bibr" rid="R2" id="21" class="deo:Reference">2</xref>], and the various volumes of Pattern Languages of Program Design [<xref ref-type="bibr" rid="R3" id="22" class="deo:Reference">3</xref>, <xref ref-type="bibr" rid="R4" id="23" class="deo:Reference">4</xref>, <xref ref-type="bibr" rid="R5" id="24" class="deo:Reference">5</xref>, <xref ref-type="bibr" rid="R6" id="25" class="deo:Reference">6</xref>].<marker type="block"/> Hardware has such Patterns as Data Storage and Processor. Data Storage is further refined as ROM, RAM, and Disk, for starters. There are Patterns associated with each of these that help determine which to use, and how large they need to be. Processor is a little more nebulous as it is really a given. There may be patterns on how to choose a Processor.<marker type="block"/> The most obvious division of the Software domain is the Operating System and the Application. The Operating System covers a wide spectrum of things that could include Drivers and Protocol Stacks. The purpose of the Operating System is to hide as much of the Hardware domain from the Application as possible, only exposing what is necessary. The Application is the top layer that is the essence that gives the embedded system its defining characteristics. Most embedded systems run a single Application, though we are seeing a stretch of embedded systems toward desktop capabilities. For all practical purposes, a handheld PDA is an embedded system, yet it can run various applications the way a desktop would.<marker type="block"/> Between the Operating System and the Application is another border. This border creates many forces that have to be resolved in order to have a working system. Many systems have been developed with the Application communicating directly with the Operating System. This arrangement has its drawbacks, though, and the two are better off separated by an OS Abstraction Layer.</region>
        <outsider class="DoCO:TextBox" type="footer" id="30" page="2" column="1">Copyright 2001 (c) Object Technology International</outsider>
        <outsider class="DoCO:TextBox" type="header" id="31" page="3" column="1">OOPSLA 2001 Workshop</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="32" page="3" column="1">Page 3</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="33" page="3" column="1">OS Abstraction Layer</h1>
        <region class="DoCO:TextChunk" id="50" page="3" column="1">Writing an Application to run on a specific Operating System makes a tightly coupled system that is difficult to reuse. The Application, or even parts of it, does not easily port to any other Operating System. The Application may also be bound to the Hardware if the Operating System does not fully hide the Hardware interface. It may be advantageous to bind the Application to the Operation System, and possible to the Hardware to achieve a real-time efficient system. It can also reduce the memory requirements of the system. More often than not, though, there is enough processing power and memory in current embedded systems to support more abstraction, and thus provide an Application that can be used in future systems. <marker type="block"/> The OS Abstraction Layer should provide an interface for the major responsibilities expected of an Operating System. It can supplement the Operating System for features that are missing, but in general, it should not add any functionality that is not generally expected. For the most part, the OS Abstraction Layer standardizes parameter data, congregates Operating System atomic operations into useful functions, and makes the Operating System behave in a predictable manner.<marker type="block"/> Now, all that is needed to move to another Operating System is to port the OS Abstraction Layer. Better yet, there are off-the-shelf OS Abstraction Layers, often existing as Frameworks, that are available. Many are available on multiple Operating Systems, so the porting work is done for you. Most of these present a simpler, more uniform representation of the Operating System interface than relying on direct calls.<marker type="block"/> There can be drawbacks with this solution. Using an OS Abstraction Layer will inherently effect the real time and memory usage of the system. However, Processors are getting faster, and memory cheaper. For the most part, it might boil down to Hardware design.<marker type="block"/> Most off-the-shelf OS Abstraction Layers have an associated cost. Some are tied in with a framework, and are not easily accessed if the entire framework is not appropriate for your application. Writing your own OS Abstraction Layer is an option. However, this can also become costly unless you are really an expert at it. Some home grown OS Abstraction Layers are developed because of political issues. The designers don’t trust the OS or think it needs additional features. Lead designers don’t trust other designers to use the OS properly. These OS Abstraction Layers usually lead to something that is not standard and not portable, both which are key elements to the use of an OS Abstraction Layer.<marker type="block"/> OS Abstraction Layer is similar to MicroKernel [<xref ref-type="bibr" rid="R2" id="40" class="deo:Reference">2</xref>]. It can also be looked at as a Façade [<xref ref-type="bibr" rid="R2" id="41" class="deo:Reference">2</xref>] or Adapter [<xref ref-type="bibr" rid="R2" id="42" class="deo:Reference">2</xref>] for the Operating System.<marker type="block"/> POSIX compliant Operating Systems are an example of implementing an OS Abstraction Layer through the use of a standardized interface. ACE contains an OS wrapper that is a good example of an OS Abstraction Layer. Though Java is a language, it hides many of the interfaces to the Operating System. This is further enhanced by The Real-Time Specification for Java.<marker type="block"/> The Real-Time Specification for Java breaks the OS Abstraction Layer into the following domains, which could be considered for Patterns: Threads, Scheduling, Memory Management, Synchronization, Time, Timers, Asynchrony, Systems and Options, and Exceptions. These may not be the most ideal categories for Patterns, and they may be incorrectly grouped, but they do form a proposal from which to expand. The development of the specification would have benefited from a Pattern Language, if one existed. Instead, it now serves as a known use.<marker type="block"/> To progress in the development of Patterns that surround OS Abstraction Layer, the Java real-time specification should be compared and contrasted to other examples of OS Abstraction Layers such as POSIX and the ACE OS wrappers. This comparison should go a long way in determining what needs to be in the Pattern Language, and what can be omitted. It can also find Patterns that are missing in one or more of the examples. Identifying these short-comings can then help to refine the examples.<marker type="page" number="4"/><marker type="block"/> An example of a problem in the Java specification is that Scheduling can be done in such a way that if the requirements needed by a task cannot be met, the task is not allowed to run. This might be fine in some systems, but in embedded systems, this should instead result in some sort of recovery. This could be in the form of task or resource throttling. A complete refusal to run is usually unacceptable. Patterns or a Pattern Language on Scheduling would have helped guide the development of the specification.</region>
        <region class="unknown" id="35" page="3" column="1">Therefore, use an OS Abstraction Layer between the Application and the Operating System.</region>
        <outsider class="DoCO:TextBox" type="footer" id="47" page="3" column="1">Copyright 2001 (c) Object Technology International</outsider>
        <outsider class="DoCO:TextBox" type="header" id="48" page="4" column="1">OOPSLA 2001 Workshop</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="49" page="4" column="1">Page 4</outsider>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="51" page="4" column="1">Conclusion</h1>
        <region class="DoCO:TextChunk" id="52" page="4" column="1">I would like to see a Pattern Language developed that covers the essence of building embedded systems. This Pattern Language should take into account existing literature, as many of the Patterns already written should find homes within the Pattern Language. I am especially interested in work on the part of the Pattern Language that would flesh out OS Abstraction Layer. This could aid in implementation of the Java real-time specification, or in the refinement of the specification. As the borders of the Pattern Language are refined, it would need to pull in Patterns related to real-time and distributed systems. However, well designed embedded systems are often easily extended to be real-time efficient and behave well as elements of a distributed system. Using a Pattern Language to guide in the design would help ensure this success.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="53" page="4" column="1">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="54" page="4" column="1">[1] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, M. Stal, Pattern-Oriented Software Architecture: A System of Patterns, Wiley and Sons, 1996.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="55" page="4" column="1">[2] E. Gamma, R. Helm, R. Johnson, J. Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software, Addison-Wesley, 1995.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="56" page="4" column="1">[3] J. Coplien, D. Schmidt (eds.), Pattern Languages of Program Design, vol. 1, Addison-Wesley, 1995.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="57" page="4" column="1">[4] J. Vlissides, J. Coplien, N. Kerth (eds.), Pattern Languages of Program Design, vol. 2, Addison-Wesley, 1996.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="58" page="4" column="1">[5] R. Martin, D. Riehle, F. Buschmann (eds.), Pattern Languages of Program Design, vol. 3, Addison-Wesley, 1998.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="59" page="4" column="1">[6] N. Harrison, B. Foote, H. Rohnert (eds.), Pattern Languages of Program Design, vol. 4, Addison-Wesley, 2000.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="footer" id="60" page="4" column="1">Copyright 2001 (c) Object Technology International</outsider>
      </section>
    </body>
  </article>
</pdfx>
