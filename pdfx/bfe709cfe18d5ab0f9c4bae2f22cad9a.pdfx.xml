<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>a4468a6a69f4399a97a94cfca7c64ae59040891eaa32d7e311a46f3ce4d62130</job>
    <base_name>62ly</base_name>
    <doi>http://dx.doi.org/10.1145/238386.238526</doi>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Reusable hierarchical command objects</article-title>
      </title-group>
      <outsider class="DoCO:TextBox" type="header" id="2">Coimputer Scewn-Ce6\i17 AD-A281 186</outsider>
      <region class="unknown" id="3">By</region>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="5">David S. Kosbie Brad A. Myers May</name>
          <aff id="6">1994</aff>
        </contrib>
      </contrib-group>
      <region class="DoCO:TextChunk" id="7" confidence="possible">CMU-CS-94- 156 T I. ECT ' &gt; 0 * ~'0 11LO</region>
      <outsider class="DoCO:TextBox" type="header" id="8">4,4</outsider>
      <region class="unknown" id="9">'0...94-20660 -QAIYWPCB</region>
      <outsider class="DoCO:TextBox" type="footer" id="10">94 7 6 098</outsider>
      <outsider class="DoCO:TextBox" type="header" id="11">a</outsider>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="4" confidence="possible" page="1" column="1">Extending Programming Demonstration With Hierarchical Event Histories</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="12" page="2" column="1">Extending Programming By Demonstration With Hierarchical Event Histories</h1>
        <region class="DoCO:TextChunk" id="13" confidence="possible" page="2" column="1">David S. Kosbie Brad A. Myers May 1994 CMU-CS-94-156</region>
        <region class="unknown" id="14" page="2" column="1">JUL</region>
        <outsider class="DoCO:TextBox" type="sidenote" id="15" page="2" column="1">0 7 19940 F</outsider>
        <region class="DoCO:TextChunk" id="16" confidence="possible" page="2" column="1">School of Con.uter Science Carnegie Mellon University Pittsburgh, PA 15213</region>
        <region class="unknown" id="17" page="2" column="1">To appear in the proceedings of EWHCI '94: East- West Human</region>
        <region class="DoCO:TextChunk" id="18" confidence="possible" page="2" column="1">Computer Interaction, St. Petersburg, Russia, August 1994. Also appears as Technical Report CMU-HCII-94-102.</region>
        <region class="DoCO:TextChunk" id="19" confidence="possible" page="2" column="1">This research was sponsored in part by the Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U. S. Air Force, Wright- Patterson AFB, OH 45433-6543 under Contract F33615-90-C-1465, Arpa Order No. 7597. Support also came from the National Science Foundation under grant number 1R[-9020089. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed -r implied, of NSF, ARPA, or the U.S. Government.</region>
        <outsider class="DoCO:TextBox" type="footer" id="20" page="2" column="1">This I dc .. tCs been ppreâ€¢d for public, r za~ nd i-W.I eits distribun;7.</outsider>
        <region class="DoCO:FigureBox" id="Fx21">
          <image class="DoCO:Figure" src="62ly.page_002.image_02.png" thmb="62ly.page_002.image_02-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="22" page="3" column="1">Keywords: Programming by Demonstration, Hierarchical Event Histories, Application Interface, User Interfaces, Intelligent Interfaces, End-User Programming</region>
        <region class="DoCO:FigureBox" id="Fx23">
          <image class="DoCO:Figure" src="62ly.page_003.image_03.png" thmb="62ly.page_003.image_03-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="24" confidence="possible" page="4" column="1">Abstract</region>
        <region class="DoCO:TextChunk" id="25" page="4" column="1">Programming by Demonstration, or PBD, is an exciting and developing branch of HCI research. With PBD techniques, end-users can add function. ality to their environments without programming in the conventional sense. Virtually all research into PBD, however, presumes that the event history is a linear sequence of user actions. This paper challenges that notion by intro- ducing Hierarchical Event Histories, a new approach which represents some of the end-user's task structure directly in the event history. PBD systems can then take advantage of this structure to operate more correctly and in more situations. To assist programmers in generating structured histories, we also present Hieractors, a new model that provides a simple and clear syntax for describing arbitrary, high-level application behaviors. Accesion For</region>
        <region class="unknown" id="26" page="4" column="1">NTIS CRA&amp;I</region>
        <region class="DoCO:TextChunk" id="27" confidence="possible" page="4" column="1">DTIC TAS Una8inoL,-ced Justification</region>
        <region class="unknown" id="28" page="4" column="1">Dis nL .......</region>
        <region class="unknown" id="29" page="4" column="1">"Dist/</region>
        <region class="DoCO:TextChunk" id="30" confidence="possible" page="4" column="1">Availability Codes lAva an-- rid or Special</region>
        <outsider class="DoCO:TextBox" type="footer" id="31" page="4" column="1">-..</outsider>
        <region class="DoCO:FigureBox" id="Fx32">
          <image class="DoCO:Figure" src="62ly.page_004.image_04.png" thmb="62ly.page_004.image_04-thumb.png"/>
        </region>
        <region class="unknown" id="33" page="5" column="1">1</region>
      </section>
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="34" page="5" column="1">Introduction</h1>
        <region class="DoCO:TextChunk" id="35" page="5" column="1">In the early days of computers, there was little distinction between the programmer and the end-user. Programs were designed to solve a particular task, and to be used exclusively by programmers. Today, this could hardly be less true. Programs such as word processors, spreadsheets, and databases are designed to be very general and apply to a large class of problems. Contemporary end-users, meanwhile, have little or no experience or even interest in programming. These two trends have created a problem: generic software packages must be customized to suit end-users' specific needs, but many end-users have no means available to them to do such customization. This often results in end-users performing tedious, repetitive tasks that computers could have performed for them. For example, consider the simple task of using a word processor to insert a line number before each line in a large document. We posed this problem to a small sample of our colleagues, and they all came to the same conclusion: programming. Some considered Emacs macros, or Hypertalk scripts, or even Unix scripts. However, not one respondent knew how to perform this task without programming. In fact, in virtually all word processors, there is no other alternative. Thus, most end-users would have no choice but to painstakingly enter all the line numbers manually. Sadly, a large amount of human-computer interaction is exactly this sort of tedium.</region>
        <region class="DoCO:TextChunk" id="36" confidence="possible" page="5" column="1">1.1 Programming by Demonstration</region>
        <region class="DoCO:TextChunk" id="46" page="5" column="1">These issues prompted research into Programming by Demonstration, or PBD, an exciting and developing branch of HCI. The basic goal of PBD is to allow end-users to customize their software by demonstrating the desired behavior. In the line numbering example, the user might type "1" on line 1. and "2" on line 2. From this, the PBD system should infer the line numbering task, and perhaps automatically complete the task for the user. Indeed. research systems like Eager [ <xref ref-type="bibr" rid="R3" id="37" class="deo:Reference">3</xref>] can already do this. Other systems have applied PBD to such domains as widget creation [<xref ref-type="bibr" rid="R18" id="38" class="deo:Reference">18</xref>], graphical editing [<xref ref-type="bibr" rid="R15" id="39" class="deo:Reference">15</xref>], and general-purpose programming [<xref ref-type="bibr" rid="R16" id="40" class="deo:Reference">16</xref>]. The key advantage of PBD is that it allows end- users to specify programs in the user interface. They do not have to learn any special syntax or<marker type="page" number="6"/><marker type="block"/> programming constructs. In essence, they do not have to program in the conventional sense, yet they are able to customize their software to suit their particular needs.</region>
        <outsider class="DoCO:TextBox" type="footer" id="42" page="5" column="1">i I i m|</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="43" page="5" column="1">|</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="44" page="5" column="1">1</outsider>
        <region class="DoCO:FigureBox" id="Fx45">
          <image class="DoCO:Figure" src="62ly.page_005.image_05.png" thmb="62ly.page_005.image_05-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="47" confidence="possible" page="6" column="1">1.2 Challenges to PBD</region>
        <region class="DoCO:TextChunk" id="48" page="6" column="1">PBD is a technology of great promise. However, there are numerous problems yet to be solved before PBD will realize its full potential. These include:</region>
        <region class="unknown" id="49" page="6" column="1">"</region>
        <region class="unknown" id="50" page="6" column="1">toggling</region>
        <region class="unknown" id="51" page="6" column="1">"</region>
        <region class="DoCO:TextChunk" id="52" confidence="possible" page="6" column="1">User Intent The primary concern of PBD is determining the user's intent in performing some actions. This requires generalizing the user's actions into a script which runs correctly under different circumstances. For example, say we have a word processor which has a Style menu and one of this menu's choices is Bold. Selecting Bold toggles the boldness of the selected text. We next demonstrate a script where we only select Bold from the Style menu. What should happen when we replay the script? This is unclear. We might have intended to record setting the text to bold. However, we also might have intended to record the boldness of the text. Moreover, the difficulty of determining user intent grows quickly as the complexity of scripts increases. Context PBD systems often require access to the context in which a demonstration occurs. For example, if the user's intention was to set the text to bold, the inferred script should resemble the following:</region>
        <region class="DoCO:TextChunk" id="53" confidence="possible" page="6" column="1">unless &lt;the-selected-text-is-bold&gt; selectt "Bold" from the "Style" menu</region>
        <region class="DoCO:TextChunk" id="54" confidence="possible" page="6" column="1">The unless is necessary to prevent toggling when the selected text is already bold. To create this script, the PBD system must know whether the selected text was bold during the demonstration (i.e., it must have accessed some context of the word processor). This poses several unsolved problems; specifically, how should the PBD system - determine the available context from an application? - access the context? - reason over the context?</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="55" page="6" column="1">2</outsider>
        <region class="DoCO:FigureBox" id="Fx56">
          <image class="DoCO:Figure" src="62ly.page_006.image_06.png" thmb="62ly.page_006.image_06-thumb.png"/>
        </region>
        <region class="unknown" id="57" page="7" column="1">"*</region>
        <region class="DoCO:TextChunk" id="59" confidence="possible" page="7" column="1">* Script Matching Many behaviors are too complex to infer from a single demonstration. In this case, users must give multiple demonstrations, showing how the script runs in different situations. Conditionals are the most common case: as users can demonstrate only one branch at a time, conditionals require multiple demonstrations. This presents a problem: given two demonstrations of the same script, the PBD system must match the scripts, determining which steps are the same and which differ (and, ultimately, why they differ). Matching can be complicated because there can be several ways of accomplishing the same task, and users may be inconsistent across examples. For example, a desktop interface might support file deletion either by dragging the file icon to the trash icon, or first selecting the file icon and then selecting Delete from the File menu. While both methods satisfy the same high-level goal, few existing PBD systems could match them. This may generate a useless rule for selecting which method to use, which then may require more examples than are strictly necessary to learn the behavior. Anticipation Feedback Script mismatches can be reduced with Anticipation Feedback, as demon- strated in Eager [<xref ref-type="bibr" rid="R3" id="58" class="deo:Reference">3</xref>]. With this approach, the PBD system encourages consistency across examples by providing feedback indicating what event the PBD system anticipates will next occur. For example, if the PBD system anticipates that the user will select a certain button, it may highlight the button in green. The user can then perform the action, or tell the PBD system to do it. In any case, if selecting the button is a reasonable alternative, the user is more likely to do so. Developers wishing to include Anticipation Feedback in their applications must address the reverse-mapping problem: if the PBD system records events at a high level (as most do), these high-level events must be mapped back into widget-level events for anticipation. To accomplish this, the PBD system must first be aware of the possible mappings. Second, it must choose one, probably the same one the user last chose. Indeed, Eager includes special code to do this. The challenge is to provide this to PBD systems in a general manner.</region>
        <region class="unknown" id="60" page="7" column="1">"*</region>
        <region class="DoCO:TextChunk" id="62" confidence="possible" page="7" column="1">Invocation In [<xref ref-type="bibr" rid="R14" id="61" class="deo:Reference">14</xref>], we propose that PBD systems should allow users to not only demonstrate their programs but to also demonstrate when to</region>
        <region class="unknown" id="63" page="7" column="1">invoke</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="64" page="7" column="1">3</outsider>
        <region class="DoCO:FigureBox" id="Fx65">
          <image class="DoCO:Figure" src="62ly.page_007.image_07.png" thmb="62ly.page_007.image_07-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="66" confidence="possible" page="8" column="1">those programs. Furthermore, there should not be restrictions on the kinds of events which invoke programs. Most PBD systems support a small, fixed selection of invoking events, such as clicking on certain icons or choosing certain menu items. This limits the utility of the PBD system, however. For example, say that a user wishes to copy all files to a backup directory before they are deleted. The script which performs the copying is easy to demonstrate, but most systems could not invoke the script before each Delete-File event. Thus, expanding the invocation techniques extends PBD to solve problems it otherwise could not.</region>
        <region class="DoCO:TextChunk" id="68" page="8" column="1">This is by no means an exhaustive list. Other issues include how to represent the inferred script, allow the user to edit the script, and recover from errors while running the script. A more complete discussion of these issues is in [<xref ref-type="bibr" rid="R5" id="67" class="deo:Reference">5</xref>].</region>
        <region class="DoCO:TextChunk" id="69" confidence="possible" page="8" column="1">1.3 High-Level Event Histories</region>
        <region class="DoCO:TextChunk" id="74" page="8" column="1">A major factor in the quality of a PBD system is the level at which events are recorded. PBD systems based on device-level events (i.e., mouse and keyboard events) are very unreliable. For example, if a House-Down event selected some object, replaying the same event would select the same object only if the object is uncovered, in the same location, and not selected. Indeed, the same Mouse-Down event might invoke other, possibly destructive behavior. In response to these concerns, various notions of high-level events were developed. High-level events vary by system, but generally equate to user actions such as Delete-File, Make-Bold, and Quit-Application. In these systems, an application processes low-level events in the normal manner until it determines that a high-level event should be performed. This event is then passed to the PBD system, where it is recorded, then back to the application, where it is finally executed. Thus, PBD systems can ignore device-level events, and reason over high-level event histories. This produces scripts which are more correct, more efficient, and more understandable. <marker type="page" number="9"/><marker type="block"/> The same arguments that favor high-level events over device-level events, however, also favor even higher-level events. Moreover, there is an occasional need for low-level events, too. For example, consider the user of a word processor saving the current file under the name "foo". To do this, she first selects Save from the File menu. This generates a dialog box for specifying the filename. There is a default value-the current filename-so she enters control-u to delete the text. She then enters the new name. Finally, she clicks on the "OK" button. How should the event history depict this sequence?</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="71" page="8" column="1">4</outsider>
        <region class="DoCO:FigureBox" id="Fx72">
          <image class="DoCO:Figure" src="62ly.page_008.image_08.png" thmb="62ly.page_008.image_08-thumb.png"/>
        </region>
        <region class="unknown" id="73" page="9" column="1">2 Hierarchical Event Histories</region>
        <region class="DoCO:TextChunk" id="75" confidence="possible" page="9" column="1">One possibility is a single high-level event, namely Save-File("foo"). This has the virtues listed in the previous section on high-level events. Unfortunately, it is also limiting. The most compelling argument is based on correctnes--occasionally, only device-level events accurately portray the user's intent. Say the user demonstrates making a backup copy by append- ing ".bak" to the current filename. If the current filename is "foo", the macro should save the backup as "foo.bak". To demonstrate this, the user brings up the dialog box from the previous example, but does not delete the filename. Instead, she appends to it by typing ".bak". Then she clicks on the "OK" button. How should this sequence appear in the history? The corresponding high-level event is Save-File ("foo. bak"). Replay- ing this when the current filename is "bar", however, would produce a file called "foo.bak", not "bar.bak". An advanced PBD system might fix this with context and inferencing, generalizing the event to: Save-File (append *current-filename* ".bak") However, the PBD system might require vast time and space resources to make this inference. Even worse, it might fail to infer this at all. Notice, however, that the net effect of the device-level events is equivalent to the generalized Save-File event. Thus, if device-level events are in the event history, they can be replayed directly, and no inferencing is necessary! Including low-level events in the history has additional benefits for PBD and other areas as well. In the file-saving example, events such as Open-Dialog, Set-String, and Close-Dialog can be applied to:</region>
        <region class="unknown" id="76" page="9" column="1">help</region>
        <region class="DoCO:TextChunk" id="77" confidence="possible" page="9" column="1">. Invocation: A third-party vendor might provide a macro-based facility for the word processor. This might include a window with</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="78" page="9" column="1">5</outsider>
        <region class="DoCO:FigureBox" id="Fx79">
          <image class="DoCO:Figure" src="62ly.page_009.image_09.png" thmb="62ly.page_009.image_09-thumb.png"/>
        </region>
        <region class="unknown" id="80" page="10" column="1">"*</region>
        <region class="unknown" id="81" page="10" column="1">"</region>
        <region class="DoCO:TextChunk" id="82" confidence="possible" page="10" column="1">some text on how to specify the filename when saving a file. The help facility would include a macro which displays this window upon the Open-Dialog event, and another macro which hides the window upon the Close-Dialog event. Similarly, another vendor might supply an automatic spell-checker which is invoked by the Set -String event. Undo: Suppose the user errantly typed control-u and deleted the current filename. In most systems, she must then retype the entire filename or abort the save operation. Including low-level events in the event stream, however, allows her to Undo the errant Key-Press. Anticipation feedback: Say that the PBD system correctly anticipates that the user will next issue a Save-File event. How should this be conveyed to the user? This is the reverse-mapping problem mentioned above. If the widget-level events are in the event history, the PBD system can iteratively anticipate those.</region>
        <region class="DoCO:TextChunk" id="90" page="10" column="1">Thus, many different levels of events should be included in the history. However, it is semantically incorrect to include multiple event levels in a linear event stream. That is, the history cannot be flat, as in <xref ref-type="fig" rid="F1" id="83" class="deo:Reference">Figure 1</xref>. If<marker type="block"/> this sequence were played back, the device-level events would generate extra instances of each high-level event. This would result in three Close-Dialog events, for example. Thus, if multiple event levels are in the event stream. the event stream itself cannot be linear-it must reflect the actual hierarchy of events. In this example, it must be structured as in <xref ref-type="fig" rid="F2" id="89" class="deo:Reference">Figure 2</xref>.</region>
        <region class="unknown" id="85" page="10" column="1">Uâ€¢ -et.Ueu-.Itmu ' Pile') olsloq('S PRW) Key.us(-.") Kâ€¢y-Pfu-so) Ke"MP604b11) Key.pV..se(W</region>
        <region class="unknown" id="86" page="10" column="1">Sot-String('foo.belk') Movee-Dow"</region>
        <region class="unknown" id="87" page="10" column="1">sMect-outtou4uOK') clmOW00Wrsave Me-) Saw-PIIN'fo.aUk')</region>
        <region class="DoCO:FigureBox" id="F1">
          <caption class="deo:Caption" id="88" page="10" column="1">Figure 1: A flat history comprised of multiple levels of events.</caption>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="91" page="10" column="1">6</outsider>
        <region class="DoCO:FigureBox" id="Fx92">
          <image class="DoCO:Figure" src="62ly.page_010.image_10.png" thmb="62ly.page_010.image_10-thumb.png"/>
        </region>
        <region class="unknown" id="93" page="11" column="1">UOue.40Z-p"â€¢4e~de0t-Uludenugm-,-Oen-OIauog " K,4- e.m'.') " ('1 ' 'PI.ea ) ('-, Pâ€¢l')|</region>
        <region class="unknown" id="94" page="11" column="1">inuee-Up --- Lele.Ct~g tun-c aee---- ie W,- PII-0 ('OK') ('lava Pil') ('fm.ba)</region>
        <region class="DoCO:TextChunk" id="96" confidence="possible" page="11" column="1"> <xref ref-type="fig" rid="F2" id="95" class="deo:Reference">Figure 2</xref>: The same history as in Figure 1, but here we show the hierarchical structure.</region>
        <region class="DoCO:TextChunk" id="97" confidence="possible" page="11" column="1">This argument is the basis for Hierar'chicalEvent Histories. We propose that applications should be structured so that they generate histories such as the one above. This will allow PBD systems, Undo facilities, and other history mechanisms to operate more correctly and in more situations.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="98" page="11" column="1">3 The Hieractors Model</h1>
        <region class="DoCO:TextChunk" id="99" confidence="possible" page="11" column="1">For hierarchical event histories to be feasible, there must be a simple way for application designers to generate them in the first place. We attacked this problem in three ways. First, we hoped to infer the structure based on the read-write patterns of the event handlers. This approach is ideal from the programmer's perspective, since it would work with unmodified code. Unfortunately, while we could infer the partial sequential order of events over time, read-write patterns alone do not provide enough information to completely determine the hierarchical structure.</region>
        <region class="DoCO:TextChunk" id="100" confidence="possible" page="11" column="1">We then tried the opposite approach, requiring the programmer to ex- plicitly construct the hierarchy. To that end, we provided functions such as Creat~e-Event;, Add-Child, and Set-Parent. This approach worked fine for simple cases, but did not scale well. As we attacked harder problems, we had to repeatedly add new history-manipulation functions. These became so unwieldy that it was impractical to continue in this direction.</region>
        <region class="DoCO:TextChunk" id="101" confidence="possible" page="11" column="1">From these efforts we concluded that: * programmers should be responsible for generating the event hierarchy; and * there should be some architectural support to simplify this process.</region>
        <outsider class="DoCO:TextBox" type="footer" id="102" page="11" column="1">K-ey, in i i</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="103" page="11" column="1">7</outsider>
        <region class="DoCO:FigureBox" id="Fx104">
          <image class="DoCO:Figure" src="62ly.page_011.image_11.png" thmb="62ly.page_011.image_11-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="106" page="12" column="1">We satisfied these criteria by developing Hieractors, a new model for ex- pressing high-level behaviors. Hieractors (from Hierarchical Interactors) are inspired by the Interactors model [<xref ref-type="bibr" rid="R19" id="105" class="deo:Reference">19</xref>]. Interactors are effective in describing widget-level interface behaviors. Hieractors generalize this model to provide a simple and clear syntax for describing arbitrary, high-level application behaviors. The basic idea behind hieractors is that most application behaviors are naturally defined in terms of the events which start, run, stop, and abort them. For example, consider the behavior of selecting a button in a graphical interface. The hieractor providing this behavior would start on a Mouse-Down in the button, run on Mouse-Moves, and stop on a Mouse-Up in the button (aborting on other Mouse-Ups). This behavior is supplied by the following code fragment:</region>
        <region class="DoCO:TextChunk" id="107" confidence="possible" page="12" column="1">(create-instance 'Button-Behavior *hieractor* (:result-type 'Select-Button) (:start-when 'Mouse-Down) (:running-when 'Mouse-Move) (:stop-vhen '(Mouse-Up :where in-original-button?)) (:abort-vhen '(Mouse-Up :where outside-original-button?))</region>
        <region class="DoCO:TextChunk" id="111" page="12" column="1">When a hieractor completes, it issues a higher-level event (in this example, a Select-Button event). The children of this event are precisely the events which triggered the start, running, and stop actions. This leads to the simple, but hierarchical, history seen in Figure 3. <marker type="block"/> High-level events can also start, run, stop, or abort even higher-level behaviors. This leads to more complex hierarchical histories, such as the history depicted in the file saving example above. To illustrate, the Save-File event from that example could have been generated by the following:</region>
        <region class="unknown" id="109" page="12" column="1">Nouue.Ove</region>
        <region class="DoCO:FigureBox" id="F3">
          <caption class="deo:Caption" id="110" page="12" column="1">Figure 3: A simple hierarchical history for selecting a button.</caption>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="112" page="12" column="1">8</outsider>
        <region class="DoCO:FigureBox" id="Fx113">
          <image class="DoCO:Figure" src="62ly.page_012.image_12.png" thmb="62ly.page_012.image_12-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="114" confidence="possible" page="13" column="1">(create-instance 'File-Savor *hieractor* (:result-type 'Save-File)</region>
        <region class="unknown" id="115" page="13" column="1">(:start-vhen '(Open-Dialog :where save-file-dialog?)) (:running-when 'Set-String)</region>
        <region class="DoCO:TextChunk" id="116" confidence="possible" page="13" column="1">(:stop-when '(Close-Dialog :where save-file-dialog?))</region>
        <region class="unknown" id="117" page="13" column="1">(:abort-when '(Abort-Dialog :where save-file-dialog?))</region>
        <region class="DoCO:TextChunk" id="118" confidence="possible" page="13" column="1">Expressing the common high-level application behaviors required some extensions to this model, the most important being:</region>
        <region class="unknown" id="119" page="13" column="1">"" Event Combinations Some behaviors make a transition (i.e., start, run, stop, or abort) after a sequence of events. For example, in a calculator, the Add-Numbers behavior starts on an Enter-Number followed by a Select-Button where the selected button's label is "+". Similarly, transitions can occur after either of two (or more) events.</region>
        <region class="unknown" id="120" page="13" column="1">"* Scoping When a hieractor, such as the "file-saver" above, is defined, it is at- tached to an object called its scope. The hieractor can only observe events which pass through this scope. For widgets, the scope usually corresponds to the graphical objects making up the widget. Thus, mouse clicks over a scrollbar are not needlessly processed by, say, the menubar in the same window. Sometimes behaviors must observe events from multiple widgets, or events that are not even associated with widgets. These behaviors can have a scope of any window, any application, or the entire system (where they observe every event). Behaviors sometimes start in one scope, but run in another. For example, consider moving an object in a graphical editor. When idle. this behavior should wait for a Mouse-Down event inside an object. Once running, however, it must observe Mouse-Move events anywhere in the window. For this reason, behaviors can specify a separate running scope. For convenience, this can be specified relative to the initial scope. In the example, the running scope is :window, meaning what- ever window the object is in.</region>
        <region class="unknown" id="121" page="13" column="1">e Priorities It is possible (and common) for two hieractors to claim the same event.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="122" page="13" column="1">9</outsider>
        <region class="DoCO:FigureBox" id="Fx123">
          <image class="DoCO:Figure" src="62ly.page_013.image_13.png" thmb="62ly.page_013.image_13-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="124" confidence="possible" page="14" column="1">In fact, the same hieractor can make multiple claims on a single event. For example, consider editing a one-line text field. This starts on any Key-Press event, but it also runs over other Key-Press events, and stops when the user hits Return. This is specified as:</region>
        <region class="DoCO:TextChunk" id="125" confidence="possible" page="14" column="1">(create-instance 'Simple-Text-Editor *hieractor* (:start-when 'Key-Press) (:running-when 'Key-Press) (:stop-when '(Key-Press :where return-key?))</region>
        <region class="DoCO:TextChunk" id="126" confidence="possible" page="14" column="1">Say the user types "H", then "i", then Return. The "H" unambigu- ously starts the hieractor. The "i", however, can either be a running event or another start event. Which transition should be favored by the event dispatcher? One solution is to disallow hieractors from starting while running. This is unnecessary and restrictive, however. Instead, transitions have integer priorities, where the larger priority is favored (and ties are decided randomly). Also, priorities can be absolute, or relative to the start priority. By default, abort events have the highest priority, followed by stop events, running events, and finally start events. Thus, for example, the text editor would process the "i" as a running event.</region>
        <region class="DoCO:TextChunk" id="127" page="14" column="1">A more complete discussion of Hieractors is given in (131. Note, however, that we have satisfied the design critera for Hieractors. First, the programmer, not the PBD system, defines the structure of the application. Second, Hieractors provide significant architectural support to assist in this task. Our experiences indicate that programming with Hieractors requires about the same effort as conventional programming. However, Hieractors provide hierarchical event histories, with all their advantages.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="128" page="14" column="1">4 Advantages of Hierarchical Event Histories</h1>
        <region class="DoCO:TextChunk" id="129" page="14" column="1">The key advantage to our model is that it represents some of the end-user's task structure directly in the event history. PBD systems can then take advantage of this structure to operate more correctly and in more situations. Referring back to the vario-s challenges facing PBD systems, hierarchical event histories address many of these issues:</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="130" page="14" column="1">10</outsider>
        <region class="DoCO:FigureBox" id="Fx131">
          <image class="DoCO:Figure" src="62ly.page_014.image_14.png" thmb="62ly.page_014.image_14-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="132" confidence="possible" page="15" column="1">User Intent Hierarchical event histories can aid in determining user intent because they expose more levels of user actions to the PBD system. Each level of the event hierarchy is typically a specialization of the level below it, corresponding to the effect the lower level events have in the current context. For example, consider when the user selects Bold from the Style menu. This would produce a Toggle-Bold event, which then produces a Set-Bold event in some contexts and a Clear-Bold event in others. Thus, the history contains both the toggle and setting (or clearing) behaviors, enabling the PBD system to offer both options to the end-user without making any inferences!</region>
        <region class="unknown" id="133" page="15" column="1">a</region>
        <region class="unknown" id="134" page="15" column="1">*</region>
        <region class="DoCO:TextChunk" id="135" confidence="possible" page="15" column="1">* Context While our approach does not address the context problem directly, it does reduce the situations in which context is even necessary. Or, to rephrase this, hierarchical event histories extend the coverage of PBD systems which do not have access to application context. This is because high-level events implicitly include some context, as just described. Note that this is only a partial solution, however, as the user's intent may depend on context that is not implicit in the hierarchy. Even in these cases, however, the PBD system can select from the various levels to choose which should be generalized. Script Matching One cause of mismatched events in multiple scripts is when there are multiple ways to perform some action, as in the file deletion example from above. Hierarchical event histories can reduce script mismatches in many of these cases, as the mismatched low-level events may be children of easily matchable high-level events. For example, say the user first demonstrates deleting a file by dragging it to the trash. and later demonstrates the same step by selecting the file and selecting Delete from the File menu. While the low-level events are completely different, both actions will produce the same high-level event, namely Delete-File, thus making the matching a trivial task. While this does not solve the generalization problem (i.e., what the arguments to the Delete-File should be), at least it advances the PBD system to that step. Anticipation Feedback Hierarchical event histories provide exactly the low-level support needed</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="136" page="15" column="1">11</outsider>
        <region class="DoCO:FigureBox" id="Fx137">
          <image class="DoCO:Figure" src="62ly.page_015.image_15.png" thmb="62ly.page_015.image_15-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="138" confidence="possible" page="16" column="1">to solve the reverse-mapping problem for Anticipation Feedback. This is because the recorded script contains the widget-level events. This enables the PBD system to anticipate an event above the widget level by iteratively anticipating the low-level events it comprises.</region>
        <region class="DoCO:TextChunk" id="139" confidence="possible" page="16" column="1">* Invocation PBD systems that allow arbitrary events to invoke user-defined programs can further benefit from hierarchical event histories. Including high-level events such as Delete-File in the event history allows programs to be invoked when these events occur. Moreover, including low-level events such as Key-Preus and Select-Button in the event history supports the invocation techniques currently available to users. By exposing more levels of a user's task structure, our approach gives users more control over how and when their programs are invoked.</region>
        <region class="DoCO:TextChunk" id="140" page="16" column="1">There are additional benefits to hierarchical event histories. For example, by allowing recorded scripts to be replayed at the highest semantically correct level, they can be more efficient than linear events. Also, while out- side the scope of this paper, hierarchical event histories benefit other parts of HCI, such as Undo, Help, and Task Analysis.</region>
      </section>
      <section class="deo:RelatedWork">
        <h1 class="DoCO:SectionTitle" id="141" page="16" column="1">5 Related Work</h1>
        <region class="DoCO:TextChunk" id="165" page="16" column="1">For people interested in learning more about Programming by Demonstration, [ <xref ref-type="bibr" rid="R4" id="142" class="deo:Reference">4</xref>] presents a thorough overview and history of the field and describes the current state-of-the-art. The crucial problem of determining user intent was first described in (9]. While many systems have made inroads on this problem, perhaps the most promising is Cima [<xref ref-type="bibr" rid="R17" id="143" class="deo:Reference">17</xref>], a learning architecture being developed specifically for PBD systems. We are currently pursuing ways to integrate our work with the Cima environment. While there are many user interface specification techniques (such as [<xref ref-type="bibr" rid="R10" id="144" class="deo:Reference">10</xref>, <xref ref-type="bibr" rid="R12" id="145" class="deo:Reference">12</xref>, <xref ref-type="bibr" rid="R8" id="146" class="deo:Reference">8</xref>]), these do not address the nature of the event history. Approaches such as TAG [<xref ref-type="bibr" rid="R21" id="147" class="deo:Reference">21</xref>] and GOMS [<xref ref-type="bibr" rid="R2" id="148" class="deo:Reference">2</xref>] do consider the hierarchical task structure, but not how to generate such a history (i.e., they are analytical, not constructive). A more hybrid approach is taken in Task-Oriented Parsing [<xref ref-type="bibr" rid="R11" id="149" class="deo:Reference">11</xref>], which is somewhat constructive and hierarchical. It is based on context-free grammars, however, which are less powerful than event-based models, and<marker type="page" number="17"/><marker type="block"/> cannot describe some important user interface behaviors [<xref ref-type="bibr" rid="R8" id="153" class="deo:Reference">8</xref>]. Moreover, their approach is not truly constructive because they provide "normal feedback" only for "meaningful tasks", and not "all [user] input actions." The simpler high-level event model is supported by numerous ... tems. In particular, most model-based UIMS's, including MIKE [<xref ref-type="bibr" rid="R6" id="154" class="deo:Reference">6</xref>], [71, Humanoid [221, and others. We extended Garnet [<xref ref-type="bibr" rid="R20" id="155" class="deo:Reference">20</xref>] because of c per- tise with that model, and because the resulting Hieractors model ui clear, concise, and efficient. It seems reasonable that other model-based UIMS's could be adapted to generate hierarchical event histories as well. Also, Apple Events [<xref ref-type="bibr" rid="R1" id="156" class="deo:Reference">1</xref>] are a high-level event paradigm now employed by a large and growing vendor population. Because of this, we are considering converting Hieractors to operate over Apple Events.<marker type="block"/> The ideas presented here serve as the basis for Katie [<xref ref-type="bibr" rid="R13" id="159" class="deo:Reference">13</xref>], an application environment which includes a Hieractors interpreter for the basic model with the extensions listed in this paper. Katie also includes two widget sets (a basic set and a more complicated Motif look-and-feel set), several small applications, and a larger database-type application. At this point, we have proven the viability of the Hieractors model for generating hierarchical event histories. The next phase of this research will focus on the graphical presentation and manipulation of the structured history, and the many applications of hierarchical event histories.<marker type="block"/> We would like to thank Allen Cypher, Francesmary Modugno, and James Landay for their help with this paper. This research was sponsored by the Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U. S. Air Force, Wright-Patterson AFB, OH 45433-6543 under Contract F33615-90- C-1465, Arpa Order No. 7597. The views and conclusions contained in this document are those of the<marker type="page" number="18"/><marker type="block"/> authors and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="151" page="16" column="1">12</outsider>
        <region class="DoCO:FigureBox" id="Fx152">
          <image class="DoCO:Figure" src="62ly.page_016.image_16.png" thmb="62ly.page_016.image_16-thumb.png"/>
        </region>
        <region class="unknown" id="158" page="17" column="1">6 Status and Future Work</region>
        <region class="unknown" id="161" page="17" column="1">7 Acknowledgments</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="163" page="17" column="1">13</outsider>
        <region class="DoCO:FigureBox" id="Fx164">
          <image class="DoCO:Figure" src="62ly.page_017.image_17.png" thmb="62ly.page_017.image_17-thumb.png"/>
        </region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="166" confidence="possible" page="18" column="1">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="167" confidence="possible" page="18" column="1">[1] Apple Computer, Inc. Inside Macintosh Volume VI. Addison-Wesley, Reading, MA, 1991.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="168" confidence="possible" page="18" column="1">[2] Stuart K. Card, Thomas P. Moran, and Allen Newell. The Psychology of Human-Computer Interaction. Lawrence Erlbaum, Hillsdale, NJ, 1983. [31 Allen Cypher. Eager: Programming repetative tasks by example. In Human Factors in Computing Systems, pages 33-40, New Orleans, April 1991. ACM SIGCHI.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="169" confidence="possible" page="18" column="1">[4] Allen Cypher, editor. Watch What I Do: Programming by Demonstration. MIT Press, Cambridge, MA, 1993.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="170" confidence="possible" page="18" column="1">[5] Allen Cypher, David S. Kosbie, and David Maulsby. Characterizing PBD systems. In Allen Cypher, editor, Watch What I Do: Programming by Demonstration, pages 467-484. MIT Press, Cambridge, MA, 1993.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="171" confidence="possible" page="18" column="1">[6] Jr. Dan R. Olsen. Mike: The menu interaction kontrol environment. ACM Transactions on Graphics, 5(4):318-344, October 1986.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="172" confidence="possible" page="18" column="1">[7] James Foley, Won Chul Kim, Srdjan Kovacevic, and Kevin Murray. Defining interfaces at a high level of abstraction. IEEE Software. 6(1):25-32, January 1989. [81 Mark Green. A survey of three dialog models. ACM Transactions on Graphics, 5(3):244-275, July 1986.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="173" confidence="possible" page="18" column="1">[9] Daniel C. Halbert. SmallStar: Programming by demonstration in the desktop metaphor. In Allen Cypher, editor, Watch What I Do: Programming by Demonstration, pages 103-124. MIT Press, Cambridge. MA, 1993.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="174" confidence="possible" page="18" column="1">[10] H. Rex Hartson, Antonio C. Siochi, and Deborah Hix. The UAN: A user-oriented representation for direct manipulation interface designs. ACM Transactions on Information Systems, 8(3):181-203, July 1990.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="177" confidence="possible" page="19" column="1">[11] Heinz Ulrich Hoppe. A grammar-based approach to unifying task- oriented and system-oriented interface descriptions. In D. Ackermann and M.J. Tauber, editors, Mental Models and Human-Computer Interaction 1, pages 353-374. North-Holland, New York, 1990.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="178" confidence="possible" page="19" column="1">[12] Robert J.K. Jacob. A specification language for direct manipulation interfaces. ACM Transactions on Graphics, 5(4):283-317, October 1986.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="179" confidence="possible" page="19" column="1">[131 David S. Kosbie. Hierarchical event histories. PhD thesis. In prepara- tion, 1994.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="180" confidence="possible" page="19" column="1">[14) David S. Kosbie and Brad A. Myers. PBD invocation techniques: A review and proposal. In Allen Cypher, editor, Watch What I Do: Programming by Demonstration, pages 423-432. MIT Press, Cambridge, MA, 1993.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="181" confidence="possible" page="19" column="1">[15] David Kurlander and Steven Feiner. Editable graphical histories. In Workshop on Visual Languages, pages 127-134, Pittsburgh, October 1988. IEEE.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="182" confidence="possible" page="19" column="1">[16] Henry Lieberman. Tinker: A programming by demonstration system for beginning programmers. In Allen Cypher, editor, Watch What I Do: Programming by Demonstration, pages 49-66. MIT Press, Cambridge, MA, 1993.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="183" confidence="possible" page="19" column="1">[17] David Maulsby. Instructible Agents. PhD thesis, University of Calgary, Calgary, Alberta, Canada, 1994. PhD thesis.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="184" confidence="possible" page="19" column="1">[18] Brad A. Myers. Creating User Interfaces by Demonstration. Academic Press, Boston, 1988.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="185" confidence="possible" page="19" column="1">[19] Brad A. Myers. A new model for handling input. ACM Transactions on Information Systems, 8(3):289-320. July 1990.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="186" confidence="possible" page="19" column="1">[20] Brad A. Myers et al. Garnet: Comprehensive support for graphical, highly-interactive user interfaces. IEEE Computer, 23(11):71-85. November 1990.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="187" confidence="possible" page="19" column="1">[21] Franz Sciele and Thomas Green. HCI formalisms and cognitive psychol- ogy: The case of task-action grammar. In Michael Harrison and Harold Thimbleby, editors, Formal Methods in Human-Computer Interaction. pages 9-62. Cambridge University Press, Cambridge, 1990.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="190" confidence="possible" page="20" column="1">(22] Pedro Szekely, Ping Luo, and Robert Neches. Facilitating the explo- ration of interface design alternatives: The Humanoid model of interface design. In Human Factors in Computing Systems, pages 507-515, Monterrey, CA, May 1992. ACM SIGCHI.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="page_nr" id="175" page="18" column="1">14</outsider>
        <region class="DoCO:FigureBox" id="Fx176">
          <image class="DoCO:Figure" src="62ly.page_018.image_18.png" thmb="62ly.page_018.image_18-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="188" page="19" column="1">15</outsider>
        <region class="DoCO:FigureBox" id="Fx189">
          <image class="DoCO:Figure" src="62ly.page_019.image_19.png" thmb="62ly.page_019.image_19-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="191" page="20" column="1">16</outsider>
        <region class="DoCO:FigureBox" id="Fx192">
          <image class="DoCO:Figure" src="62ly.page_020.image_20.png" thmb="62ly.page_020.image_20-thumb.png"/>
        </region>
      </section>
    </body>
  </article>
</pdfx>
