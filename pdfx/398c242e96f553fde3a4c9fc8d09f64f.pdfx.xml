<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>6c7102ffa2b1b3d6badc8ed8ac0c027b5bf2c5038577954c3b5f60f3e987f6ac</job>
    <base_name>62dl</base_name>
    <doi>10.1145/1656250.1656252</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Synthesizing Hierarchical State Machines from Expressive Scenario Descriptions</article-title>
      </title-group>
      <outsider class="DoCO:TextBox" type="sidenote" id="2">8</outsider>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="3">JON WHITTLE Lancaster University</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="4">PRAVEEN K. JAYARAMAN George Mason University</name>
        </contrib>
      </contrib-group>
      <abstract class="DoCO:Abstract" id="5" confidence="possible">There are many examples in the literature of algorithms for synthesizing state machines from scenario-based models. The motivation for these is to automate the transition from scenario-based requirements to early behavioral design models. To date, however, these synthesis algorithms have tended to generate flat state machines which can be difficult to understand or adapt for practical systems. One of the reasons for this is that relationships between scenarios are often not taken into account during synthesis—either because the relationships are not explicitly defined or because the synthesis algorithms are not sophisticated enough to cope with them. If relationships are not considered, it is impossible for a synthesis algorithm to know, for example, where one scenario stops and another continues. Furthermore, the lack of relationships makes it difficult to introduce structure into the generated state machines. With the introduction of interaction overview diagrams (IODs) in UML2.0, relationships such as continuation and concurrency can now be specified between scenarios in a way that conforms to the UML standard. But synthesis algorithms do not currently exist that take into account all of these relationships. This article presents a novel synthesis algorithm for an extended version of interaction overview diagram. This algorithm takes into account not only continuation and concurrency, but also preemption, suspension and the notion of a negative scenario. Furthermore, the synthesis algorithm generates well-structured state machines. These state machines are executable and can therefore be used to validate the scenarios. The hierarchy generated aids readability and so the state machines are more amenable to subsequent design steps. Our IOD extensions have a formal semantics and are supported by a synthesis and execution tool, UCSIM, which is currently provided as a plug-in to IBM Rational Software Modeler.</abstract>
      <region class="DoCO:TextChunk" id="10" confidence="possible">The work described in this article is an extension of work described in two previous articles, Whittle and Jayaraman [2006] and Jayaraman and Whittle [2007]. Authors’ addresses: J. Whittle, Computing Department, InfoLab21, South Drive, Lancaster University, Lancaster LA1 4AW U.K.; email: <email id="6">whittle@comp.lancs.ac.uk</email>; P. K. Jayaraman, Department of Computer Science, George Mason University, 4400 University Drive MSN 4A5, Fairfax, VA 22030; email: <email id="7">praveenjayaraman@yahoo.com</email>. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212) 869-0481, or <email id="8">permissions@acm.org</email>. C 2010 ACM 1049-331X/2010/01-ART8 $10.00 DOI 10.1145/1656250.1656252 <ext-link ext-link-type="uri" href="http://doi.acm.org/10.1145/1656250.1656252" id="9">http://doi.acm.org/10.1145/1656250.1656252</ext-link></region>
      <outsider class="DoCO:TextBox" type="footer" id="11">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
      <outsider class="DoCO:TextBox" type="header" id="12">8:2</outsider>
      <outsider class="DoCO:TextBox" type="header" id="13">•</outsider>
      <outsider class="DoCO:TextBox" type="header" id="14">J. Whittle and P. K. Jayaraman</outsider>
      <section class="DoCO:Section">
        <h2 class="DoCO:SectionTitle" id="15" confidence="possible" page="2" column="1">Engineering]: Engineering]:</h2>
        <region class="DoCO:TextChunk" id="16" confidence="possible" page="2" column="1">Categories and Subject Descriptors: D.2.1 [Software Requirements/Specifica- tions—Languages; Tools; D.2.2 [Software Design Tools and Techniques—Object- oriented design methods; state diagrams General Terms: Design, Languages Additional Key Words and Phrases: State machine synthesis, scenario-based requirements, interaction overview diagrams, software modeling</region>
      </section>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="17" confidence="possible" page="2" column="1">ACM</h1>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="18" confidence="possible" page="2" column="1">Reference Format:</h2>
          <region class="DoCO:TextChunk" id="20" confidence="possible" page="2" column="1">Whittle, J. and Jayaraman, P. K. 2010. Synthesizing hierarchical state machines from expressive scenario descriptions. ACM Trans. Softw. Eng. Methodol. 19, 3, Article 8 (January 2010), 45 pages. DOI = 10.1145/1656250.1656252 <ext-link ext-link-type="uri" href="http://doi.acm.org/10.1145/1656250.1656252" id="19">http://doi.acm.org/10.1145/1656250.1656252</ext-link></region>
        </section>
      </section>
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="21" page="2" column="1">1. INTRODUCTION</h1>
        <region class="DoCO:TextChunk" id="35" page="2" column="1">One of the popular methods of choice for eliciting and analyzing requirements is scenario-based requirements engineering [Alexander and Maiden 2004]. A scenario is an expected execution trace of the system under development. Scenarios are widely used in industry (see, e.g., Weidenhaupt et al. [1998]) because they are easy to understand, relatively straightforward to create, and give step-by- step “stories” of how the system will operate. Scenarios can be captured both during requirements elicitation and requirements analysis. In requirements elicitation, scenarios are typically used to describe use cases [Jacobson et al. 1992] and treat the system as a black box. In requirements analysis, scenarios show the interactions between internal system components needed to realize a use case. Since use cases are a part of most major UML-based OOAD methodologies, scenarios have gained widespread appeal. In UML [O <xref ref-type="bibr" rid="R29" id="22" class="deo:Reference">MG 2007</xref>], scenarios can be described using interaction diagrams (e.g., UML sequence diagrams). For reactive systems, it is also important to model state-dependent behavior using some form of finite state machine (FSM). In fact, many OOAD methodologies give guidance on how to derive initial FSM models directly from use case descriptions given as interaction diagrams. Many authors (e.g., Harel et al. [2005], Kr uger  ̈ [2000], M akinen  ̈ and Syst a  ̈ [2002], Uchitel et al. [2003], Whittle [2005b], Whittle and Schumann [2000]) have tried to automate this transition from interaction diagrams to FSMs. This is important research for the following reasons. First, it automates a key activity of many OOAD processes and therefore can save developers valuable time. Second, it transforms scenarios into an executable form (namely, FSMs). Since FSMs are executable, they can be simulated. Hence, automation of the transformation is a way of simulating scenario-based requirements. This simulation can be used in requirements validation. The transition from interaction diagrams to finite state machines is essentially from a global view of object interactions to a local, object-based view. Each interaction diagram contributes to the state-based definition of one or more objects participating in the interaction, and each object may participate in multiple interaction diagrams. It is this fundamental mismatch between the global and local view that makes synthesis nontrivial. A synthesis algorithm must not only consider the behavior of a given object in one scenario, but must unify all of the object’s behavior from multiple scenarios.<marker type="page" number="3"/><marker type="block"/> Early research considered each scenario in isolation and therefore could not generate state machines that unified the behavior of the same object appear- ing in different scenarios. Researchers quickly realized that unification of the object’s behavior was crucial and a number of strategies were invented to deal with the problem. Before UML2.0, scenario-based specifications often did not make explicit the relationships between scenarios. In other words, scenarios were written in isolation and their associations (e.g., continuation, overlapping, parallelism) were not specified. This was partly because early versions of UML did not support the specification of these relationships. In the absence of scenario relationships, synthesis algorithms have taken one of two approaches to elicit them. Either the algorithm infers the relationships (e.g., M akinen  ̈ and Syst a  ̈ [2002] used inductive learning to do this) or the algorithm requires the scenario writer to explicitly give the relationships in some form (e.g., by explicitly identifying overlapping states [Kr uger  ̈ 2000]). The inference approach is problematic because it results in false positives. Specification of explicit relationships is problematic because it may rely on a nonstandard methodology with which users are not familiar. With the introduction of interaction overview diagrams (IODs) in UML2.0 [O<xref ref-type="bibr" rid="R29" id="28" class="deo:Reference">MG 2007</xref>], developers were given standard ways for specifying relationships between scenarios, in much the same way that high-level Message Sequence Charts (hMSCs) [ITU 2004] had been used in the telecommunications industry. There remain, however, fundamental gaps in synthesis algorithm technology. First, existing synthesis algorithms do not yet consider the full range of relationships that can be specified in IODs. Some works [Uchitel et al. 2003b, 2004] presented a synthesis algorithm for hMSCs but they include only continuation. IODs allow concurrency to be specified and, in fact, this article will introduce new relationships not currently available in IODs. Second, existing synthesis algorithms generate flat state machines which can be difficult to understand or adapt for practical systems. This article addresses both of these limitations of current synthesis algorithms. It presents a novel synthesis algorithm for an extension of IODs that includes not only relationships such as continuation and concurrency, but also additional relationships found to be useful in specifying distributed, concurrent systems, namely, preemption, suspension, and the notion of negative scenario. The synthesis algorithm presented generates hierarchical state machines that make use of UML’s structuring mechanisms for state machines, namely, composite states and orthogonal regions. This makes the generated state machines easier to read and, therefore, means that they can be used in subsequent design steps. The synthesis algorithm presented in the article works on an extension of IODs that was first introduced in Whittle [2005] and given a formal semantics in Whittle [2007]. The key contribution of this article is the synthesis algorithm. The main application of this algorithm to date has been to simulate scenarios, but the generated FSMs could also be used in test generation and automated verification. In summary, our synthesis algorithm goes beyond previous synthesis algorithms because<marker type="page" number="4"/><marker type="block"/> —it takes into account a rich set of relationships between scenarios such as preemption, parallelism, and negation; —it synthesizes hierarchical state machines which can be built upon in subsequent analysis and design steps. The synthesis algorithm has been implemented in the UCSIM tool [Jayaraman and Whittle 2007; Whittle and Jayaraman 2006]. This tool allows its users to describe scenarios for a system under development, including complex and rich relationships between scenarios. The tool synthesizes a set of hierarchical state machines from the scenario description—in particular, one hierarchical state machine is generated for each state-dependent object. UCSIM comes with an FSM simulator so that the generated state machines can be simulated, which helps the user to debug the scenarios. Finally, UCSIM is designed as a vendor- independent tool that can be integrated with existing UML modeling tools. So far, UCSIM has been integrated with IBM Rational Software Modeler (RSM) [<xref ref-type="bibr" rid="R17" id="34" class="deo:Reference">IBM 2008</xref>]. Users draw scenarios in RSM, generate state machines from within RSM, and simulate those state machines in RSM. The architecture of UCSIM is such that integration with other modeling tools is straightforward. The remainder of this article is organized as follows. Section 2 presents back- ground and describes the scenario input language for our synthesis algorithm. Section 3 is the main contribution—the algorithm itself. Section 4 describes the UCSIM tool and discusses our experiences using UCSIM. Section 5 compares the approach to related work and, Section 6 gives our conclusions. The online appendix at ACM’s Digital Library 1 contains a full description of the synthesis algorithm, presented as pseudocode.</region>
        <outsider class="DoCO:TextBox" type="footer" id="24" page="2" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="25" page="3" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="26" page="3" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="27" page="3" column="1">8:3</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="30" page="3" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="31" page="4" column="1">8:4</outsider>
        <outsider class="DoCO:TextBox" type="header" id="32" page="4" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="33" page="4" column="1">J. Whittle and P. K. Jayaraman</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="36" page="4" column="1">2. SCENARIO DESCRIPTIONS</h1>
        <region class="DoCO:TextChunk" id="37" page="4" column="1">In this article, scenarios will be described using an extension of UML interaction overview diagrams. We briefly review IODs and then motivate extensions to IODs that both we and other authors have found to be useful. This extended scenario description language will be called EIODs (extended IODs). Furthermore, we advocate a particular way of modeling with EIODs and introduce that in this section also. Finally, we give an overview of the semantics of EIODs so that it can be compared with the semantics of the state machines generated by our synthesis algorithm in Section 3.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="38" page="4" column="1">2.1 Interaction Overview Diagrams</h2>
          <region class="DoCO:TextChunk" id="59" page="4" column="1">The 2.0 release of UML introduced interaction overview diagrams (IODs), a notation based on activity diagrams, for specifying relationships between interactions. IODs are based on high-level message sequence charts (hMSCs) [ <xref ref-type="bibr" rid="R19" id="39" class="deo:Reference">ITU 2004</xref>], a well-established notation for specifying interactions originally developed for the telecommunications domain. IODs are a graph-oriented way of specifying relationships between UML interaction diagrams (see <xref ref-type="fig" rid="F1" id="40" class="deo:Reference">Figure 1</xref>). A sequence diagram is one way of defining an interaction (see <xref ref-type="fig" rid="F1(b)" id="41" class="deo:Reference">Figure 1(b)</xref>). Participants in this interaction are denoted by vertical lines called lifelines that<marker type="page" number="5"/><marker type="block"/> capture the progression of time vertically down the page. Interactions between participants are shown by messages, drawn as edges, connecting two lifelines. The direction of the edge shows which participant initiates the interaction. Messages can be synchronous or asynchronous and are labeled with message names. The UML standard interprets the semantics of messages in terms of send and receive events, corresponding to the sending or receipt of a message by a participant. Events are partially ordered by weak sequential composition that defines the following: (1) events on the same lifeline are ordered according to their vertical location; (2) a message’s send event always comes before its receive event. Weak sequential composition means that sometimes the intuitive vertical ordering of messages is not respected in the semantics. For example, two messages without a common lifeline may occur in any order irrespective of their vertical positioning when drawn graphically. UML2.0 introduced interaction fragments as a way of increasing the expressiveness of sequence diagrams. An interaction fragment (see <xref ref-type="fig" rid="F1(b" id="50" class="deo:Reference">Figure 1(b)</xref>) is a box defining a subset of the messages in a sequence diagram and stating that the messages within the fragment are optional, alternatives to each other, can execute in parallel, or should not be allowed. Each fragment is defined by an operator, which states the connection between the fragment’s messages, and one or more operands. The operators considered in this paper are alt, opt, par, neg, and seq opt and neg have one operand and define that the operand’s messages are optional or should not be allowed, respectively. alt and par have two or more operands and define that the messages within each of the operands are<marker type="page" number="6"/><marker type="block"/> either alternatives or can run in parallel, respectively. seq is used to explicitly mark that a sequence of messages is joined by weak sequential composition (the default in UML). UML includes state invariants as a way of defining states in sequence diagrams. State invariants are essentially labels that can be used to identify different points along the lifeline of a participant (or participants). Before their introduction into UML2.0, they were called state labels by other authors (e.g., Kr uger  ̈ [2000], Whittle et al. [2005b]). State invariants are useful to capture the fact that two points along a lifeline are meant to be the same. For example, they are an easy way to define loops (see <xref ref-type="fig" rid="F1(b" id="56" class="deo:Reference">Figure 1(b)</xref>) or to identify points in different sequence diagrams. State invariants allow very fine-grained connections between sequence diagrams. In this article, we do not allow state invariants to be drawn across multiple lifelines. UML2.0 defines other operands as well but they will not be considered here. Neither will this article consider any of the other many modeling constructs for UML sequence diagrams, such as dynamic creation and destruction of participants, timing constraints, and the modeling of data. A formal semantics for some of the more common interaction operators was given in Haugen et al. [2005]. An alternative semantics was given in Grosu and Smolka [2005]. Interaction overview diagrams are a restricted form of UML activity diagram for capturing some kinds of relationships between interactions (see <xref ref-type="fig" rid="F1(a)" id="57" class="deo:Reference">Figure 1(a)</xref>). Each node in the activity graph is a reference to an interaction and the edges between activity nodes allow the definition of relationships between interactions, such as parallel execution, alternatives, and control flow. The references in <xref ref-type="fig" rid="F1(a)" id="58" class="deo:Reference">Figure 1(a)</xref> are to sequence diagrams, although the references could also be to communication diagrams or other interaction overview diagrams.</region>
          <region class="unknown" id="43" page="4" column="1">1 www.acm.org.</region>
          <outsider class="DoCO:TextBox" type="footer" id="44" page="4" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="45" page="5" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="46" page="5" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="47" page="5" column="1">8:5</outsider>
          <region class="unknown" id="48" page="5" column="1">initial node name of interaction ref interactions sd seqDiag to run in parallel participant a:A b:B interaction ref ref fragment state operator interaction send event par x alternative interactions y ref ref seqDiag state receive event life line state invariant defining final node reference to a loop interaction (a) (b)</region>
          <region class="DoCO:FigureBox" id="F1">
            <caption class="deo:Caption" id="49" page="5" column="1">Fig. 1. UML interaction overview diagrams (a) and sequence diagrams (b).</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="52" page="5" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="53" page="6" column="1">8:6</outsider>
          <outsider class="DoCO:TextBox" type="header" id="54" page="6" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="55" page="6" column="1">J. Whittle and P. K. Jayaraman</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="60" page="6" column="1">2.2 Extended Interaction Overview Diagrams</h2>
          <region class="DoCO:TextChunk" id="106" page="6" column="1">2.2.1 Introduction. According to the UML specification ([O <xref ref-type="bibr" rid="R29" id="61" class="deo:Reference">MG 2007</xref>], p. 512), “Interaction Overview Diagrams define Interactions . . . through a variant of Activity Diagrams . . . in a way that promotes overview of the control flow.” The exact nature of this “variant,” however, is never made clear. The specification lists five differences between IODs and standard activity diagrams. The first of these states that all nodes in an IOD are interactions (or references to interactions). The fifth states that forking and joining of branches must be properly nested. The remaining three differences relate mainly to presentation issues. In the absence of additional information, therefore, one can assume that all other activity diagram concepts transfer to IODs. However, activity diagrams are extremely rich in expressiveness and some concepts do not necessarily make sense when applied to interaction modeling. For example, activity diagrams include the notions of concurrent node executions, interruptible regions and flow final nodes. Reading the UML specification strictly, these concepts can also be used in an IOD. However, their semantics is far from clear when applied in an IOD. In this article, as the input language for our synthesis algorithm, we use an extended form of interaction overview diagram (EIOD) that includes additional<marker type="page" number="7"/><marker type="block"/> constructs from activity diagrams not normally considered for IODs (cf., for example, Grosu and Smolka [2005]; Haugen et al. [2005]). Specifically, EIODs allow those additional constructs from activity diagrams which are shown in <xref ref-type="fig" rid="F2" id="69" class="deo:Reference">Figure 2</xref>. <xref ref-type="fig" rid="F2(a)" id="70" class="deo:Reference">Figure 2(a)</xref> shows an interruptible activity region. The dotted box is an activity group that scopes nodes and edges. An interruptible activity region is an activity group that can be interrupted—shown by the lightning bolt. If an interrupting event occurs, all activities within the region are stopped. <xref ref-type="fig" rid="F2(b)" id="71" class="deo:Reference">Figure 2(b)</xref> shows an activity with the keyword &lt;&lt;singleCopy&gt;&gt; which denotes that all invocations of the activity are handled by the same execution. This is in contrast to allowing a separate copy of the activity to handle each new invocation of the activity. The latter is the default semantics if the &lt;&lt;singleCopy&gt;&gt; keyword is not shown. If an activity is marked with &lt;&lt;singleCopy&gt;&gt;, then a new invocation of the activity may have to wait until a previous invocation has completed. For example, a Process Order activity marked as &lt;&lt;singleCopy&gt;&gt; would only allow one order to be processed at a time, whereas if separate copies are allowed, then multiple orders can be processed simultaneously. The UML activity semantics is token-based (as in Petri Nets) and so activity invocation corresponds to the receipt of a new token. As we shall see, there are no tokens in the usual semantics for interactions, so the notion of &lt;&lt;singleCopy&gt;&gt; must be reinterpreted for interaction diagrams. <xref ref-type="fig" rid="F2(c)" id="72" class="deo:Reference">Figure 2(c)</xref> shows a final flow node which terminates the current flow but does not terminate the activity diagram. These constructs will be referred to in the next subsections where their use in interaction diagrams is motivated and their semantic interpretation for the usual trace semantics of interactions is defined. Furthermore, EIODs will include the notion of scoped negation, defined in the next subsection, which means that a behavior can be marked as undesired if that behavior occurs during the execution of a particular group of nodes. This is an extension to UML whereby interruptible regions are used to define negative behaviors.<marker type="block"/> 2.2.2 Motivation for Extending IODs. EIODs extend IODs with new scenario constructs, namely, preemption, suspension, multiple concurrent node executions, final flow, and scoped negation. Although some of these constructs exist in activity diagrams, they are not usually considered to be part of IODs. EIODs have a formal semantics [Whittle 2007] which builds upon the semantics of Haugen et al. [2005] for IODs. We briefly motivate the extensions that<marker type="page" number="8"/><marker type="block"/> we propose. As will be seen in Section 2.2.4, we follow a use case-based methodology in this article. Our goal is to be able to specify use case scenarios in a way that they are executable. <xref ref-type="fig" rid="F3" id="81" class="deo:Reference">Figure 3</xref> shows the use case diagram for a hypothetical system which sends data to a number of distributed clients. New clients may connect to this system and disconnect from the system. Periodically, an external timer triggers a data update procedure which distributes updated data to all connected clients. The Administrator has two use cases—maintain the system, and abort the data update procedure. Standard use case-driven development processes elaborate each use case by drawing a set of UML interaction diagrams which can be connected using an interaction overview diagram. Such a process may leave issues unspecified that are important to capture in the requirements specification, particularly if automated use case execution or analysis is required. For example, in this application, IODs cannot address the following issues: (1) Can more than one client connect at the same time? (2) How does abort affect a data update process that is already underway? (3) Can a client disconnect during the data update process? To answer these questions, we can construct an IOD in which each use case is an IOD node. Constructs from activity diagrams could be used to answer questions (1) and (2), but the semantics of these constructs is not obvious when applied to IODs. Question (1) could be handled by marking the Connect use case as an interaction that may have multiple executions. That is, the keyword &lt;&lt;singleCopy&gt;&gt; would not be applied to the Connect interaction. In this case, every time the Connect interaction is invoked (e.g., by a new client request),<marker type="page" number="9"/><marker type="block"/> a new execution thread would be created to handle the request. For question (2), the modeler may decide that an abort interrupts an ongoing data update. This could be handled using the notion of an interruptible region from activity diagrams. For question (3), suppose that the modeler decides that a client should never disconnect during the update process. This is an example of a negative use case—a use case that should be outlawed by the eventual design (e.g., by dis- abling the client disconnect feature during an update). Although possible, it can be awkward to specify negation using IODs. From a syntactical point of view, using activity diagram constructs to answer these questions is straightforward, as detailed in the previous two paragraphs. The semantics of such a model, however, is another question altogether. UML does not yet have a formal semantics definition for activity diagrams (cf. Störrle [2005]; Störrle and Hausmann [2005]) and the informal semantics given in the UML specification [O<xref ref-type="bibr" rid="R29" id="89" class="deo:Reference">MG 2007</xref>] is not well suited for scenario-based descriptions. Neither do existing semantics for IODs define these constructs precisely.<marker type="block"/> 2.2.3 Extensions. Extended interaction overview diagrams address the issues identified in the previous subsection by extending IODs with constructs from activity diagrams and by defining their semantics formally. The main extensions are given below (see <xref ref-type="fig" rid="F4" id="91" class="deo:Reference">Figure 4</xref>):<marker type="block"/> (1) Nodes in EIODs may have single or multiple concurrent executions—that is, &lt;&lt;singleCopy&gt;&gt; is allowed in EIODs. For convenience, we prefer the UML1.x notation for single/multiple copies over that of UML2.x—that is, we define the default to be a single execution and mark activities with<marker type="page" number="10"/><marker type="block"/> multiple executions with an asterisk. Most interactions tend to be single copy so this way turns out to be more convenient. In addition, we extend the notion of multiple copies to sets of nodes and borrow the concept of activity group from interruptible regions to allow this. Thus, in <xref ref-type="fig" rid="F4(b)" id="98" class="deo:Reference">Figure 4(b)</xref>, M1 may have multiple executions at once. Once they have all completed, the next interaction can execute. If both interactions were grouped into a region with an asterisk applied to the region, then the entire composed interaction could have multiple copies occurring in parallel. (2) EIODs allow interruptible regions, but define two types of interrupt—one for preemption and one for suspension. The type is denoted by a stereotype &lt;&lt;preempted&gt;&gt; or &lt;&lt;suspended&gt;&gt; attached to the lightning bolt for an interruptible activity region. The difference between preempt and suspend is that, for preempt, the interrupted interaction is never returned to, whereas, for suspend, once the suspending interaction is complete, control returns to the interrupted interaction at the point where it was interrupted. <xref ref-type="fig" rid="F4(a)" id="99" class="deo:Reference">Figure 4(a)</xref> shows two IOD nodes (i.e., interactions) that are suspended by another node. If the first message in the suspending interaction (i.e., S1) occurs at any point during the interruptible region, then the messages in the region are suspended and the suspending interaction takes over. Once it completes, control returns to the region at the point where it left off. There is a similar stereotype &lt;&lt;preempted&gt;&gt; which has the same semantics except that control does not return to the region. (3) EIODs also include a notion of scoped negation. Although negation can be modeled in IODs by referencing a sequence diagram which includes a neg fragment, we allow a negative scenario to be scoped over an activity group. That is, the scenario is negative only if it occurs during the execution of activities in the activity group. <xref ref-type="fig" rid="F4(c)" id="100" class="deo:Reference">Figure 4(c)</xref> shows negation in an EIOD. Negation is scoped over a set of nodes. So the interaction N1 cannot occur at any point during the execution of the interactions covered by the region. (4) EIODs include the notion of a flow final node which can be used to show that a scenario results in failure. <xref ref-type="fig" rid="F4(d)" id="101" class="deo:Reference">Figure 4(d)</xref> shows an EIOD nested within another EIOD. The upper part of <xref ref-type="fig" rid="F4(d)" id="102" class="deo:Reference">Figure 4(d)</xref> shows the control flow between two interactions, IOD1 and IOD2. The lower part shows the definition of IOD1 and includes a final node and a flow final node. In EIODs, the semantics of these final nodes is as follows. For a nested node, flow only continues beyond the nested node if a final node is reached in the EIOD which defines the nested node. So flow only continues from IOD1 to IOD2 if the final node in the definition of IOD1 is reached. If the flow final node is reached instead, then flow ends with IOD1 and does not continue on to IOD2. (5) EIODs also introduce a minor extension to UML sequence diagrams, namely, the all and exist interaction fragments (see <xref ref-type="fig" rid="F9" id="103" class="deo:Reference">Figure 9</xref> later for an example of all). If a participant has multiple instances (for example, Client in Abort Update in <xref ref-type="fig" rid="F9" id="104" class="deo:Reference">Figure 9</xref>), and a message is sent to this participant and is enclosed by an all fragment, then the message should be sent to all instances of the participant. In <xref ref-type="fig" rid="F9" id="105" class="deo:Reference">Figure 9</xref>, for the Abort Update sequence, abort is sent to all instances of Client. exist is similar and is useful to describe</region>
          <outsider class="DoCO:TextBox" type="footer" id="63" page="6" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="64" page="7" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="65" page="7" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="66" page="7" column="1">8:7</outsider>
          <region class="unknown" id="67" page="7" column="1">&lt;&lt;singleCopy&gt;&gt; interruptible activity single copy flow final node region (a) (b) (c)</region>
          <region class="DoCO:FigureBox" id="F2">
            <caption class="deo:Caption" id="68" page="7" column="1">Fig. 2. Additional activity diagram constructs.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="75" page="7" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="76" page="8" column="1">8:8</outsider>
          <outsider class="DoCO:TextBox" type="header" id="77" page="8" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="78" page="8" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="79" page="8" column="1">Connect Update Data Disconnect Timer Client Maintain Administrator Abort Update</region>
          <region class="DoCO:FigureBox" id="F3">
            <caption class="deo:Caption" id="80" page="8" column="1">Fig. 3. Use case diagram for distributed data propagation.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="83" page="8" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="84" page="9" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="85" page="9" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="86" page="9" column="1">8:9</outsider>
          <region class="unknown" id="87" page="9" column="1">ref &lt;&lt;suspended&gt;&gt; ref M1 * ref S1 ref ref (a) (b) ref ref IOD1 IOD2 ref &lt;&lt;neg&gt;&gt; ref Definition of IOD1 N1 ref ref ref ref (c) (d)</region>
          <region class="DoCO:FigureBox" id="F4">
            <caption class="deo:Caption" id="88" page="9" column="1">Fig. 4. EIOD constructs.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="94" page="9" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="95" page="10" column="1">8:10</outsider>
          <outsider class="DoCO:TextBox" type="header" id="96" page="10" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="97" page="10" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="107" page="10" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="108" page="11" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="109" page="11" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="110" page="11" column="1">8:11</outsider>
          <region class="unknown" id="111" page="11" column="1">use case node Level 1: use case flow (use case EIOD) &lt;&lt;defined by&gt;&gt; * Level 2: scenario flow (scenario EIOD) scenario node Level 3: scenarios (interaction diagram) &lt;&lt;defined by&gt;&gt;</region>
          <region class="DoCO:FigureBox" id="F5">
            <caption class="deo:Caption" id="112" page="11" column="1">Fig. 5. Use case charts—using EIODs to describe use cases.</caption>
          </region>
          <region class="DoCO:TextChunk" id="113" confidence="possible" page="11" column="1">that a message must be sent to or received from at least one instance of a participant.</region>
          <region class="DoCO:TextChunk" id="167" page="11" column="1">2.2.4 Methodology for Using EIODs. In this article, we assume a use case- based methodology and advocate a three-layered specification using extended interaction overview diagrams to define use case scenarios. We call this structured specification a use case chart. The idea is illustrated in <xref ref-type="fig" rid="F5" id="114" class="deo:Reference">Figure 5</xref>. For the purposes of the article, a use case is considered to be a set of scenarios. A use case chart specifies the scenarios for a system’s use cases as a three-level description: level 1 is an EIOD in which the nodes are use cases; level 2 is a set of EIODs where the nodes are scenarios; level 3 is a set of sequence diagrams. Each level 1 use case node is defined by a level 2 EIOD. Each level 2 scenario node is defined by a sequence diagram. A use case chart is just a particular way of using EIODs in which —at the top level, relationships are given between use cases (i.e., references to EIODs that define the use cases), and —three levels of specification are used. EIODs allow any number of nested levels of interaction diagram but only three levels will be used in this article to simplify the presentation of the synthesis algorithm. The control flow of a use case chart starts with the initial node of the use case chart (at level 1). Flow then passes between use case nodes along the edges of the level 1 EIOD. When flow reaches a use case node at level 1, the level 2 EIOD defining this node is executed, with flow starting from the EIOD’s initial node. Flow exits a scenario node (at level 2) when a final node is reached. Level 2 EIODs may have two types of final nodes—a final node represents successful<marker type="page" number="12"/><marker type="block"/> completion of the scenario and a flow final node represents completion but with failure. Flow only continues beyond the current use case node if a final node is reached in the use case’s defining EIOD. The semantics of each level 2 EIOD is the same as level 1 except that, when a scenario node is entered, control passes to the level 3 sequence diagram that defines it. When the sequence diagram completes, flow returns to level 2, exits the current scenario node at that level, and continues with the next scenario node.<marker type="block"/> 2.2.5 Example Revisited. This section illustrates the nonstandard constructs of EIODs by defining a use case chart for the distributed data management system introduced earlier. <xref ref-type="fig" rid="F6" id="123" class="deo:Reference">Figure 6</xref> gives the level 1 EIOD for this example. It shows the use cases as well as their relationships. <xref ref-type="fig" rid="F6" id="124" class="deo:Reference">Figure 6</xref> gives the complete control flow of the system use cases. A maintenance procedure is ongoing. At the same time, clients can connect and disconnect. While connected, they receive periodic data updates. The connection and/or data update procedure is preempted if an abort is invoked. Note that any number of clients can connect (as denoted by the asterisk). The asterisk covers the activity group containing three use cases—Connect, Update Data, and Disconnect. The meaning of this is that any number of copies of these three use cases can be executing simultaneously. In other words, clients can connect at any time, and, once they are connected, they receive updates or can choose to disconnect. The diamond choice operator in <xref ref-type="fig" rid="F6" id="125" class="deo:Reference">Figure 6</xref> may or may not have guards attached to it. If there are no guards, the first message in each branch decides which branch is taken. Level 2 of the use case chart refines each of the use case nodes at level 1 by providing an EIOD to describe the scenarios that form part of the use case and the relationships between those scenarios—the nodes are scenarios and the edges are scenario relationships. A complete use case chart will include one level 2 EIOD for each use case, although, of course, partial use case charts can<marker type="page" number="13"/><marker type="block"/> be defined. Figures 7 and 8 give the level 2 definitions for the use cases Connect and Update Data, respectively. <xref ref-type="fig" rid="F7" id="135" class="deo:Reference">Figure 7</xref> shows the level 2 EIOD for the Connect use case. A client attempts to connect but a failure can occur during connection. In the case of success, the final node is reached and so control returns to level 1 of the use case chart. In this case, control passes to the next use case (Update Data or Disconnect depending on which occurs first). If the connection fails, the flow final node is reached. In this case, control does not pass back to level 1—that is, this particular thread is terminated—and so Update Data or Disconnect will not occur. <xref ref-type="fig" rid="F8" id="136" class="deo:Reference">Figure 8</xref> illustrates the use of scoped negation. It specifies that clients may not request a connection during the preparation or sending of data, although this is allowed during the scenario Finalize Data. At the lowest level (level 3), each level 2 EIOD is defined by a sequence diagram. Hence, an entire use case chart defines a set of connected sequence diagrams—each level 2 EIOD connects its sequence diagrams and then each<marker type="page" number="14"/><marker type="block"/> level 1 EIOD connects a set of level 2 EIODs. For completeness, the level 3 sequence diagrams are given in <xref ref-type="fig" rid="F9" id="144" class="deo:Reference">Figure 9</xref>. These will be referred to in Section 3.4 where the generated hierarchical state machines for this example are presented. The sequence diagrams are named—these names match the references in Figures 7 and 8. Note the use of the all fragment in Abort Update to send aborts to all active client instances. The Registry object is used to store details of currently connected clients. The Controller is the main state-dependent object, responsible for coordinating connections and data updates.<marker type="block"/> 2.2.6 Semantics. This subsection defines the syntax and semantics of EIODs. A fully formal treatment is beyond the scope of this article and so only enough detail will be provided to understand the synthesis algorithm in Section 3. In particular, we will make some simplifying assumptions for the purposes of the synthesis algorithm. A complete and formal definition of the EIOD semantics can be found in Whittle [2007]. Below is a definition of the abstract syntax of EIODs. The concrete syntax has already been described via examples.<marker type="block"/> Definition 1 (EIOD). An EIOD is a graph of the form (S, R S , E S , s o , s f , s f , L S , f s , m s ) where S is a set of interaction nodes, R S is a set of node sets, s o ∈ S is the unique initial node, s f ∈ S is the unique final node, s f ∈ S is the unique flow final node, L S is a set of interaction references (each reference is to an EIOD or sequence diagram), f s : (S\{s f , s f }) → L S is a total, injective function mapping each interaction node to a reference, and m S : R S → {+, −} is a total function marking whether or not each node set can have multiple concurrent<marker type="page" number="15"/><marker type="block"/> executions. Final and flow final nodes are optional and do not have defining references. There must be an initial node. E S is the set of edges. Edges can be of type normal, fork, join, preempting, suspending, and neg, that is:<marker type="block"/> E S = E S norm ∪ E S f ork ∪ E S j oin ∪ E S preempting ∪ E S suspend ing ∪ E S ne g , where E S norm ⊆ (S × S); E S f ork ⊆ (S × P (S)); E S j oin ⊆ (P (S) × S); E S preempting ⊆ (R S × S); E S suspend ing ⊆ (R S × S); E S ne g ⊆ (R S × S). For edges (s i , s j ) ∈ E S f ork , |s j | &gt; 1. For (s i , s j ) ∈ E S j oin, |s i | &gt; 1. The definition describes a graph whose edges may be continuation, parallel fork, and join, negation, preemption, and suspension. Conditions are omitted for simplicity (but could easily be added by including condition labels). A normal edge defines basic control flow and is therefore from a single source interaction node to a single target interaction node. A fork introduces a parallel branch and so is from a node to a node set. Similarly, a join is from a node set to a single node. We assume, without loss of generality, that fork and join edges are binary. A preempting edge is from a node set to a single node—the node set is preempted by the single node. (Node sets capture regions in our abstract syntax.) Suspending edges are similar. Negative edges have a node set as source and a single node as target, meaning that the target should never happen during the scope of the source. Node sets are not allowed to overlap. This definition is the most general form of a definition for EIODs. However, we make some simplifying restrictions here to make the presentation of the synthesis algorithm in Section 3 simpler. These restrictions are as follows: —We follow the three-level structure for EIODs described in Section 2.2.4. In particular, at level 1, there is no flow final node. —We restrict EIODs to those with well-nested fork/join branches and such that there are no recursive interaction references. This means that an EIOD can be written as a term, which simplifies the presentation of the synthesis algorithm greatly. In general, EIODs (and their semantics in Whittle [2007]) need not follow this restriction. —We impose a precedence ordering so that concurrent executions take precedence over edges. This ensures a unique interpretation. For example, concurrent executions take precedence over preempting edges so, in <xref ref-type="fig" rid="F6" id="153" class="deo:Reference">Figure 6</xref>, the preempting edge will interrupt all concurrent connections. We do not show the abstract syntax for sequence diagrams (i.e., level 3 of a use case chart) since it is almost the same as the official UML specification. The only difference is the new interaction operators all and exist. The following sketches the EIOD semantics. The full formal definition is too lengthy to include here but more details can be found in Whittle [2007]. The following definition gives the interpretation of an EIOD in terms of a pair of positive and negative trace sets. A trace is a sequence of events where an event may be the sending or receipt of a message. For a message m, the event of sending a message will be denoted as !m and the event of receiving a message will be denoted as ?m. A trace is well defined if, for each message, the trace<marker type="page" number="16"/><marker type="block"/> contains both a send and receive event for the message, and, furthermore, the send event comes earlier in the sequence than the receive event. Definition 2 (EIOD Semantics). The semantics of an EIOD, U, is a pair of trace sets, (P U , N U ), where P U is the set of (well-defined) positive traces for U and N U is the set of (well-defined) negative traces for U. Positive traces define potential behaviors in any implementation of the EIOD. Negative traces may never occur in a valid implementation of the EIOD. An implementation therefore satisfies an EIOD if a subset of the positive traces are possible in the implementation and no negative traces are possible. For an EIOD, the positive and negative trace sets are found by traversing the graph representation of the EIOD. A trace term is defined to be a path through the graph representation of the EIOD that starts with the initial node and either ends with a final node, a flow final node or is infinite. Trace terms are henceforth written using the operators sseq, preempted by, suspended by, negated by, and par to represent normal, preempting, suspending, neg, and fork/join edges, respectively. A trace term is constructed by traversing the graph (in a way that respects the edge precedence for multiple concurrent executions) and representing each edge by its equivalent operator and each node by the semantics of its interaction reference. For multiple concurrent executions, a traversal may choose to replace the asterisk by any positive number of parallel executions—that is, by a term with any number of par operators. The set of all possible trace terms therefore captures all possible paths through the graph. Each trace term, t, then defines a pair of positive and negative trace sets, t , as we shall see later. The semantics of the EIOD is then the pairwise union of t for all possible trace sets. Definition 3 (EIOD Semantics). For an EIOD, U, the semantics of U is given by U = ∪ { t | t is a trace term for U } where ∪ is the union of pairs: ( p 1 , n 1 ) ∪ ( p 2 , n 2 ) = ( p 1 ∪ p 2 , n 1 ∪ n 2 ). As an example, recall the EIOD in <xref ref-type="fig" rid="F6" id="159" class="deo:Reference">Figure 6</xref>. The following would be one possible trace term for this EIOD: ( M sseq M sseq . . .) par ((( C sseq U sseq . . .) par ( C sseq U sseq . . .)) preempted by A ) where ellipsis denotes that the trace term is infinite and each interaction reference is given by its first letter (e.g., M for Maintain, etc.). Note that there are multiple trace terms for this EIOD—for example, there could be any number of par operators joining ( C sseq U sseq . . .). In this way, the trace terms enumerate all possible positive and negative traces for a given EIOD. The semantics of an interaction node is defined to be the semantics of the reference of the node. That is, for an interaction node, s, s = f S (s) . Since f S (s f ) and f S (s f ) are not defined, s f = s f = ({ }, { }), where is the empty trace. Hence, trace terms such as the one given above for <xref ref-type="fig" rid="F6" id="160" class="deo:Reference">Figure 6</xref> can be fully evaluated by replacing M , etc. with the pair of trace sets defining the semantics of the EIOD which represents them.<marker type="page" number="17"/><marker type="block"/> We have not yet defined the semantics for the operators sseq, par, preempted by, suspended by, and negated by. This will be done next. Follow- ing this, we will finish with a definition of sequence diagram semantics. Each of the operators are binary and have arguments that are pairs of trace sets.<marker type="block"/> 2.2.6.1 Semantics of Preemption and Suspension. The semantics of the operators preempted by and suspended by are similar and will be dealt with together. Consider the term ( X preempted by Y ). The intuition is that the positive traces of X should be interrupted if any positive trace of Y is invoked. In other words, each positive trace in ( X preempted by Y ) is made up of a prefix of a positive trace of X composed (using weak sequentiality) with a positive trace of Y. In contrast, negative traces for ( X preempted by Y ) can be formed in one of two ways. First, negative traces for X remain negative in the composition. Second, any prefix of a positive trace of X composed (again using weak sequentiality) with a negative trace of Y is considered to be negative. Intuitively, this says that X can be preempted by a positive trace of Y but cannot be preempted by a negative trace of Y. The case for suspension is similar except that if the interrupting trace is finite, then once this trace has finished executing, control returns to the interrupted trace at the point where it was interrupted. Formally, the semantics of preemption and suspension are defined below, where c 1 , c 2 are pairs of positive and negative trace sets c = ( p , n ), c = ( p , n ).</region>
          <outsider class="DoCO:TextBox" type="footer" id="116" page="11" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="117" page="12" column="1">8:12</outsider>
          <outsider class="DoCO:TextBox" type="header" id="118" page="12" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="119" page="12" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="120" page="12" column="1">ref Maintain * ref Connect ref Abort Update ref ref Update Data Disconnect &lt;&lt;preempted&gt;&gt;</region>
          <region class="DoCO:FigureBox" id="F6">
            <caption class="deo:Caption" id="121" page="12" column="1">Fig. 6. Data propagation system level 1 EIOD.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="127" page="12" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="128" page="13" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="129" page="13" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="130" page="13" column="1">8:13</outsider>
          <region class="unknown" id="131" page="13" column="1">ref Request Connection ref Handle Failed Connection ref Initialize Client</region>
          <region class="DoCO:FigureBox" id="F7">
            <caption class="deo:Caption" id="132" page="13" column="1">Fig. 7. Level 2 EIOD for connect use case.</caption>
          </region>
          <region class="unknown" id="133" page="13" column="1">ref Prepare Data ref Send &lt;&lt;neg&gt;&gt; Data ref Request ref Finalize Connection Data</region>
          <region class="DoCO:FigureBox" id="F8">
            <caption class="deo:Caption" id="134" page="13" column="1">Fig. 8. Level 2 EIOD for update data use case.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="138" page="13" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="139" page="14" column="1">8:14</outsider>
          <outsider class="DoCO:TextBox" type="header" id="140" page="14" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="141" page="14" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="DoCO:FigureBox" id="F9">
            <image class="DoCO:Figure" src="62dl.page_014.image_01.png" thmb="62dl.page_014.image_01-thumb.png"/>
            <caption class="deo:Caption" id="143" page="14" column="1">Fig. 9. Sequence diagrams.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="148" page="14" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="149" page="15" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="150" page="15" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="151" page="15" column="1">8:15</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="155" page="15" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="156" page="16" column="1">8:16</outsider>
          <outsider class="DoCO:TextBox" type="header" id="157" page="16" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="158" page="16" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="162" page="16" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="163" page="17" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="164" page="17" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="165" page="17" column="1">8:17</outsider>
          <region class="DoCO:TextChunk" id="168" confidence="possible" page="17" column="1">1 1 1 2 2 2 c 1 preempted by c 2 = ( p 1 ∪ ( pre( p 1 ) p 2 ), n 1 ∪ ( pre( p 1 ) n 2 )) c 1 suspended by c 2 = ( p 1 ∪ sus( p 1 , p 2 ), n 1 ∪ sus( p 1 , p 2 ))</region>
          <region class="DoCO:TextChunk" id="179" page="17" column="1">pre(H) is the set of prefixes of traces in the trace set H. sus(H 1 , H 2 ) is the set of traces formed by suspending a trace in H 1 by a trace in H 2 and can easily be defined using trace concatenation. H 1 H 2 is the set of all traces derived by composing (using weak sequential composition) a trace from H 1 with a trace from H 2 . These definitions are not given in full here as they can be defined using basic set theory and trace concatenation. Full details are given in Whittle [2007]. Assuming these notions, the definition of preempted by then says that a positive trace of c 1 preempted by c 2 is either a positive trace of c 1 or is a trace formed by concatenating (using weak sequentiality) a prefix of a positive trace of c 1 with a positive trace of c 2 . A negative trace of c 1 preempted by c 2 is either a negative trace of c 1 or is formed from a prefix of a positive trace of c 1 and a negative trace of c 2 . Suspension is similar except that, instead of prefixes, sus( p 1 , p 2 ) is used, which simply means to split a trace in p 1 into a prefix and its postfix and then to insert (using weak sequentiality) a trace from p 2 in between the prefix and postfix. 2.2.6.2 Semantics of Parallel Edges. As is usual, we define parallel edges by interleaving. For ( X par Y ), positive traces are the interleavings of a positive trace of X with a positive trace of Y. Negative traces are all other combinations: c 1 par c 2 = ( p 1 p 2 , (n 1 p 2 ) ∪ (n 1 n 2 ) ∪ ( p 1 n 2 )) <marker type="page" number="18"/><marker type="block"/> Here, (x 1 x 2 ) simply denotes interleaving of trace sets, that is, all ways of interleaving a trace from x 1 with a trace from x 2 . Again, the formal definition can be found in Whittle [2007]. 2.2.6.3 Semantics of Scoped Negation. As explained previously, the negated by operator allows one to define traces that are not allowed during a certain scope or node set. The semantics of negated by is straightforward. For a term ( X negated by Y ), the positive traces of ( X negated by Y ) are simply the positive traces of X . The negative traces of ( X negated by Y ) are any traces that are interleavings of a trace of Y with a positive trace of X . This, in effect, defines a monitor for traces of Y. If a positive trace of Y occurs at any point, even with events interleaved between its own events, then the negative interaction is said to have occurred. Put another way, the “during” in the phrase “not allowed during a certain scope” is interpreted as interleaving. Formally, ( X negated by Y ) is equivalent to ( X par (neg Y )), where neg simply negates all traces in Y. See below. c 1 negated by c 2 = c 1 par (neg c 2 ) 2.2.6.4 Semantics of Final and Flow Final Nodes. The semantics of final nodes and flow final nodes are encapsulated in the operator sseq. ( X sseq Y ) defines a modified weak sequential composition, taking into account flow final nodes so that, if a trace in X ends in a flow final node, the trace does not continue to Y. More precisely, let X = ( p 1 , n 1 ) and let Y = ( p 2 , n 2 ). Then let f ( p i ) denote the set of positive traces in p i that end in a flow final node and let s( p i ) represent all other positive traces in p i . Similarly, f (n i ) is the set of negative traces in n i ending in a flow final node and s(n i ) represents all other negative traces in n i . Then the positive traces of ( X sseq Y ) can be formed either by taking a trace from f ( p 1 ) or by composing (using weak sequentiality) a trace from s( p 1 ) with a trace from p 2 . Intuitively, this captures the fact that a positive trace can be either a positive trace from X that ends abruptly at a flow final node or can be a concatenation of a continuing trace from X with a trace from Y. The full definition is given below. c 1 sseq c 2 = ( f ( p 1 ) ∪ (s( p 1 ) p 2 ), (s(n 1 ) p 2 ) ∪ (s(n 1 ) n 2 ) ∪ (s( p 1 ) n 2 ) ∪ f (n 2 )) 2.2.6.7 Semantics of Multiple Concurrent Executions. Multiple concurrent node executions are handled simply by replacing X , where X has multiple concurrent executions, with ( X par . . . par X ) for some number of par operators. Since all trace terms are enumerated to obtain the EIOD semantics, all possible numbers of par operators are included. 2.2.6.8 Semantics of UML Sequence Diagrams. Thus far, we have sketched the semantics of levels 1 and 2 of a use case chart. It remains to define the semantics of level 3, that is, UML sequence diagrams. Since a formal presentation is rather long, we refer the reader to existing work on the subject, notably [Haugen et al. 2005], where a semantics, compatible with the definitions given in this article, is given for the sequence diagram interaction operators seq, opt, par, and neg. In fact, our semantics deliberately builds on the one found<marker type="page" number="19"/><marker type="block"/> there. Therefore, we simply restate the definitions from [Haugen et al. 2005] below. If d , d 1 , d 2 are sequence diagrams with d = ( p, n), d 1 = ( p 1 , n 1 ) and d 2 = ( p 2 , n 2 ), then interaction fragments in a sequence diagram are given by neg d , opt d , d 1 alt d 2 , d 1 par d 2 , d 1 seq d 2 . The following definitions then capture the semantics assuming our previous (informal) definitions for and . neg d = ({ }, p ∪ n) opt d = ( p ∪ { }, n) d 1 alt d 2 = ( p 1 ∪ p 2 , n 1 ∪ n 2 ) d 1 par d 2 = ( p 1 p 2 , (n 1 p 2 ) ∪ (n 1 n 2 ) ∪ ( p 1 n 2 )) d 1 seq d 2 = ( p 1 p 2 , (n 1 p 2 ) ∪ (n 1 n 2 ) ∪ ( p 1 n 2 )) Briefly, neg makes all traces negative and, in particular, double negatives do not make a positive. opt produces either the original traces or the empty trace, which implies that the option is not taken. alt simply takes the union of the positive and negative traces. par is defined via interleaving and seq simply defines weak sequential composition for positive and negative traces. The only additions in EIODs to sequence diagrams are the all and exist operators which are defined in detail in Whittle [2007]. Again, it would be lengthy to include those definitions here and so we give only the intuition. Consider first the interaction operator all applied to a single event trace, all e 1 , e 2 , . . . . The resulting traces are all those that can be derived by replacing each e i by a set of events, as follows. For a send event sent to a multiobject, the event is sent to all instances of the multiobject, so replace e i by a set of send events, one for each instance. For a send event sent from a multiobject, the event is sent from all instances of the multiobject. For a receive event received by a multiobject, the event is received by all instances of the multiobject. Finally, for a receive event received from a multiobject, the event is received from each instance of the multiobject. In the case of exist, the replacement set does not correspond to all instances of the multiobject, but any nonzero number of them. In other words, at least one of the multiobject instances is involved in the interaction. The choice of the subset of instances involved is made once for each exist fragment. This same procedure can be applied to derive both positive and negative traces. This concludes the definition of the semantics of EIODs. Specific examples of positive and negative trace sets can be found in the next section when synthesis examples are given.</region>
          <outsider class="DoCO:TextBox" type="footer" id="170" page="17" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="171" page="18" column="1">8:18</outsider>
          <outsider class="DoCO:TextBox" type="header" id="172" page="18" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="173" page="18" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="175" page="18" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="176" page="19" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="177" page="19" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="178" page="19" column="1">8:19</outsider>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="180" page="19" column="1">3. SYNTHESIS OF STATE MACHINES</h1>
        <region class="DoCO:TextChunk" id="187" page="19" column="1">This section presents a synthesis algorithm for converting 3 level EIODs (i.e., use case charts) into a set of hierarchical state machines. The novelty of the algorithm, over that of previous synthesis algorithms, is as follows: <marker type="block"/> —A range of sequence diagram interaction operators, namely alt, opt, seq, par, neg, all, exist are included in the algorithm. Previous algorithms have generally been limited to basic sequence diagrams without interaction fragments.<marker type="page" number="20"/><marker type="block"/> —Additional IOD constructs are taken into account, namely preemption, suspension, multiple concurrent executions, flow final nodes, and negation scoped over IOD nodes. —The generated state machines incorporate hierarchical states and orthogonal regions. The synthesis algorithm is presented in two parts—first, the transformation for sequence diagrams, including interaction fragments, is given, and this is followed by the transformation for EIODs. Before this, the precise variant of hierarchical finite state machines generated is defined.</region>
        <outsider class="DoCO:TextBox" type="footer" id="183" page="19" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="184" page="20" column="1">8:20</outsider>
        <outsider class="DoCO:TextBox" type="header" id="185" page="20" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="186" page="20" column="1">J. Whittle and P. K. Jayaraman</outsider>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="188" page="20" column="1">3.1 Generated Hierarchical Finite State Machines</h2>
          <region class="DoCO:TextChunk" id="196" page="20" column="1">The algorithm presented in this section takes a three-level EIOD as input and generates a set of hierarchical finite state machines (HFSMs). The HFSMs generated are a simplified form of UML state machines and include both composite states (that is, states containing other states) and orthogonal regions. 3.1.1 HFSM Abstract Syntax. Definition 4 (HFSM Abstract Syntax). A HFSM is a graph of the form (N , E N , n o , n f , L N , m N , k N , f N , R, S). N is a set of states where n o ∈ N , n f ∈ N are identified as the initial and final states, respectively. States may contain zero or more orthogonal regions. This is captured by the total, injective function f N : (N \{n 0 , n f }) → P(L N ) which maps each state to a set of HFSMs identified by labels in the set L N . If a state n ∈ N is atomic (i.e., a noncomposite state containing zero regions), then f N (n) is the empty set. If | f N (n)| &gt; 1, then n contains orthogonal regions. If | f N (n)| = 1, then n is composite but does not have orthogonal regions. The total function m N : (N \{n 0 , n f }) → {+, −} marks whether each state is a history state. The total function k N : (N \{n 0 , n f }) → {+, −} marks whether each state is an error state or not. Transitions between states are given by directed edges, E N ⊆ (N × R × S × N ), between two states with labels from a set of symbols R and a set of symbols S. All symbols in R denote the receipt of a message. All symbols in S denote the sending of a message. (For the sake of simplicity, it is assumed that the sender of a message can be uniquely determined by its symbol. Similarly, for message receivers.) Labels from R and S may be prefixed by (all) or (exist) to capture universal or existential messages. This definition for HFSMs is a simplification of the UML definition but also includes syntax specific to our synthesis algorithm, namely, all, exist, and k N . It includes only concepts from the UML definition necessary for the synthesis algorithm. Note, in particular, that it supports orthogonal regions and that these are handled by allowing a state to recursively contain a set of HFSMs. It also includes history states. The definition ignores guards on transitions to keep things simple. Because of the need to capture negative interactions, we introduce special error states (represented by k N ). If an HFSM transitions to an error state, it will be said to be in error. The precise semantics of these error states is defined below. To capture universal and existential messages, <marker type="page" number="21"/><marker type="block"/> the keywords all and exist can be prefixed to triggering events and response actions—their semantics is also defined below.<marker type="block"/> 3.1.2 Semantics. The semantics of these HFSMs is as expected according to the UML standard but with extensions for the synthesis-specific concepts. A set of HFSMs communicate with each other by message passing. Each HFSM maintains a FIFO message queue and iterates through its own run-to- completion cycle (see OMG [2007], p. 546). When a HFSM receives a message, it is added to its queue. On the next iteration of the run-to-completion cycle, the next message is dequeued and is processed as follows: the HFSM calculates the set of enabled transitions, selects a subset of these to fire, and then sends messages to other HFSMs according to which transitions fired. A transition (n 1 , ?m, !m , n 2 ) is enabled if the HFSM is in state n 1 and the dequeued message matches ?m. A subset of enabled transitions is chosen to fire using the same algorithm as defined in the UML standard. If transition (n 1 , ?m, !m , n 2 ) fires, message m is sent to the appropriate target HFSM and the current state is moved from n 1 to n 2 . If n 2 is a composite state, the HFSM enters one substate for each orthogonal region of n 2 , f N (n 2 ) defines a HFSM for each orthogonal region and so the substates entered in each orthogonal region are the intial states of each HFSM in f N (n 2 ), unless n 2 is a history state, in which case the current state when n 2 was most recently exited becomes the current state. (We do not make a distinction in this between shallow and deep history. All history states implement shallow history). When sending messages as response actions, if the prefix all is attached to the action !m, then m is sent to all instances of the target multiobject. The order in which instances are sent this message is chosen nondeterministically. Similarly, if the prefix exist is attached to !m, then a single instance is chosen nondeterministically. For receiving messages, (all)?m means that all source instances must send m before the transition becomes enabled. (exist)?m means that any source instance that sends m will enable the transition. Given the description above, it is now possible to define the semantics of a set of communicating HFSMs as a pair of positive trace sets and negative trace sets. This will allow a comparison with the semantics for the EIOD from which a set of HFSMs is derived. A trace through a set of communicating HFSMs is a sequence of symbols from R and S (possibly prefixed by all and exist) constructed by traversing the HFSMs in the way described by the previous paragraphs. A negative trace is a well-defined trace in which at least one HFSM passes through an error state when the trace is constructed. All other well- defined traces are called positive traces. Now, the following definition captures the semantics of a set of communicating HFSMs.<marker type="block"/> Definition 5 (HFSM Semantics). The semantics of a set of communicating HFSMs is a pair of trace sets, (P, N ), where P is the set of (well-defined) positive traces and N is the set of (well-defined) negative traces. Well-defined traces are constructed by finding any path through the HFSMs according to the execution semantics defined earlier.</region>
          <outsider class="DoCO:TextBox" type="footer" id="190" page="20" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="191" page="21" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="192" page="21" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="193" page="21" column="1">8:21</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="197" page="21" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="198" page="22" column="1">8:22</outsider>
          <outsider class="DoCO:TextBox" type="header" id="199" page="22" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="200" page="22" column="1">J. Whittle and P. K. Jayaraman</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="201" page="22" column="1">3.2 Level 3 Synthesis—Sequence Diagrams</h2>
          <region class="DoCO:TextChunk" id="231" page="22" column="1">The remainder of this section presents the synthesis algorithm for use case charts. This section describes the algorithm informally. The online Appendix 2 provides full details. We start by describing the conversion to HFSMs for a (level 3) UML sequence diagram. 3.2.2.1 Synthesis for Seq. For a sequence diagram without interaction fragments (but which may contain state invariants), the algorithm is identical to previously published algorithms in the literature [Kr uger  ̈ 2000; Uchitel et al. 2003b; Whittle and Schumann 2000]. We therefore do not dwell on this case but merely outline how our algorithm operates. Note that a sequence diagram without interaction fragments composes its messages using weak sequential composition. This is equivalent to having a single seq fragment surrounding the entire sequence. Hence, we consider the case for seq fragments here. The algorithm generates a HFSM for each participant in the sequence diagram. It starts by creating an empty HFSM for each participant. Then, for each participant, O, its HFSM is constructed by proceeding vertically down the participant’s lifeline and creating new states and transitions in the HFSM as messages (and state invariants) are encountered. A message m directed away from O to another object becomes an action, !m, in the HFSM for O to send that message to the target object. A message directed toward O becomes a triggering event, !m, in the HFSM and results in a new transition. If a state invariant is encountered, a named state is created, where the state has the same name as the state invariant. All references to the state invariant result in a transition to this named state. If a state invariant is reached and the corresponding named state already exists, a transition is created to this state. Otherwise, a new named state is created. This straightforward algorithm ensures that all traces in the sequence diagram are also traces of the generated HFSM. There could be additional traces in the HFSM not present in the sequence diagram. These are the so-called implied scenarios [Uchitel et al. 2001] and are a well-known issue for this type of synthesis algorithm. Implied scenarios arise because the global behavior in sequence diagrams must be distributed across a set of objects, each with local behaviors. It is not generally possible to avoid implied scenarios unless all objects agree to synchronize. However, such a solution would be inefficient or may not even be implementable. Therefore, we do not enforce synchronization in this paper but leave implied scenarios as a recognized issue that is being dealt with by other authors. <xref ref-type="fig" rid="F10" id="202" class="deo:Reference">Figure 10</xref> shows a simple sequence diagram with two participants and a single message passed between them. A seq fragment surrounds the message. The generated HFSMs are also shown. In this section, examples will be used to illustrate the synthesis for each language construct. The left-hand side of each figure will show the input and the generated HFSMs will be shown on the right. Under each, the positive and negative trace sets will be shown so that<marker type="page" number="23"/><marker type="block"/> the reader can convince him/herself that the translation is correct. (A full proof of the correctness of the translation is a topic for future work.)<marker type="block"/> 3.2.2.2 Synthesis for par, opt, alt, neg, all, exist. Previously published synthesis algorithms have not considered interaction operators other than seq. We handle them here. Figures 11–15 give examples. We briefly describe the translations below. <xref ref-type="fig" rid="F11" id="214" class="deo:Reference">Figure 11</xref> gives an example synthesis for a par fragment. A par fragment is handled by introducing an orthogonal region into the generated HFSMs. This preserves the sequence diagram traces because the UML semantics for orthogonal regions is interleaving of events from different regions. For an opt fragment (see <xref ref-type="fig" rid="F12" id="215" class="deo:Reference">Figure 12</xref>), two branches are created in the generated HFSMs— one for the optional messages and one for mandatory messages. Note that, if the opt fragment is followed by additional messages, these messages will appear in both branches. Hence, in <xref ref-type="fig" rid="F12" id="216" class="deo:Reference">Figure 12</xref>, m2 appears in both the optional and mandatory branches. This correctly captures the semantics of opt. An alt fragment is handled simply by introducing a branch in the generated HFSMs (see <xref ref-type="fig" rid="F13" id="217" class="deo:Reference">Figure 13</xref>). <xref ref-type="fig" rid="F14" id="218" class="deo:Reference">Figure 14</xref> illustrates an example for neg. The construction is similar to the case for opt in that two branches are created—one for the positive behavior and one for the negative behavior. The negative behavior results in a branch containing error states. Similarly to opt, if the neg fragment is followed by<marker type="page" number="24"/><marker type="block"/> additional messages, according to the neg semantics, these messages form part of the negative trace and so appear in both branches. In <xref ref-type="fig" rid="F14" id="228" class="deo:Reference">Figure 14</xref>, according to the semantics of neg (as defined in Section 2.2.6), there are three negative traces: a trace from just the neg fragment, and two traces from joining the neg fragment with what follows it. The all and exist fragments are handled by introducing modifiers to the transitions. A label (all)!m therefore means to send message m to all instances of the target multiobject. UML state machines do not keep track of instances of multiobjects so (all)!m must be implemented in whatever tool simulates the state machines. Our tool UCSIM (see Section 4.1) does this. In a similar way, (all)?m means that m must be received from all source instances before a transition is enabled. (exist)!m and (exist)?m are defined analogously. <xref ref-type="fig" rid="F15" id="229" class="deo:Reference">Figure 15</xref> gives an example synthesis for all. It assumes there are two target instances of A. m denotes a message sent to/received from the first instance and m denotes a message sent to/received from the second instance. Note that the (all) modifier is only applied to the HFSM for b. Since each instance of the multiobject only receives a single message, (all) is only needed on the sender side. As explained in Section 3.1.2, the multiobject instances are chosen nondeterministically. Hence, in <xref ref-type="fig" rid="F15" id="230" class="deo:Reference">Figure 15</xref>, m and m can be sent in any order.</region>
          <region class="unknown" id="204" page="22" column="1">2 ACM Digital Library, www.acm.org.</region>
          <outsider class="DoCO:TextBox" type="footer" id="205" page="22" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="206" page="23" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="207" page="23" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="208" page="23" column="1">8:23</outsider>
          <region class="unknown" id="209" page="23" column="1">a:A b:B /!m ?m/ seq m HFSM for a HFSM for b Positive traces &lt;!m,?m&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F10">
            <caption class="deo:Caption" id="210" page="23" column="1">Fig. 10. Synthesis for seq.</caption>
          </region>
          <region class="unknown" id="211" page="23" column="1">a:A b:B /!m1 ?m1/ par m1 /!m2 ?m2/ m2 HFSM for a HFSM for b Positive traces &lt;!m1,?m1,!m2,?m2&gt; &lt;!m2,?m2,!m1,?m1&gt; &lt;!m1,!m2,?m1,?m2&gt; &lt;!m1,!m2,?m2,?m1&gt; &lt;!m2,!m1,?m2,?m1&gt; &lt;!m2,!m1,?m1,?m2&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F11">
            <caption class="deo:Caption" id="212" page="23" column="1">Fig. 11. Synthesis for par.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="220" page="23" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="221" page="24" column="1">8:24</outsider>
          <outsider class="DoCO:TextBox" type="header" id="222" page="24" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="223" page="24" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="224" page="24" column="1">/!m1 /!m2 ?m1/ ?m2/ a:A b:B opt m1 /!m2 ?m2/ m2 HFSM for a HFSM for b Positive traces &lt;!m2,?m2&gt; &lt;!m1,!m2,?m1,?m2&gt; &lt;!m1,?m1,!m2,?m2&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F12">
            <caption class="deo:Caption" id="225" page="24" column="1">Fig. 12. Synthesis for opt.</caption>
          </region>
          <region class="unknown" id="226" page="24" column="1">a:A b:B /!m1 ?m1/ alt m1 /!m2 ?m2/ m2 HFSM for a HFSM for b Positive traces &lt;!m1,?m1&gt; &lt;!m2,?m2&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F13">
            <caption class="deo:Caption" id="227" page="24" column="1">Fig. 13. Synthesis for alt.</caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="232" page="24" column="1">3.3 Level 1 and 2 Synthesis—EIODs</h2>
          <region class="DoCO:TextChunk" id="287" page="24" column="1">Synthesis of an EIOD could be done by flattening the EIOD to the equivalent set of sequence diagrams. This is not the approach taken, however, as the inherent structure of the EIOD would be lost and, hence, the generated HFSMs would <marker type="page" number="25"/><marker type="block"/> not be well structured and readable. As in Section 3.2, the presentation of the synthesis algorithm is by example, with the full details in the online Appendix.<marker type="block"/> 3.3.1 Synthesis for Normal Edges. Normal edges in an EIOD are interpreted as weak sequential composition but taking into account flow final and final nodes (recall the sseq operator). <xref ref-type="fig" rid="F16" id="243" class="deo:Reference">Figure 16</xref> illustrates a simple level 2 EIOD with a normal edge which joins two sequence diagrams, S1 and S2 . In this case, the level 2 EIOD is equivalent to a single sequence diagram that joins the two seq fragments from S1 and S2 . More interestingly, <xref ref-type="fig" rid="F17" id="244" class="deo:Reference">Figure 17</xref> shows a level 1 EIOD which is defined using a flow final node. Note how messages from S2 do not appear in the generated HFSMs. (If the flow final node was replaced with a final node, the result would be the same as in <xref ref-type="fig" rid="F16" id="245" class="deo:Reference">Figure 16</xref>.)<marker type="block"/> 3.3.2 Synthesis for Parallel Fork/Join Edges. Parallel fork/join edges lead to orthogonal regions in the generated HFSMs. Since fork/join edges are well nested, there is no ambiguity in deciding where the orthogonal regions should be placed. <xref ref-type="fig" rid="F18" id="247" class="deo:Reference">Figure 18</xref> gives a simple example.<marker type="block"/> 3.3.3 Synthesis for Preempting and Suspending Edges. For preempting and suspending edges, composite states are introduced into the generated HFSMs. Recall that a preempting edge is from a node set to a single node, meaning<marker type="page" number="26"/><marker type="block"/> that all interactions in the node set are interrupted. This is neatly handled by creating a composite state to contain all states generated from the node set and then to have a transition from this composite state to the first state generated from the single preempting node. The only difference between preemption and suspension is that, once the suspending interaction is finished, control returns to the originating node set, at the point where the behavior was interrupted. This is captured in the generated HFSMs by making the composite state a history state so that it caches its current state on exit, and by introducing a transition that returns to the composite state once the suspending states are completed. <xref ref-type="fig" rid="F19" id="258" class="deo:Reference">Figure 19</xref> illustrates preemption. Note that there are too many traces to show in the figure (because of many possible orderings) so only the major ones are shown. We have chosen to give a nontrivial example that includes negative traces in the preempting interaction. Recall from the semantics of preempting edges that this defines sequences that cannot preempt. Hence, for example, the sequence m1, m2 cannot be preempted by m3. If the preempting edge in <xref ref-type="fig" rid="F19" id="259" class="deo:Reference">Figure 19</xref> was instead suspending, the only difference in the generated HFSMs would be that the composite states would be marked as history states and, instead of m4 leading to a final node, it would go back to the composite state.<marker type="page" number="27"/><marker type="block"/> 3.3.4 Synthesis for Negative Edges. Negative edges result in orthogonal regions in the generated HFSMs. Negation is handled by monitoring for the negative events and transitioning to a special error state if they occur. The negative events under monitor are placed into an orthogonal region so that, if the sequence of negative events ever occurs (even with other events interleaved), then the error state will be entered. Note that the interpretation of negation is slightly different at levels 1 and 2 than at level 3. At levels 1 and 2, a negative sequence may have other messages interleaved with it. At level 3, however, the negative sequence is the flattening of the neg fragments. This is the case because negation is scoped over a set of nodes at levels 1 and 2 whereas there is no notion of scope at level 3. Negation without a scope can also be defined at<marker type="page" number="28"/><marker type="block"/> levels 1 and 2 by simply creating a node which references a sequence diagram with neg as the outermost interaction fragment. <xref ref-type="fig" rid="F20" id="276" class="deo:Reference">Figure 20</xref> illustrates a simple case for negative edges at levels 1 and 2 (only some of the negative traces are shown).<marker type="block"/> 3.3.5 Synthesis for Multiple Concurrent Nodes. If a node group is marked as having multiple concurrent nodes (i.e., it has an asterisk attached to it), then the semantics of EIODs says that the node group can be replaced by a parallel fork/join edge in which the node group is repeated some undetermined number of times. When translating to HFSMs, there is no way to specify an undetermined number of orthogonal regions. For this reason, we introduce the notion of dynamic orthogonal regions. A dynamic orthogonal region is an orthogonal region that can replicate itself when its HFSM is executed. The trigger for the replication is the first event received by the orthogonal region. Hence, the behavior represented by the orthogonal region can run concurrently with itself any number of times because a new copy of the region is created each time the behavior is triggered again. Concretely, we implement dynamic orthogonal regions by a special action in a HFSM, createRegionCopy, which replicates an orthogonal region. For an EIOD with a node group marked with an asterisk, a composite state is generated in the HFSM which has the capability to dynamically add orthogonal regions. The first transition in this composite state is of the form m/createRegionCopy. This means that the transition may decide to dynamically create a copy of itself (as an orthogonal region) so that subsequent messages m can be handled. This process could repeat any number of times.<marker type="page" number="29"/><marker type="block"/>  <xref ref-type="fig" rid="F21" id="285" class="deo:Reference">Figure 21</xref> shows an example. Looking only at the HFSM for a, this HFSM will send a message m1 when it is created. It will also call createRegionCopy, which will nondeterministically create a new orthogonal region with a copy of the existing behavior. This would result in two orthogonal regions—one of which would be ready to send m2 and the other would be ready to send another m1. Note that dedicated tool support is needed to correctly handled createRegionCopy. Our tool UCSIM (see Section 4) includes such support. It is also important to note that the generated HFSMs are highly nondeterministic—in that the HFSM for a in <xref ref-type="fig" rid="F21" id="286" class="deo:Reference">Figure 21</xref> autonomously decides to send any number of m1s. This, of course, results in an infinite stream of m1s. Developers typically require more control over such nondeterminism. However, to maintain consistency with the EIOD semantics, we expect that the HFSM simulator would provide an option to control nondeterminism if so required. This completes our description of the synthesis algorithm for EIODs. We have described how each EIOD edge and each sequence diagram interaction fragment is translated into a set of HFSMs. The algorithm is compositional in the sense that combinations of edges and/or fragments are translated by apply- ing the synthesis rules recursively. A pseudocode description of the algorithm is given in the online Appendix.</region>
          <outsider class="DoCO:TextBox" type="footer" id="234" page="24" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="235" page="25" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="236" page="25" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="237" page="25" column="1">8:25</outsider>
          <region class="unknown" id="238" page="25" column="1">a:A b:B /!m1 ?m1/ ERR ERR neg m1 /!m2 /!m2 ?m2/ ?m2/ m2 HFSM for a HFSM for b Positive traces &lt;!m2,?m2&gt; Negative traces &lt;!m1,?m1,!m2,?m2&gt; &lt;!m1,!m2,?m1,?m2&gt; &lt;!m1,?m1&gt;</region>
          <region class="DoCO:FigureBox" id="F14">
            <caption class="deo:Caption" id="239" page="25" column="1">Fig. 14. Synthesis for neg.</caption>
          </region>
          <region class="unknown" id="240" page="25" column="1">a:A b:B ?m/ (all)!m/ all m HFSM for b HFSM for instances of A Positive traces &lt;!m’,!m,?m’,?m&gt; &lt;!m,!m’,?m,?m’&gt; &lt;!m’,?m’,!m’,?m’&gt; &lt;!m,?m,!m’,?m’&gt; &lt;!m,!m’,?m’,?m&gt; &lt;!m’,!m,?m,?m’&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F15">
            <caption class="deo:Caption" id="241" page="25" column="1">Fig. 15. Synthesis for all.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="250" page="25" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="251" page="26" column="1">8:26</outsider>
          <outsider class="DoCO:TextBox" type="header" id="252" page="26" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="253" page="26" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="254" page="26" column="1">/!m1 ?m1/ S1 S2 /!m2 ?m2/ a:A b:B HFSM for a seq m1 HFSM for b S1 Positive traces &lt;!m1,?m1,!m2,?m2&gt; a:A b:B &lt;!m1,!m2,?m1,?m2&gt; Negative traces none seq m2 S2</region>
          <region class="DoCO:FigureBox" id="F16">
            <caption class="deo:Caption" id="255" page="26" column="1">Fig. 16. Synthesis for normal edges.</caption>
          </region>
          <region class="unknown" id="256" page="26" column="1">/!m1 ?m1/ E1 S2 HFSM for a HFSM for b S1 Positive traces &lt;!m1,?m1&gt; E1 Negative traces none</region>
          <region class="DoCO:FigureBox" id="F17">
            <caption class="deo:Caption" id="257" page="26" column="1">Fig. 17. Synthesis for flow final nodes.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="261" page="26" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="262" page="27" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="263" page="27" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="264" page="27" column="1">8:27</outsider>
          <region class="unknown" id="265" page="27" column="1">S1 /!m1 ?m1/ S2 /!m2 ?m2/ HFSM for a HFSM for b Positive traces &lt;!m1,?m1,!m2,?m2&gt; &lt;!m2,?m2,!m1,?m1&gt; &lt;!m1,!m2,?m1,?m2&gt; &lt;!m1,!m2,?m2,?m1&gt; &lt;!m2,!m1,?m2,?m1&gt; &lt;!m2,!m1,?m1,?m2&gt; Negative traces none</region>
          <region class="DoCO:FigureBox" id="F18">
            <caption class="deo:Caption" id="266" page="27" column="1">Fig. 18. Synthesis for parallel fork/join edges.</caption>
          </region>
          <region class="unknown" id="267" page="27" column="1">/!m1 ?m1/ S1 S2 /!m2 ?m2/ &lt;&lt;preempted&gt;&gt; /!m4 /!m3 ?m4/ ?m3/ S3 ERR ERR /!m4 ?m4/ a:A b:B neg m3 HFSM for a HFSM for b Positive traces &lt;!m1,?m1,!m2,?m2&gt; m4 &lt;!m1,!m2,?m1,?m2&gt; &lt;!m1,?m1,!m4,?m4&gt; &lt;!m1,!m4,?m1,?m4&gt; S3 &lt;!m1,?m1,!m2,?m2,!m4,?m4&gt; &lt;!m1,!m2,?m1,?m2,!m4,?m4&gt; &lt;!m1,!m2,!m4,?m1,?m2,?m4&gt; etc. Negative traces &lt;!m1,?m1,!m3,?m3&gt; &lt;!m1,?m1,!m3,!m4,?m3,?m4&gt; &lt;!m1,?m1,!m3,?m3,!m4,?m4&gt; &lt;!m1,?m1,!m2,?m2,!m3,?m3&gt; &lt;!m1,?m1,!m2,?m2,!m3,!m4,?m3,?m4&gt; etc.</region>
          <region class="DoCO:FigureBox" id="F19">
            <caption class="deo:Caption" id="268" page="27" column="1">Fig. 19. Synthesis for preemption.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="270" page="27" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="271" page="28" column="1">8:28</outsider>
          <outsider class="DoCO:TextBox" type="header" id="272" page="28" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="273" page="28" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="274" page="28" column="1">/!m1 /!m2 S1 S2 /!m4 ERR &lt;&lt;neg&gt;&gt; S4 HFSM for a a:A b:B ?m1/ ?m2/ m4 ?m4/ ERR S4 HFSM for b Positive traces &lt;!m1,?m1,!m2,?m2&gt; &lt;!m1,!m2,?m1,?m2&gt; Negative traces &lt;!m1,?m1,!m4,?m4,!m2,?m2&gt; &lt;!m1,!m2,!m4,?m4,!m2,?m2&gt; &lt;!m1,?m1,!m2,?m2,!m4,?m4&gt; &lt;!m1,!m2,?m1,?m2,!m4,?m4&gt; &lt;!m1,!m2,!m4,?m1,?m2,?m4&gt; etc.</region>
          <region class="DoCO:FigureBox" id="F20">
            <caption class="deo:Caption" id="275" page="28" column="1">Fig. 20. Synthesis for scoped negation.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="279" page="28" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="280" page="29" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="281" page="29" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="282" page="29" column="1">8:29</outsider>
          <region class="unknown" id="283" page="29" column="1">/!m1; S1 S2 createRegionCopy /!m2 * HFSM for a ?m1/ createRegionCopy ?m2/ HFSM for b Positive traces &lt;!m1,?m1,!m2,?m2&gt; &lt;!m1,?m1,!m2,?m2&gt; &lt;!m1,?m1,!m1,?m1,!m2,?m2,!m2,?m2&gt; etc. Negative traces</region>
          <region class="DoCO:FigureBox" id="F21">
            <caption class="deo:Caption" id="284" page="29" column="1">Fig. 21. Synthesis for multiple concurrent executions.</caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="288" page="29" column="1">3.4 Synthesis Example</h2>
          <region class="DoCO:TextChunk" id="299" page="29" column="1">In this section, we show the HFSMs generated for our motivating example from Section 2. The starting use case chart is given by Figures 6–9. The use case chart constitutes an executable specification. The main state-dependent object in this example is Controller, which appears in all of the level 3 sequence <marker type="page" number="30"/><marker type="block"/> diagrams in <xref ref-type="fig" rid="F9" id="296" class="deo:Reference">Figure 9</xref>. The HFSM generated for the Controller participant is given in <xref ref-type="fig" rid="F22" id="297" class="deo:Reference">Figure 22</xref> (final states have been omitted to reduce clutter). The highly structured HFSM is crucial in understanding and modifying the result. The structure allows different levels of hierarchy to be hidden—for example, if the states concerned with connection and updating are not of interest, they can be suppressed. The states for maintenance are in their own orthogonal region because they can happen concurrently with other events. createRegionCopy is used to handle the fact that any number of connections can be ongoing at once. Each time the connect event is received, a new orthogonal region is dynamically created in the HFSM, which allows any number of connections at once. An orthogonal region with an error state is used to model the negative edge from <xref ref-type="fig" rid="F8" id="298" class="deo:Reference">Figure 8</xref>.</region>
          <outsider class="DoCO:TextBox" type="footer" id="290" page="29" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="291" page="30" column="1">8:30</outsider>
          <outsider class="DoCO:TextBox" type="header" id="292" page="30" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="293" page="30" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="294" page="30" column="1">maintain/maintain done/(all)abort done/ abort/abort connect/ createRegionCopy timeout/ validate; update;notify connect/ validate; update; update; ERR accept accept disconnect/ initialize/ validate;update; validate; accept done/ start/getData getInitData data/ (all)send(data); timeout/ initData/ prepareData finalizeData send(initData) done/</region>
          <region class="DoCO:FigureBox" id="F22">
            <caption class="deo:Caption" id="295" page="30" column="1">Fig. 22. Synthesized HFSM for controller.</caption>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="300" page="30" column="1">4. TOOL SUPPORT AND DISCUSSION</h1>
        <region class="DoCO:TextChunk" id="320" page="30" column="1">The synthesis algorithm described in this article has been implemented in the UCSIM tool [Jayaraman and Whittle 2007]. UCSIM is implemented as an Eclipse plug-in and EIODs can be created using IBM Rational Software Modeler (RSM) using standard UML notations and stereotypes where necessary. Although UCSIM currently works with RSM, it is designed in a <marker type="page" number="31"/><marker type="block"/> vendor-independent way and can be adapted to other modeling tools in a relatively straightforward manner. UCSIM supports —specification of use case charts in RSM using EIODs, —automatic generation of a set of hierarchical finite state machines for state- dependent objects, and —simulation of the generated HFSMs using our own HFSM simulator for ani- mating walkthroughs of the use case chart. <xref ref-type="fig" rid="F23" id="308" class="deo:Reference">Figure 23</xref> gives an overview of UCSIM’s architecture. Under the RSM implementation, a user first creates a use case chart in RSM using a profile that defines the stereotypes which extend UML interaction overview diagrams. <xref ref-type="fig" rid="F24" id="309" class="deo:Reference">Figure 24</xref> is a screenshot of RSM displaying level 1 for an example use case chart. Note, in particular, the use of the stereotype &lt;&lt;preempted&gt;&gt; to capture preemption of use cases. To simulate a use case chart, the user first invokes synthesis of state machines by invoking a menu command as shown in <xref ref-type="fig" rid="F24" id="310" class="deo:Reference">Figure 24</xref>. The generated state machines can be displayed in the current UML modeling tool (RSM currently) or, alternatively, the state machines can be simulated using our own Configurable State Machine Simulator (CSMS). This simulator allows the user to view a set of state machines and inject events to run test cases and what-if scenarios. Currently, the simulator cannot display and simulate the state machines directly in RSM but this is planned for future work. Instead, the state machines are displayed in the CSMS and the user can inject events in CSMS— see <xref ref-type="fig" rid="F25" id="311" class="deo:Reference">Figure 25</xref>. UCSIM’s architecture has a number of components as described in <xref ref-type="fig" rid="F23" id="312" class="deo:Reference">Figure 23</xref>. An instance of the UML2 metamodel representing the use case chart is exported<marker type="page" number="32"/><marker type="block"/> from RSM and sent to the UML2toText component. UCSIM has its own internal textual representation of use case charts defined by a grammar. UML2toText generates this textual representation from the UML2 metainstances. This textual representation is used so that UCSIM can be tailored to different UML modeling tools. It is completely independent of RSM, for example. The Monticore tool [Krahn and Rumpe 2006] is an ongoing project at the Technical University of Braunschweig. Monticore aims to support the development of domain- specific languages by allowing compact definitions of languages. UCSIM uses the parsing facilities of Monticore to generate AST Java classes that are input to the Synthesizer. The Synthesizer then applies the synthesis algorithm and passes the resulting state machines to RSM (as instances of the UML2 metamodel) and to our in-house state machine simulator, CSMS. CSMS is similar to existing state machine simulators such as those implemented in commercial tools. CSMS is novel, however, in that it allows the semantics of the state machines to be customized. UML deliberately marks some semantic decisions as semantic variation points (see Chauvel and Jezequel [2005]). These variation points can be defined differently by different tools. This can cause problems because a state machine designed and tested in one tool may not behave identically in another tool. To help alleviate this problem, the user can configure the semantic variation points in CSMS and the execution of the state machine then changes to match the new semantic definition.</region>
        <outsider class="DoCO:TextBox" type="footer" id="302" page="30" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="303" page="31" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="304" page="31" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="305" page="31" column="1">8:31</outsider>
        <region class="unknown" id="306" page="31" column="1">Rational UML2 Software UML2 to text Modeler textual syntax UML2 Metamodel Monticore AST UML2 Synthesizer UML2 Configurable State Machine Simulator</region>
        <region class="DoCO:FigureBox" id="F23">
          <caption class="deo:Caption" id="307" page="31" column="1">Fig. 23. UCSIM overview.</caption>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="314" page="31" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="315" page="32" column="1">8:32</outsider>
        <outsider class="DoCO:TextBox" type="header" id="316" page="32" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="317" page="32" column="1">J. Whittle and P. K. Jayaraman</outsider>
        <region class="DoCO:FigureBox" id="F24">
          <image class="DoCO:Figure" src="62dl.page_032.image_02.png" thmb="62dl.page_032.image_02-thumb.png"/>
          <caption class="deo:Caption" id="319" page="32" column="1">Fig. 24. An EIOD in UCSIM.</caption>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="321" page="32" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="322" page="33" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="323" page="33" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="324" page="33" column="1">8:33</outsider>
        <region class="DoCO:FigureBox" id="F25">
          <image class="DoCO:Figure" src="62dl.page_033.image_03.png" thmb="62dl.page_033.image_03-thumb.png"/>
          <caption class="deo:Caption" id="326" page="33" column="1">Fig. 25. Synthesized state machines in UCSIM.</caption>
        </region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="327" page="33" column="1">4.2 Experience with UCSIM and Synthesis</h2>
          <region class="DoCO:TextChunk" id="364" page="33" column="1">So far, we have used UCSIM to specify use case charts and generate HFSMs for three reasonably large case studies. These examples demonstrate (1) that realistic specifications can be captured using EIODs and that our extensions are useful in practice, and (2) that readable HFSMs can be generated for realistic examples. We give brief descriptions of these three examples here. The first is a weather update subsystem of an air traffic control system developed at NASA [Denery et al. 1997]. The illustrative example used earlier in this article is a much simplified version of this subsystem. This particular example was used in an earlier article on synthesis [Whittle et al. 2005b]. Our particular contribution here is that we were able to use the extended features of EIODs to generate hierarchical state machines for the example. We gave the same scenarios as were used in Whittle et al. [2005b]. However, in Whittle et al. [2005b], heavy use of state invariants was made to connect scenarios together. In essence, each sequence diagram used state invariants to label the states at the beginning and end of the sequence, and these state invariants were used to “paste together” the sequences. State invariants were also used within sequences to mark where, for example, a scenario was interrupted by another. This worked but did require <marker type="page" number="34"/><marker type="block"/> the modeler to provide these state invariants. The constructs of EIODs provide a more elegant solution. We have also applied UCSIM to a version of the shuttle system case study provided by the University of Paderborn [Paderborn 2005]. For the shuttle system, we applied UCSIM at the requirements analysis phase. In order to obtain realistic scenario specifications, we used the shuttle system as a term project in a software architecture and design graduate course at George Mason University. We then took student solutions to the requirements analysis phase and reengineered them into a use case chart specification. This involved taking a collection of UML sequence diagrams and adding structure using the three- level layering in use case charts. We did not have students write the use case charts directly because of the training time that would be needed. Even so, this exercise showed that it is possible to represent complex analysis models with use case charts and, moreover, synthesis of correct HFSMs can be automatically generated using UCSIM. Finally, we also reengineered student solutions to another term project which was the UML design of an automated tollbooth system. Once again, we refactored the solutions into a use case chart solution so that the sequences would be representative of those produced by actual users. The examples showed that the three-level structure of use case charts allow a wide range of behavior to be specified in a controllable way. If UML sequence diagrams alone had been used to capture the same information, the number of modeling elements needed would have been at least an order of magnitude larger. Indeed, it would have been extremely difficult if not impossible to capture some of the more complex behavior, such as preemption. Simply specifying the examples, of course, does not provide any evidence of how easy it is to develop the use case chart, nor how readable the generated HFSMs are. These are important considerations but are considered as future research. Use case charts for the first two examples were developed by the authors of this article. The third was developed by a graduate student who was not involved in the development of UCSIM and had no experience with IODs before using the tool. These three case studies led us to a number of conclusions regarding the ben- efits and drawbacks of synthesis. We offer these here to spur further research in this area.<marker type="block"/> 4.2.1 Scalability and Usability. The three case studies conducted so far were of a reasonable size. As an indication, the shuttle system consisted of 7 use case nodes (level 1), 10 scenario nodes (level 2), an average of 7.2 participants per sequence diagram, 23 interaction fragments, and 144 messages. There were seven state-dependent objects for which HFSMs were generated. This resulted in a total of 117 generated states, four of which were composite states and nine of which were orthogonal regions. The studies showed that the new relationships in EIODs—preemption, suspension, negation—were used in- frequently but their application was crucial when used. This is to be expected. One would not expect, for example, preemption to be used as frequently as simple control flow.<marker type="page" number="35"/><marker type="block"/> Even for examples of medium size such as these, three factors were found to be crucial in making the generated HFSMs readable. First, the use of composite and orthogonal regions was essential. Hierarchical states allow the result to be viewed at different levels of abstraction. Although UCSIM does not yet support suppressing the contents of a hierarchical state (mainly because it is not supported in Rational Software Modeler), hierarchy still improves readability even when all states within a hierarchical state are shown on the same diagram. The importance of hierarchy is a key point. It is relatively straightforward to generate flat state machines that have equivalent behavior to an EIOD. In fact, this is basically the approach taken by research that defines the semantics of IODs in terms of automata or Petri Nets (see, for example, Grosu and Smolka [2005]). For example, a Petri Net can be constructed where each place is a message send or receive event. Such approaches are fine for a formal semantics definition or for when the result is not meant to be human-readable, but if the generated state machines are to be used in further development, readability is critical. Although our method for introducing hierarchy helps a lot, there is further research to be done in this area. For example, the structure generated is highly dependent on the structure in the use case chart. When developing HFSMs manually, modelers may have insights not available to a synthesis algorithm. It would be interesting to develop a set of transformation patterns that capture best practice in how to derive HFSMs, and to match against these patterns during synthesis. Second, we optimized the generated state machines. This was necessary because the algorithm generates redundant states. Transitions with an event but no action may be followed by a transition with an action but no event. In this case, the two transitions can be combined as long as the intermediate state between them has no incoming or outgoing transitions. Similarly, null transitions can be removed. Third, a readable layout of the generated HFSMs is a difficult problem (see, for example, Castello et al. [2002]; Harel and Yashchin [2000]). Most graph layout algorithms do not take into account hierarchical states. That is, a hierarchical state containing many substates will be drawn as a state which is the same physical size as a basic state. This is not sufficient when all states and their substates appear on the same diagram (as is the case with Rational Software Modeler).<marker type="block"/> 4.2.2 Notational Limitations. Currently, the expressiveness of EIODs is somewhat richer than can be easily captured as a set of HFSMs. As a result, our synthesis algorithm does not support everything that can be specified using a use case chart. One interesting construction, for example, that makes sense according to the trace semantics of EIODs Whittle [2007], but for which UCSIM cannot yet generate HFSMs, is shown in <xref ref-type="fig" rid="F26(a)" id="340" class="deo:Reference">Figure 26(a)</xref>. This construct was found to be quite natural and captures the fact that the interaction Start can be executed any number of times whilst existing flows (i.e., the interaction Continue) are still ongoing. This is an example of fork/join branches that are not well nested. The UML definition states that branches must be well nested in an IOD. EIODs relax this restriction, however, because it has been found to be useful<marker type="page" number="36"/><marker type="block"/> in practice. The formal semantics of EIODs have no problem in interpreting such cases, but, in general, branches that are not well nested are not supported by UCSIM yet. In this particular example, the construction can be replaced by an equivalent one (<xref ref-type="fig" rid="F26(b)" id="350" class="deo:Reference">Figure 26(b)</xref>). Since multiple concurrent executions are supported, some cases could be handled by identifying patterns that need to be transformed. However, the general solution is still under investigation. Another case that causes problems for UCSIM is given in <xref ref-type="fig" rid="F27" id="351" class="deo:Reference">Figure 27</xref>. In this example, one interaction preempts two other parallel interaction flows. This causes problems because UCSIM handles preemption by surrounding the states for the interruptible region by a composite state and by introducing a transition leaving the composite state, where this transition corresponds to the<marker type="page" number="37"/><marker type="block"/> preempting event. In the generated HFSM, there would be three orthogonal regions (one for each branch). This means that one orthogonal region preempts the other two, and, in particular, that the two preempted regions become dor- mant. If we apply our algorithm to this example, we get a valid HFSM, but one that is inelegant and awkward to read. A more concise HFSM would have only two orthogonal regions where the preempting event would cause an exit of both of these regions. This would require, however, a more sophisticated synthesis algorithm. The observation here is that it is much harder to define a synthesis algorithm when the readability of the generated HFSMs is a key concern. This might sound obvious, but the example illustrates the point well. An algorithm for generating a flat state machine with exactly the same traces as <xref ref-type="fig" rid="F27" id="357" class="deo:Reference">Figure 27</xref> is relatively straightforward to define. It is much harder to generate a hierarchical state machine where the hierarchy is always the most appropriate for the example at hand.<marker type="block"/> 4.2.3 Methodological Considerations. Our experiences with UCSIM raise a number of methodological considerations. We do not yet offer any in-depth guidelines on how to construct EIODs. In fact, there are very few works in the literature that address how best to use IODs. This is an especially important consideration when synthesis is being used, because the structure in the EIODs has a direct effect on the structure generated in the HFSMs. In Whittle et al. [2005a], we offered some initial hints on how to define a process for analyzing requirements with EIODs. There are two principal uses for synthesis from EIODs. First, since the generated HFSMs can be animated, they provide a way of validating the requirements scenarios. Of course, the scenarios could also be animated directly, using the trace semantics to define an execution environment. Ultimately, we believe that both forms of animation should be used in tandem to validate the requirements since the scenario and state-based models offer different views on the requirements. Second, the HFSMs can be used as an initial behavioral design and used in further development. So far, UCSIM has mainly been used for requirements validation. In the NASA example, errors in the scenarios were not found but these scenarios had already been validated extensively in previous research. Recall that, in the tollbooth system, student solutions that had been developed independently were refactored to use EIODs and HFSMs were generated. This activity led to the discovery of many errors in the student solutions. Most of these errors were found during the process of translating the existing models into a set of EIODs. Animation of the generated HFSMs did uncover additional errors, but these were much fewer in number, and the main purpose of the animation was to achieve confidence in the way that the sequences had been specified. Our experience with student models leads us to the conclusion that one of the most promising applications for animation of generated HFSMs is in education. Typically, students learning OOAD have no tool support for executing models. This is akin to developing code without the support of a compiler.<marker type="page" number="38"/><marker type="block"/> Currently, users of UCSIM must develop a complete EIOD in order to generate HFSMs—in the sense that, if a scenario S2 follows S1 and if a scenario S4 follows S3, then the user must also specify a relationship between S2 and S3. Otherwise, there is not enough information for UCSIM to decide how flow continues after S2. At the level of requirements analysis, specifying such detailed information could be overly restrictive. It would be interesting to investigate synthesis based on partial information. This could lead to nondeterminism in the generated models but could be a useful way of supporting exploration of requirements.</region>
          <outsider class="DoCO:TextBox" type="footer" id="329" page="33" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="330" page="34" column="1">8:34</outsider>
          <outsider class="DoCO:TextBox" type="header" id="331" page="34" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="332" page="34" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="335" page="34" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="336" page="35" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="337" page="35" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="338" page="35" column="1">8:35</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="342" page="35" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="343" page="36" column="1">8:36</outsider>
          <outsider class="DoCO:TextBox" type="header" id="344" page="36" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="345" page="36" column="1">J. Whittle and P. K. Jayaraman</outsider>
          <region class="unknown" id="346" page="36" column="1">ref ref Start Start ref Continue ref Continue * (a) (b)</region>
          <region class="DoCO:FigureBox" id="F26">
            <caption class="deo:Caption" id="347" page="36" column="1">Fig. 26. Equivalent constructions.</caption>
          </region>
          <region class="unknown" id="348" page="36" column="1">* ref Connect ref Automatically Update Data ref Send Data &lt;&lt;preempted&gt;&gt; ref Manually &lt;&lt;preempted&gt;&gt; Update Data</region>
          <region class="DoCO:FigureBox" id="F27">
            <caption class="deo:Caption" id="349" page="36" column="1">Fig. 27. Preemption of two flows.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="353" page="36" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="354" page="37" column="1">Synthesizing Hierarchical State Machines</outsider>
          <outsider class="DoCO:TextBox" type="header" id="355" page="37" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="356" page="37" column="1">8:37</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="360" page="37" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
          <outsider class="DoCO:TextBox" type="header" id="361" page="38" column="1">8:38</outsider>
          <outsider class="DoCO:TextBox" type="header" id="362" page="38" column="1">•</outsider>
          <outsider class="DoCO:TextBox" type="header" id="363" page="38" column="1">J. Whittle and P. K. Jayaraman</outsider>
        </section>
      </section>
      <section class="deo:RelatedWork">
        <h1 class="DoCO:SectionTitle" id="365" page="38" column="1">5. RELATED WORK</h1>
        <region class="DoCO:TextChunk" id="381" page="38" column="1">Use cases and scenarios are well established as requirements gathering and description techniques [Alexander and Maiden 2004; Jacobson et al. 1992]. Popu- lar development methodologies such as the Rational Unified Process [Kruchten 2004] do not, however, offer much guidance on how to come up with a good set of scenarios. As a result, there has been considerable research into processes for supporting scenario development in requirements engineering. This has ranged from techniques for managing brainstorming sessions (e.g., Gottesdi- ener [2004]) to rigorous processes for obtaining scenarios from other requirements artifacts such as goals, for example, the Inquiry Cycle [Potts et al. 1994]. There are also many tools available that support the process of scenario development. Scenario Plus [Alexander 2005] is a scenario management tool that includes a feature for generating sequence diagrams from a textual use case description. The tool is based on a simple grammar parsing algorithm that iden- tifies verbs as messages and nouns as actors. Although useful, this tool is limited to generating rather simple sequence diagrams. UML interaction fragments, for example, cannot be generated. CREWS-SAVRE [Maiden et al. 1998] includes tool support for generating use case scenarios from object system models and is based on theory from cognitive science and human-computer interaction. ART- SCENE [Zachos and Maiden 2004] aids scenario developers in generating alternative and exceptional scenarios based on a library of domain-specific scenario extensions. Each domain is first analyzed and common alternative scenario types are captured formally. These are then presented to the tool user as potential new scenarios and can be used to validate existing textual requirements or to elicit new requirements. Other work on scenario-based methodologies has focused on defining notions of refinement. STAIRS [Haugen et al. 2005], for example, offers a development process which categorizes common classes of scenario refinements. Both STAIRS and the work in [Grosu and Smolka 2005] take into account negative scenarios in their refinement definitions. These scenario development processes differ in their aims to the work presented in this article. This article does not consider how to come up with a good use case chart, although it is likely that existing scenario development processes could be extended. Initial work on a query-based methodology for developing use case charts has been undertaken [Whittle et al. 2005a, 2006]. It is well known that the description of use case semantics in the UML specification is severely lacking. Several authors have contributed toward clarifying <marker type="page" number="39"/><marker type="block"/> the semantics, focusing on particularly vague constructs such as &lt;&lt;include&gt;&gt;, &lt;&lt;extend&gt;&gt;, and the notion of use case generalization [Isoda 2004; Overgaard  ̈ and Palmkvist 1999; Stevens 2001]. Research has also been done on providing ways for stakeholders to rigorously describe use cases. Such research usually in- volves placing structural restrictions on the text that can be used in templates (e.g., Smialek [2004]; Williams [2004]) These approaches define a restricted grammar for a subset of natural language and may also enforce that words in the text come from a well-defined dictionary. The current article takes a different approach. It aims to provide a precise but graphical language for extensions to IODs but it does not attempt to formalize UML’s notion of a use case. EIODs contain constructs that currently exist in activity diagrams but have not been defined for IODs—namely, preemption/suspension, activity groups, final flow nodes, and scoped negation. Kr uger  ̈ has suggested a way to incorporate preemption into MSCs [Kr uger  ̈ 2000, 2003] but, to the authors’ knowledge, the other constructs have not been previously considered as part of sequence chart- style notations. Negation already exists in both hMSCs and IODs although the scoped version of EIODs makes the specification of scoped negation more convenient. Other approaches to negative scenarios have been defined in the literature—such as a notation for negation in MSCs that consists of a set of precondition messages followed by a single negative message [Uchitel et al. 2002]. The intended meaning is that, if the precondition messages occur, then the negative message should not. This notation allows only for a single negative message and indeed appears to be subsumed by UML’s neg operator. In a similar way, Live Sequence Charts (LSCs) [Combes et al. 2005] also define a sequence chart as having a precondition which defines the initial state for the chart, followed by the actual messages. A null precondition can be used to denote a negative scenario because, in this case, the precondition never occurs. LSCs do not appear to have a notion of scoped negation. Finally, use case maps [Amyot et al. 1999] are a notation undergoing stan- dardization for showing relationships between use cases in a way that abstracts the details of any particular scenario (including the abstraction of message passing). A use case map shows related use cases in a map-like diagram where paths through the diagram show the progression of a scenario along a use case. Since use case maps do not show use case details, they are at a more abstract level than EIODs and so serve a different purpose. There have been many papers on synthesizing state machines from scenario- based notations such as UML sequence diagrams [Whittle and Schumann 2000], message sequence charts [Kr uger  ̈ 2000; Uchitel et al. 2003b], and LSCs [Harel et al. 2005]. See Saiedian et al. [2005] and Amyot and Eberlein [2003] for recent surveys on this topic. For the most part, these works have considered a more limited set of scenario relationships than are considered in this article. The algorithm in Uchitel et al. [2003], for instance, takes into account simple control flow given in a hMSC but does not consider parallelism or preemption. One key distinguishing feature between these synthesis algorithms is how they decide on the relationships between different scenarios. There have been two broad classes of approaches—to derive the relationships or to assume that the user provides relationships explicitly. In the former case, the user may<marker type="page" number="40"/><marker type="block"/> specify a set of unconnected scenarios. The synthesis algorithm then derives how these scenarios should be connected, for example, using a learning algorithm [M akinen  ̈ and Syst a  ̈ 2002]. Although an interesting approach, the authors believe that such approaches are fundamentally flawed because of the large number of false positives that will be produced for large systems. The effort required for the user to understand and correct synthesis mistakes will ulti- mately prove to be too great. M akinen  ̈ and Syst a  ̈ [2002] used Angluin’s learning algorithm to derive scenario connections. This approach can, however, produce incorrect results because it characterizes states based on the actions that they execute. This can lead to scenarios in the generated state machines that were not specified in the scenario descriptions. Later work by Koskinen et al. [2002] attempted to solve this problem by incorporating a query cycle during synthesis so that users were asked to classify scenarios as desired or undesired during the learning process of the synthesis algorithm. Although interesting, the user will likely be flooded with a large number of queries. Similar work was presented in Damas et al. [2005] and was followed by work that tried to reduce the number of queries by combining scenarios with goals [Damas et al. 2006]. Approaches to specifying scenario relationships explicitly differ in the amount of detail they expect from the user. At one end of the scale are approaches that use state invariants to label the start and end points of each scenario. This is the approach taken in Kr uger  ̈ [2000] and Whittle et al. [2005b]. It is problematic because a lot of work is required to define these state invariants. Other approaches (e.g., Somé [2005]; Whittle and Schumann [2000]) derived relationships from formally defined pre- and postconditions on scenarios. Hence, a scenario S1 can be assumed to follow a scenario S2 if the precondition of S2 is implied by the postcondition of S1. This is essentially an application of plan- ning. In Somé [2005], the focus was at the use case level and the idea was to formalize the pre- and postconditions that would normally be given as part of a use case template description. In Whittle and Schumann [2000], the pre- and postconditions were limited to simple conditions on Boolean variables. Once again, these approaches require a significant additional modeling effort from the user. The algorithm in this article takes into account both explicit relationships given in EIODs and state invariants. We believe this is a realistic approach. The EIOD relationships can be specified without any knowledge of the internals of a scenario and, if such knowledge is known or required, state invariants can be used to define it. To the authors’ knowledge, there is no existing synthesis algorithm that takes into account as wide a range of relationships as in this article. We have seen no previous algorithms that incorporate preemption, suspension, scoped negation, and parallelism. However, some work has been done on incorporating a subset of these relationships. In his doctoral dis- sertation, Kr uger  ̈ [2000] hinted at the idea of generating composite states for preempted scenarios, but the idea was never fully worked out or implemented. As for negative scenarios, the notion of negative scenario from Uchitel et al. [2002] has been included in a synthesis algorithm. A negative scenario is used to generate a behavioral constraint (given by labeled transition systems) on the rest of the system. This is different from our approach since we incorporate<marker type="page" number="41"/><marker type="block"/> negation directly into the generated HFSMs. In particular, Uchitel et al. [2003a] not incorporate a notion of scoped negation into synthesis. Another interesting work was [Uchitel et al. 2003a] in which partial labeled transition systems were generated. The idea there was to cope with unproscribed behavior—that is, scenarios that have been marked as neither positive nor negative. Synthesis usually assumes that a generated FSM captures all positive behavior and all other behavior is negative. It would be interesting to compare this work in detail with ours. An additional major contribution of our work is the ability to generated well- structured FSMs containing both hierarchical states and orthogonal regions. The question of how to generate appropriate hierarchy has barely been ad- dressed by the synthesis algorithm community so far. M akinen  ̈ and Syst a  ̈ [2002] showed how to generate a limited form of hierarchy by optimizing the generated FSMs—for example, if multiple states have a common outgoing transition, then these states can be combined into a hierarchical state. Orthogonal regions were introduced into the FSMs generated from LSCs in Harel et al. [2005]. For each participant in an LSC, a statechart was generated that contains a number of orthogonal regions, one for each scenario in which the participant takes part. This is a very different approach from the one taken in this article and makes no attempt to identify or use relationships between scenarios. This is because LSCs are defined by a prechart that acts as a precondition to the rest of the LSC (the main chart). Each generated orthogonal region, therefore, contains states for the prechart and for the mainchart of a single LSC. The states for multiple LSCs are not combined in any way other than using orthogonal regions to define parallel composition. Earlier work [Bordeleau and Corriveau 2001] showed how to generate hierarchy in state machines taking a pattern-based approach. This has never been automated, however, and indeed, was intended as a manual process. The algorithm in Harel et al. [2005] also makes the perfect information hy- pothesis, that is, that each object synchronizes with all other objects when an event is received. Although this does alleviate the problem of implied scenarios—which occur because an object’s local view of the system state, as captured in the generated FSM, is insufficient to enforce the global view captured in the scenarios—it appears to be overly restrictive and does not lead to efficient or modular implementations. The algorithm in this article does not assume perfect information. On the other hand, implied scenarios may exist. However, there has been extensive research on how to deal with implied scenarios [Uchitel et al. 2001].</region>
        <outsider class="DoCO:TextBox" type="footer" id="367" page="38" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="368" page="39" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="369" page="39" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="370" page="39" column="1">8:39</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="372" page="39" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="373" page="40" column="1">8:40</outsider>
        <outsider class="DoCO:TextBox" type="header" id="374" page="40" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="375" page="40" column="1">J. Whittle and P. K. Jayaraman</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="377" page="40" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="378" page="41" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="379" page="41" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="380" page="41" column="1">8:41</outsider>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="382" page="41" column="1">6. CONCLUSION AND FUTURE WORK</h1>
        <region class="DoCO:TextChunk" id="393" page="41" column="1">This article presented a new algorithm for converting scenarios into hierarchical finite state machines. Scenarios are specified as extended interaction overview diagrams. It is suggested to use these EIODs in a three-layer structure where the top layer defines use cases, the second layer defines scenarios, and the bottom layer defines sequence diagrams. Rich relationships can be specified including preemption, suspension, scoped negation, parallelism, and multiple <marker type="page" number="42"/><marker type="block"/> concurrent scenario executions. The algorithm generates well-structured HFSMs that make use of orthogonal regions and composite states to improve the readability of the generated FSMs. The algorithm has been implemented in the UCSIM tool, a vendor-independent implementation currently integrated with IBM Rational Software Modeler. UCSIM includes its own HFSM simulator that can be used in validation of the EIODs. Our algorithm is novel in that it works for a very expressive interaction language, suitable, in particular, for distributed, concurrent systems. It is also novel in that the FSMs generated contain rich hierarchy which makes the generated FSMs easier for human consumption during later stages of analysis and design. UCSIM is an ongoing project. So far, we have applied the tool to a number of reasonably large case studies. In each, requirements for a complex distributed concurrent system were specified as EIODs and simulated as HFSMs. The experiments so far have included a transportation system from the University of Paderborn, an air traffic control application, and a student project involving roadway toll collection. We expect the tool to be useful in teaching software modeling and have tentative plans to incorporate it into courses on OOAD. Currently, simulation is done at the state machine level. This is advanta- geous because it allows the user to examine each subsystem independently. However, for stakeholders not familiar with state machines, the results of the simulation may be difficult to understand. We plan on implementing a visual- ization tool on top of UCSIM so that the simulation results can be viewed using graphical icons which are much closer to the domain language of requirements engineers. In addition, one could investigate simulation of the scenarios directly without first translating to state machines. This would not support further design steps but could be useful as a complementary way to validate a use case specification. Despite many years of research into synthesis algorithms (see, for example, the SCESM series of workshops at ICSE dating back to 2000), the practical utility of these algorithms has not yet been properly validated. So far, research has focused on technical issues such as how best to derive connections between scenarios or how best to ensure the correctness of the transformation. We feel the time is ripe for these algorithms to be put through their paces and to un- dertake in-depth studies on how they can most effectively support software engineers. We plan to investigate their role in education initially. Our teaching experience has shown that students have great difficulty maintaining the internal consistency of their analysis and design models. The state-of-practice of developing interaction models is akin to developing code without a compiler. We feel that synthesis algorithms could prove beneficial both in assisting students in building correct interaction models and in transitioning to later design phases. There are two longer term avenues for further work. First, we currently generate HFSMs with error states for negative scenarios. It would be interesting to investigate how to generate HFSMs that guarantee that the negative behaviors cannot happen. Second, we assume that the structure in the input EIODs is suitable for structuring the HFSMs. It would be useful to investigate whether<marker type="page" number="43"/><marker type="block"/> this assumption indeed makes sense or whether HFSMs should be structured in a different way than the input scenarios.</region>
        <outsider class="DoCO:TextBox" type="footer" id="384" page="41" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="385" page="42" column="1">8:42</outsider>
        <outsider class="DoCO:TextBox" type="header" id="386" page="42" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="387" page="42" column="1">J. Whittle and P. K. Jayaraman</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="389" page="42" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="390" page="43" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="391" page="43" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="392" page="43" column="1">8:43</outsider>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="394" confidence="possible" page="43" column="1">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="396" confidence="possible" page="43" column="1">A LEXANDER , I. 2005. Scenario plus use case toolkit. <ext-link ext-link-type="uri" href="http://www.scenarioplus.org.uk/." id="395">http://www.scenarioplus.org.uk/.</ext-link></ref>
          <ref rid="R2" class="deo:BibliographicReference" id="397" confidence="possible" page="43" column="1">A LEXANDER , I. AND M AIDEN , N. 2004. Scenarios, Stories, Use Cases through the Systems Develop- ment Life-Cycle. John Wiley, New York, NY.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="398" confidence="possible" page="43" column="1">A MYOT , D. AND E BERLEIN , A. 2003. An evaluation of scenario notations and construction approaches for telecommunication systems development. Telecomm. Syst. J. 24, 1, 61–94.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="399" confidence="possible" page="43" column="1">A MYOT , D., L OGRIPPO , L., B UHR , R. J. A., AND G RAY , T. 1999. Use case maps for the capture and validation of distributed systems requirements. In Proceedings of the Conference on Requirements Engineering. IEEE Computer Society Press, Los Alamitos, CA, 44–53.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="400" confidence="possible" page="43" column="1">B ORDELEAU , F. AND C ORRIVEAU , J.-P. 2001. On the importance of inter-scenario relationships in hierarchical state machine design. In Proceedings of the Conference on Fundamental Approaches to Software Engineering. 156–170.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="401" confidence="possible" page="43" column="1">C ASTELLO , R., M ILI , R., AND T OLLIS , I. G. 2002. Automatic layout of statecharts. Softw. Pract. Exper. 32, 1, 25–55.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="402" confidence="possible" page="43" column="1">C HAUVEL , F. AND J EZEQUEL , J.-M. 2005. Code generation from UML models with semantic variation points. In Proceedings of the Conference on Model Driven Engineering Languages and Systems (MODELS). Springer, Berlin, Germany, 54–68.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="403" confidence="possible" page="43" column="1">C OMBES , P., H AREL , D., AND K UGLER , H. 2005. Modeling and verification of a telecommunication application using live sequence charts and the play-engine tool. In Proceedings of the ATVA. Springer, Berlin, Germany, 414–428.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="404" confidence="possible" page="43" column="1">D AMAS , C., L AMBEAU , B., D UPONT , P., AND VAN L AMSWEERDE , A. 2005. Generating annotated behavior models from end-user scenarios. IEEE Trans. Softw. Eng. 31, 12, 1056–1073.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="405" confidence="possible" page="43" column="1">D AMAS , C., L AMBEAU , B., AND VAN L AMSWEERDE , A. 2006. Scenarios, goals and state machines: a win-win partnership for model synthesis. In Proceedings of the SIGSOFT FSE. 197–207.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="406" confidence="possible" page="43" column="1">D ENERY , D., E RZBERGER , H., D AVIS , T., G REEN , S., AND M C N ALLY , B. D. 1997. Challenges of air traffic management research: analysis, simulation, and field test. In Proceedings of the AIAA Guidance, Navigation, and Control Conference. AIAA, Reston, VA.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="407" confidence="possible" page="43" column="1">G OTTESDIENER , E. 2004. Running a use case/scenario workshop. In Scenarios, Stories and Use Cases, I. Alexander and N. Maiden, Eds. John Wiley &amp; Sons, New York, NY, 81–101.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="408" confidence="possible" page="43" column="1">G ROSU , R. AND S MOLKA , S. 2005. Safety-liveness semantics for UML 2.0 sequence diagrams. In Proceedings of the 5th International Conference on Application of Concurrency to System Design. IEEE Computer Society Press, Los Alamitos, CA, 6–14.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="409" confidence="possible" page="43" column="1">H AREL , D., K UGLER , H., AND P NUELI , A. 2005. Synthesis revisited: generating statechart models from scenario-based requirements. In Proceedings of the Conference on Formal Methods in Software and Systems Modeling. 309–324.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="410" confidence="possible" page="43" column="1">H AREL , D. AND Y ASHCHIN , G. 2000. An algorithm for blob hierarchy layout. In Proceedings of the Conference on Advanced Visual Interfaces. 29–40.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="411" confidence="possible" page="43" column="1">H AUGEN , Ø., H USA , K. E., R UNDE , R. K., AND S T ø LEN , K. 2005. STAIRS: Towards formal design with sequence diagrams. J. Softw. Syst. Model. 4, 355–367.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="413" confidence="possible" page="43" column="1">IBM. 2008. Rational software modeler. <ext-link ext-link-type="uri" href="http://www.ibm.com" id="412">http://www.ibm.com</ext-link>.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="414" confidence="possible" page="43" column="1">I SODA , S. 2004. On UML2.0’s abandonment of the actors-call-use-cases conjecture. J. Obj. Tech. 4, 69–80.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="415" confidence="possible" page="43" column="1">ITU. 2004. Recommendation Z.120: Message sequence chart. International Telecommunication Union, Geneva, Switzerland.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="416" confidence="possible" page="43" column="1">J ACOBSON , I., C HRISTERSON , M., J ONSSON , P., AND O  ̈ VERGAARD , G. 1992. Object Oriented Software Engineering: A Use Case Driven Approach. Addison-Wesley Professional, Reading, MA.</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="417" confidence="possible" page="43" column="1">J AYARAMAN , P. AND W HITTLE , J. 2007. UCSIM: A tool for simulating use case scenarios. In Com- panion to the 29th International Conference on Software Engineering (ICSE). IEEE Computer Society Press, Los Alamitos, CA, 43–44.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="418" confidence="possible" page="43" column="1">K OSKINEN , J., MÄ KINEN , E., AND S YST Ä, T. 2002. Implementing a component-based tool for interac- tive synthesis of UML statechart diagrams. Acta Cybernet. 15, 4, 547–565.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="423" confidence="possible" page="44" column="1">K RAHN , H. AND R UMPE , B. 2006. Techniques for lightweight generator refactoring. In Proceedings of the Conference on Generative and Transformational Techniques in Software Engineering. 437– 446.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="424" confidence="possible" page="44" column="1">K RUCHTEN , P. 2004. An Introduction to the Rational Unified Process. Addison-Wesley Professional, Reading, MA.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="425" confidence="possible" page="44" column="1">K R UGER  ̈ , I. 2003. Capturing overlapping, triggered and preemptive collaborations using MSCs. In Proceedings of the Conference on Fundamental Approaches to Software Engineering (FASE). 387–402.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="426" confidence="possible" page="44" column="1">K R UGER  ̈ , I. 2000. Distributed system design with message sequence charts. Technische Univer- sit at  ̈ M unchen,  ̈ Munrich, Germany.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="427" confidence="possible" page="44" column="1">M AIDEN , N. A. M., M INOCHA , S., M ANNING , K., AND R YAN , M. 1998. CREWS-SAVRE: Systematic scenario generation and use. In Proceedings of the International Conference on Requirements Engineering. IEEE Computer Society Press, Los Alamitos, CA, 148–155.</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="428" confidence="possible" page="44" column="1">MÄ KINEN , E. AND S YST Ä, T. 2002. Minimally adequate teacher synthesizes statechart diagrams. Acta Informat. 38, 235–239.</ref>
          <ref rid="R29" class="deo:BibliographicReference" id="430" confidence="possible" page="44" column="1">O MG . 2007. Unified modeling language 2.1.1 specification (05-07-04). <ext-link ext-link-type="uri" href="http://www.omg.org" id="429">http://www.omg.org</ext-link>.</ref>
          <ref rid="R30" class="deo:BibliographicReference" id="431" confidence="possible" page="44" column="1">O  ̈ VERGAARD , G. AND P ALMKVIST , K. 1999. A formal approach to use cases and their relationships. In Proceedings of the 1st International Workshop on The Unified Modeling Language (UML’98). Springer-Verlag, Berlin, Germany, 406–418.</ref>
          <ref rid="R31" class="deo:BibliographicReference" id="433" confidence="possible" page="44" column="1">P ADERBORN . 2005. Shuttle System case study. Software Engineering Group, University of Paderborn. <ext-link ext-link-type="uri" href="http://www.cs.uni-paderborn.de/cs/ag-schaefer/CaseStudies/ShuttleSystem/." id="432">http://www.cs.uni-paderborn.de/cs/ag-schaefer/CaseStudies/ShuttleSystem/.</ext-link></ref>
          <ref rid="R32" class="deo:BibliographicReference" id="434" confidence="possible" page="44" column="1">P OTTS , C., T AKAHASHI , K., AND A NT ON  ́ , A. I. 1994. Inquiry-based requirements analysis. IEEE Softw. 11, 21–32.</ref>
          <ref rid="R33" class="deo:BibliographicReference" id="435" confidence="possible" page="44" column="1">S AIEDIAN , H., K UMARAKULASINGAM , P., AND A NAN , M. 2005. Scenario-based requirements analysis techniques for real-time software systems: A comparative evaluation. Require. Eng. 10, 1, 22–33.</ref>
          <ref rid="R34" class="deo:BibliographicReference" id="436" confidence="possible" page="44" column="1">S MIALEK , M. 2004. Accommodating informality with necessary precision in use case scenarios. J. Obj. Tech. 4, 59–67.</ref>
          <ref rid="R35" class="deo:BibliographicReference" id="437" confidence="possible" page="44" column="1">S OM É, S. 2005. Use case based requirements validation with scenarios. In Proceedings of the International Conference on Requirements Engineering. 465–466.</ref>
          <ref rid="R36" class="deo:BibliographicReference" id="438" confidence="possible" page="44" column="1">S TEVENS , P. 2001. On use cases and their relationships in the unified modelling language. In Proceedings of the 4th International Conference on Fundamental Approaches to Software Engineering (FASE’01). Springer-Verlag, Berlin, Germany, 140–155.</ref>
          <ref rid="R37" class="deo:BibliographicReference" id="439" confidence="possible" page="44" column="1">S T ORRLE  ̈ , H. 2005. Semantics and verification of data flow in UML 2.0 activities. Electronic Notes Theoret. Comput. Sci. 127, 4, 35–52.</ref>
          <ref rid="R38" class="deo:BibliographicReference" id="440" confidence="possible" page="44" column="1">S T ORRLE  ̈ , H. AND H AUSMANN , J. H. 2005. Towards a formal semantics of UML2.0 activities. In Proceedings of the Conference on Software Engineering. 117–128.</ref>
          <ref rid="R39" class="deo:BibliographicReference" id="441" confidence="possible" page="44" column="1">U CHITEL , S., K RAMER , J., AND M AGEE , J. 2003a. Behavior model elaboration using partial labelled transition systems. In Proceedings of ESEC/SIGSOFT FSE. 19–27.</ref>
          <ref rid="R40" class="deo:BibliographicReference" id="442" confidence="possible" page="44" column="1">U CHITEL , S., K RAMER , J., AND M AGEE , J. 2001. Detecting implied scenarios in message sequence chart specifications. In Proceedings of ESEC/SIGSOFT FSE. 74–82.</ref>
          <ref rid="R41" class="deo:BibliographicReference" id="443" confidence="possible" page="44" column="1">U CHITEL , S., K RAMER , J., AND M AGEE , J. 2004. Incremental elaboration of scenario-based specifications and behavior models using implied scenarios. ACM Trans. Softw. Eng. Methodol. 13, 37–85.</ref>
          <ref rid="R42" class="deo:BibliographicReference" id="444" confidence="possible" page="44" column="1">U CHITEL , S., K RAMER , J., AND M AGEE , J. 2002. Negative scenarios for implied scenario elicitation. In Proceedings of SIGSOFT FSE. 109–118.</ref>
          <ref rid="R43" class="deo:BibliographicReference" id="445" confidence="possible" page="44" column="1">U CHITEL , S., K RAMER , J., AND M AGEE , J. 2003b. Synthesis of behavorial models from scenarios. IEEE Trans. Softw. Eng. 29, 99–115.</ref>
          <ref rid="R44" class="deo:BibliographicReference" id="446" confidence="possible" page="44" column="1">W EIDENHAUPT , K., P OHL , K., J ARKE , M., AND H AUMER , P. 1998. Scenarios in system development: Current practice. IEEE Softw. 15, 2, 34–45.</ref>
          <ref rid="R45" class="deo:BibliographicReference" id="447" confidence="possible" page="44" column="1">W HITTLE , J. 2005. Specifying precise use cases with use case charts. In MoDELS Satellite Events (Revised Selected Papers). Springer-Verlag, Berlin, Germany. 290–301.</ref>
          <ref rid="R46" class="deo:BibliographicReference" id="448" confidence="possible" page="44" column="1">W HITTLE , J. 2007. Precise specification of use case scenarios. In Proceedings of the Conference on Fundamental Approaches to Software Engineering (FASE). Springer, Berlin, Germany. 170–184.</ref>
          <ref rid="R47" class="deo:BibliographicReference" id="449" confidence="possible" page="44" column="1">W HITTLE , J. AND J AYARAMAN , P. 2006. Generating hierarchical finite state machines from use case charts. In Proceedings of the 14th IEEE International Conference on Requirements Engineering. IEEE Computer Society Press, Los Alamitos, CA, 16–25.</ref>
          <ref rid="R48" class="deo:BibliographicReference" id="454" confidence="possible" page="45" column="1">W HITTLE , J., J OY , C., AND K R UGER  ̈ , I. 2005a. Generating simulation and test models from scenarios. In Proceedings of the 3rd World Congress on Software Quality. 41–53.</ref>
          <ref rid="R49" class="deo:BibliographicReference" id="455" confidence="possible" page="45" column="1">W HITTLE , J., J OY , C., AND K R UGER  ̈ , I. 2006. Supporting model-based testing with scenarios and state machines. Softw. Qual. Prof. 8, 17–28.</ref>
          <ref rid="R50" class="deo:BibliographicReference" id="456" confidence="possible" page="45" column="1">W HITTLE , J., K WAN , R., AND S ABOO , J. 2005b. From scenarios to code: An air traffic control case study. Softw. Syst. Model. 4, 71–93.</ref>
          <ref rid="R51" class="deo:BibliographicReference" id="457" confidence="possible" page="45" column="1">W HITTLE , J. AND S CHUMANN , J. 2000. Generating statechart designs from scenarios. In Proceedings of the 22nd International Conference on Software Engineering. ACM Press, New York, NY, 314– 323.</ref>
          <ref rid="R52" class="deo:BibliographicReference" id="458" confidence="possible" page="45" column="1">W ILLIAMS , C. 2004. Towards engineered, useful use cases. J. Obj. Techn. 4, 45–57.</ref>
          <ref rid="R53" class="deo:BibliographicReference" id="459" confidence="possible" page="45" column="1">Z ACHOS , K. AND M AIDEN , N. A. M. 2004. ART-SCENE: Enhancing scenario walkthroughs with multi-media scenarios. In Proceedings of the International Conference on Requirements Engineering. IEEE Computer Society Press, Los Alamitos, CA, 360–361.</ref>
          <ref rid="R54" class="deo:BibliographicReference" id="460" confidence="possible" page="45" column="1">Received June 2007; revised February 2008, June 2008; accepted July 2008</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="footer" id="419" page="43" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="420" page="44" column="1">8:44</outsider>
        <outsider class="DoCO:TextBox" type="header" id="421" page="44" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="422" page="44" column="1">J. Whittle and P. K. Jayaraman</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="450" page="44" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        <outsider class="DoCO:TextBox" type="header" id="451" page="45" column="1">Synthesizing Hierarchical State Machines</outsider>
        <outsider class="DoCO:TextBox" type="header" id="452" page="45" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="453" page="45" column="1">8:45</outsider>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="461" page="45" column="1">4.1 UCSIM</h2>
          <outsider class="DoCO:TextBox" type="footer" id="462" page="45" column="1">ACM Transactions on Software Engineering and Methodology, Vol. 19, No. 3, Article 8, Pub. date: January 2010.</outsider>
        </section>
      </section>
    </body>
  </article>
</pdfx>
