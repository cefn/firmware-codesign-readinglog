<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>8c3946517d1cee894072f5fbbb79c8eca1c34f0e352453226b8587bacf0688e7</job>
    <base_name>62py</base_name>
    <doi>http://dx.doi.org/10.1145/1500412.1500419</doi>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Firmware engineering: Methods and tools for firmware specification and design</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="2">WOLFGANG K. GILOI</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="3">REINHOLD GUETH</name>
        </contrib>
      </contrib-group>
      <region class="unknown" id="4">by Technical University of Berlin</region>
      <region class="DoCO:TextChunk" id="5" confidence="possible">Berlin, Germany and</region>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="6">BRUCE D. SHRIVER</name>
        </contrib>
      </contrib-group>
      <region class="DoCO:TextChunk" id="7" confidence="possible">University of Southwestern Louisiana Lafayette, Louisiana INTRODUCTION</region>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="23" page="1" column="1">Microprogramming has become the means of implementing the machine language instructions of a conventional computer. In the future, the vertical migration of functions from the software levels of a system to the microprogramming level may become equally important. The vertical migration of functions of a computer is undertaken to realize architectures having improved performance, functionality, reliability, or data security. The increased volume of microcode brought about by vertical migration tends to increase the complexity of the firmware development process and calls for a firmware engineering discipline that provides tools for the design and specification, implementation, validation, and maintenance of firmware. We present a rationale for the specification and procedural design of firmware based on the use of an appro- priately defined specification language. The features of such a language and the supporting software system are outlined and demonstrated by the example of an existing APL-based firmware development system. <marker type="block"/> Modern software engineering methodology is characterized by features such as: structured programming, hierarchical decomposition based on the use of abstractions for data, operations and control, execution-independent definition of program semantics, and verification by correctness proof or by testing. The core of any software development system is a formal specification method. Only formal specifications can be tested for consistency, completeness and ambiguities. A formal specification of the program modules of a software system is the starting point for the process of hierarchical decomposition in which a complex software system is decom- posed into a hierarchy of less complex modules. This results in a more manageable design and validation process that can be carried out at each stage of a stepwise refinement process.<marker type="column" number="2"/><marker type="block"/> The system decomposition is supported by the use of program and data abstraction, allowing decisions concerning irrelevant implementational details to be deferred until the appropriate stage of the design process. The result obtained after each refinement step must be validated with respect to the given specifications. There exist three major approaches to software specification: (<xref ref-type="bibr" rid="R1" id="11" class="deo:Reference">1</xref>) the operational method, (<xref ref-type="bibr" rid="R2" id="12" class="deo:Reference">2</xref>) the denotational method, and (<xref ref-type="bibr" rid="R3" id="13" class="deo:Reference">3</xref>) the axiomatic method. Only the denotational and the axiomatic specification methods allow for execution-independent semantic definitions. The operational method requires the introduction of representations that are already at the highest level of abstraction. It thus has the potential danger of "overspecification" i.e., the introduction of implementational details not perti- nent at the given level of abstraction. Any specification system must be sufficiently abstract and precise. By "sufficiently abstract" we mean that no more information is contained in a specification than absolutely necessary. By "sufficiently precise" we mean that all abstractions used are completely and unambiguously defined. In general, it should be possible to define an abstraction without specifying its implementation representation, thus avoiding premature binding. Specification systems should meet some additional requirements. A specification system should: (a) allow for specifications to be given at all levels of abstraction in the design process, (b) allow mappings to be defined between the objects and functions at various levels of abstraction, (c) lend itself to the application of automated checking of the completeness and consistency of the specifications, and (d) lend itself to the application of computer assisted verification of the system. However, since verification by correctness proof requires an automated theorem prover, validation by testing will still be 1 predominant. When selecting a firmware specification system, an important question to pose is whether software and firmware are similar enough in nature so that existing software development systems (including their specification subsystems, in particular) can be used in the firmware development process<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> as well. This would be very desirable because the vertical migration of primitives to the microprogramming level sug- gests a view of firmware design as an extension of software design, involving only additional levels of decomposition. As shown in the following section, however, the firmware differs in some decisive aspects from software. Consequently, what is needed is an adaption of software development methods to the task of firmware development, rather than a simple<marker type="block"/> There are some decisive differences between firmware and software that affect the level of abstraction and the nature of the design steps to be taken in the course of firmware development. Firmware represents a "target machine" by implementing the data objects, operations, and control constructs of the microprogramming language of a given "host ma- 2 chine". All abstractions of a firmware design must eventually be mapped onto real hardware resources. Both the hardware and logical architecture of real machines are often based on marketing considerations such as cost, hardware performance, backward compatibility (and also on tradition). Therefore, the firmware interface provided by the hardware usually is strongly determined by the underlying hardware architecture rather than by the constructs found at the higher levels of interpretation. The limited reservoir of hardware resources, especially those available for the representation of data objects, is a serious constraint imposed on the design of firmware. Consequently, a firmware specification system must provide means for introducing bindings of data objects and operations to specific real hardware resources. In contrast, in software design it is usually sufficient to introduce bindings to virtual resources and transformation and leave the mappings of the virtual resources to the real ones to the compiler and oper- ating system. The elementary data objects of firmware design are the contents of certain hardware resources for which the generic name carrier is used. The basic data type of the data objects of the firmware is the bit vector. More complex data types can be defined to represent arbitrary information items of the machine based on the bit vector. A common feature of firmware data types, which is also 3 found in high-level microprogramming languages is that they define data representations and not the semantics of the represented information. Contrasted with software data types these data types have no predefined semantics; their interpretation thus is context-dependent. Therefore, firmware specification systems must include models for the information interpretation (the definition of semantics). The primary goal of software engineering is to produce a reliable and maintainable software system at minimal cost. This is often a very elaborate and costly goal and, if the penalty for failure is high, other important system characteristics (such as execution time) may become of secondary importance. The performance of firmware, on the other hand, determines directly the performance of a computer and, therefore, execution time of the microprograms is of primary concern.<marker type="column" number="2"/><marker type="block"/> A firmware design process, including its specification system, should offer provisions for stating performance requirements. For example, the firmware design system should allow its user to describe parallel activities of the hardware and to verify execution speed requirements. In the firmware design process, the timing characteristics of microprogram execution by the host machine may have to be considered, and the microprograms must be validated with respect to freedom of timing conflicts and resource contention. This distinguishes firmware from software where the notion of run time generally does not exist. An operational specification readily allows for the introduction of models for the host machine semantics, and it lends itself in a natural way to the definition of parallel activities and timing characteristics. The operational specification method initially requires the definition of representations. This is undesirable in software development but is no serious disadvantage in firmware design because the representations of data objects and operations are restricted by the host machine architecture. The operational specification method can be combined with a procedural design process to form a design system having the advantage of allowing for design validations through testing.</region>
      <region class="unknown" id="9" page="1" column="1">Firmware Engineering versus Software Engineering</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="15" page="2" column="1">50</outsider>
      <outsider class="DoCO:TextBox" type="header" id="16" page="2" column="1">National Computer Conference, 1981</outsider>
      <region class="unknown" id="18" page="2" column="1">adop-</region>
      <region class="unknown" id="19" page="2" column="1">tion.</region>
      <region class="unknown" id="20" page="2" column="1">Characteristics of Firmware</region>
      <region class="DoCO:FigureBox" id="Fx22">
        <image class="DoCO:Figure" src="62py.page_002.image_02.png" thmb="62py.page_002.image_02-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="24" confidence="possible" page="2" column="2">OPERATIONAL FIRMWARE SPECIFICATION</region>
      <region class="DoCO:TextChunk" id="25" page="2" column="2">For the reasons listed above, the operational specification method is the preferred starting point in the firmware development process.</region>
      <region class="unknown" id="26" page="2" column="2">Operation Abstraction</region>
      <region class="DoCO:TextChunk" id="27" confidence="possible" page="2" column="2">A microprogram can be interpreted as a state transforming function, f u of an abstract machine M,. The operational specification method requires the existence of a programming language L with semantically well understood constructs. These constructs are used to define the semantics of the operations of Mi. The data objects of M are defined by algorithms formulated in L. To validate the construction, a program written in L is executed, that is, validation is Carried out by testing. Therefore, an essential prerequisite of the operational specification method is the existence of an interpreter for L, to perform the state transformations by which the semantics of the operations and constructs of a microprogram are defined. An operation fj of an abstract machine M, is specified by representing f itj by a program, Pi-ij, to be interpreted by an abstract machine M,-i./j, ; may be a transformation performed on data objects d i&gt;u . Pt-ij may be a transformation performed oh data objects di-i, v . The program P,-i,, can be validated with respect to the specification of f itj , if the values are defined in terms of the data objects rf,_i, v . Therefore, mappings m iy , must be given for all types of data objects of M, so that 4 di, u =mi,,(di-i,v). These mappings, together with the specifications for the operations and control constructs of the microprogram, should be formulated in L in order to render them executable by the interpreter for L. A program P performs transformations in the state space 5,-_i given by the values of the data objects d -i, . By virtue of</region>
      <region class="unknown" id="28" page="2" column="2">t v</region>
      <outsider class="DoCO:TextBox" type="header" id="29" page="3" column="1">Firmware Engineering</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="30" page="3" column="1">51</outsider>
      <region class="unknown" id="31" page="3" column="1">Figure 1—Validation of a program implementing a higher-level function</region>
      <region class="DoCO:TextChunk" id="42" page="3" column="1">mappings m u , S can be mapped onto 5„ i.e., the initial state Si-1 and the final state in 's,_i of a transformation in S,-_i can be related to Sj and 's h respectively. Conversely, if the execution of operation fj by machine Af, leads to the final state *si, then validation of the program P,-i, y implementing/),, is to demonstrate that *.s, = '.s,, as illustrated in Figure 1. <marker type="block"/> Data abstraction of both user defined and predefined data 5 objects is achieved by using abstract data types. The definition of an internal representation, in the cases where there is not a predefined representation, is based on the elementary data types of the host machine. To this end, one may start, for example, with a state machine input-output specification of 6 the operations of a user defined abstract data type. Sub- sequently, by introducing representations, the axiomatic specification can be substituted by an appropriate operational specification, and validation by execution becomes feasible. This approach introduces internal representations even in cases that are not yet predefined, resulting in an "overspecification" at this level. For the reasons given above, such an approach that may be questionable in software specification seems quite acceptable in firmware specification.<marker type="block"/> Control constructs establish an ordering of execution of operations. A control construct of an abstract machine A/,- can be implemented by a program that transforms specific data objects of the machine given at the next lower level. Examples of specific objects are the instruction counter or semaphores.<marker type="column" number="2"/><marker type="block"/> In contrast, the ordering of operations can be defined in software in a more abstract manner, e.g., through iterators of path expressions. This difference results from the early resource binding of firmware data objects. For example, to mi- grate the calling sequence of a high-level programming language into firmware, certain hardware resources must be provided in the host architecture from the beginning, such as instruction counter, stack pointer register, and local base register. The extent to which control constructs may occur as part of the firmware design task can be included in an operational specification.<marker type="block"/> A language to be employed in the operational specification and procedural design of firmware should primarily satisfy the requirements listed earlier. The language must allow for stating resource bindings, for defining the semantics of all possible interpretations of the elementary data types, arid for stating timing specifications. These requirements preclude the unmodified adaption of existing operational software specification systems. Conventional hardware description languages (CHDLS), which may satisfy some of these requirements, exhibit deficiencies that make them unsuitable for the operational firmware specification. CHDLS generally lack the abstraction and expressive power needed for a specification language; in particular they lack the capability to provide precise and abstract specifications of software oriented data objects. Furthermore, they do not allow for the necessary mappings between different levels of abstraction. An important attri- bute of a realistic firmware specification and design system is for it to allow for a stepwise refinement of the specified firmware product. The similarity between the abstractions and semantic models introduced at the higher levels and the functionality and structure of the host machine should be increased with each refinement step. If the designer finds out at a lower level that certain Specifications provided at a higher level hinder the reaching Of the desired proximity, the higher level specifications should be modified. This makes firmware design an iterative process in which phases of specification, refinement, and validation alternate. Such an approach raises two stipulations concerning L: (<xref ref-type="bibr" rid="R1" id="40" class="deo:Reference">1</xref>) the language L should be able to be used interactively and (<xref ref-type="bibr" rid="R2" id="41" class="deo:Reference">2</xref>) it must allow for definitions of abstractions and models at all possible levels of refinement. Meeting the second condition allows the intermediate validation steps to be performed on specifications in which different portions of the system are defined at different levels. The representations of all the data objects, functions, and program constructs at the next lower level need not be defined in one step. The user can thus control the complexity of a refinement step. The requirements for the data types, control constructs, and operations that a suitable language L should satisfy are discussed in the following section. One-dimensional arid two-dimensional arrays suffice as elementary data structures in L, because the only data objects to be represented are: memory arrays and register files, represented by boolean matrices; single register or memory cell</region>
      <region class="unknown" id="33" page="3" column="1">Data Abstraction</region>
      <region class="unknown" id="35" page="3" column="1">Control Abstraction</region>
      <region class="DoCO:FigureBox" id="Fx37">
        <image class="DoCO:Figure" src="62py.page_003.image_03.png" thmb="62py.page_003.image_03-thumb.png"/>
      </region>
      <region class="unknown" id="39" page="3" column="2">Anatomy of the Specification Language</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="43" page="4" column="1">52</outsider>
      <outsider class="DoCO:TextBox" type="header" id="44" page="4" column="1">National Computer Conference, 1981</outsider>
      <region class="DoCO:TextChunk" id="46" confidence="possible" page="4" column="1"> <xref ref-type="table" rid="TI" id="45" class="deo:Reference">TABLE I</xref>—Operations on arrays</region>
      <region class="DoCO:TextChunk" id="47" confidence="possible" page="4" column="1">Clause Operation Indexing Selection of vectors of a matrix or of single array elements Mask Selection of subvectors (fields in a vector) Shift Shift and fill operation Rotate Cyclic shift Catenate Concatenation of vectors</region>
      <outsider class="DoCO:TextBox" type="sidenote" id="48" page="4" column="1">a</outsider>
      <region class="DoCO:TextChunk" id="51" confidence="possible" page="4" column="1">contents, represented by boolean vectors; fields or single bits in bit vectors, obtained by mask or indexing functions. <xref ref-type="table" rid="TI" id="49" class="deo:Reference">Table I</xref> lists the functions of the basic type array. Data objects of this type are specified together with their dimen- sion. Explicit reference data types such as "pointer" are not needed; referencing is restricted to the naming of objects and their substructures or elements. Data dependencies and procedural dependencies establish a partial ordering of the activities of a program. Two activities that are not in a predecessor-successor relationship to each other may be executed simultaneously, provided there are independent hardware resources available for the parallel execution. In microprogramming, where a number of independent hardware resources exist, such parallel execution is ex- ploited for performance optimization. The operations of a program may be grouped into several cooperating processes to indicate asynchronous sequences of activities occuring in independent hardware resources. Therefore, the language should contain constructs for process declaration as well as inter-process communication and synchronization. Such an expressive power of L is unusual, but is essential to validate performance requirements as well as the requirement that hardware bindings are conflict free. To illustrate this point, <xref ref-type="table" rid="TII" id="50" class="deo:Reference">Table II</xref> lists the constructs as can be found in the FIT system, a firmware development system that was designed and imple- 7 mented at the Technical University of Berlin. A language L should facilitate the specification of the host machine. Resource binding of microoperations to functional hardware and control word organization should be supported in a machine independent way. The specification language should allow constraints, such as restrictions on parallel execution of operations, to be expressed. The interpreter of L should include virtual time facilities, so that the time consumed by a specific operation may be specified and its effect on the specified time behavior and performance requirements may be validated. Virtual time specifications also allow the recognition of possible resource contentions among parallel activities and provide a basis for the formulation of synchronization conditions. The time raster used must be fine enough to allow subcycles to be considered. The specification language L should be as syn- tactically simple as possible, containing no more than the minimal number of types, operators, and constructs needed to provide it with the required expressive power. Except for standard operations, such as arithmetical, relational, and logical operations, functions and statements should be named in mnemonic and self-explanatory fashion. In other words, a specification should be easily readable and intelligible.</region>
      <region class="DoCO:FigureBox" id="Fx52">
        <image class="DoCO:Figure" src="62py.page_004.image_04.png" thmb="62py.page_004.image_04-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="53" confidence="possible" page="4" column="2">THE LEVELS OF REFINEMENT</region>
      <region class="unknown" id="54" page="4" column="2">General</region>
      <region class="DoCO:TextChunk" id="59" confidence="possible" page="4" column="2">The syntactic framework of the language L outlined above allows the user to formulate an operational specification in a firmware design process at different levels of abstraction. Figure 2 lists the levels of such a specification and design process, together with the design decisions to be made and the refinements obtained at each level. The use of specification at the problem-oriented level is primarily motivated as a vehicle for the designer to develop a correct and complete understanding of the design task and demonstrate this to other people in- volved. In the data refinement portion of the firmware design process, two fundamental refinements may be distinguished: (<xref ref-type="bibr" rid="R1" id="55" class="deo:Reference">1</xref>) definition of binary representations of given data objects and (<xref ref-type="bibr" rid="R2" id="56" class="deo:Reference">2</xref>) mapping the formats of binary data objects to formats available in the real machine. The resulting data objects can be bound to carriers of the host machine. There are two basic design steps in operation refinement: (<xref ref-type="bibr" rid="R1" id="57" class="deo:Reference">1</xref>) introduction of operations on binary data objects and (<xref ref-type="bibr" rid="R2" id="58" class="deo:Reference">2</xref>) refinement to operations similar to microoperations. The resulting operations can be bound to operations of the host machine and thereby to functional units of the hardware.</region>
      <region class="unknown" id="60" page="4" column="2">The Machine-Independent, Hardware-Oriented Level</region>
      <region class="DoCO:TextChunk" id="61" confidence="possible" page="4" column="2">At the machine-independent level, microoperations are specified in terms of carrier-to-carrier transfer statements. A state change in a carrier is brought about by transferring a new value to it, and a data transformation is performed by letting</region>
      <region class="DoCO:TextChunk" id="63" confidence="possible" page="4" column="2"> <xref ref-type="table" rid="TII" id="62" class="deo:Reference">TABLE II</xref>—Control Constructs in L</region>
      <region class="DoCO:TextChunk" id="64" confidence="possible" page="4" column="2">Clause Purpose •FUNC Procedure head •ENDFUNC Procedure end •CALL Procedure call •RET Procedure return •GOTO Unconditioned jump •IF ...-+DOTO ... (-*ELSE) ...-^FI Conditioned branching •CASE ...^ESAC Alternative branching •REPEAT ..-•UNTIL Iteration clause •FOR ... FROM ... TO ...^ROF Repetition clause •DECLARE Opens declarative part of process •PROCESS Opens procedural part of process •FOREVER Reiterates process execution •END Terminates process execution •PAR Parallel execution of operations •ON Switches signals and state indi- ^OFF cators on or off respectively •WAIT Wait for signal to become true •LOCK Critical section lock •FREE Critical section unlock •INIT ...^EVENT Initiation of a process on behalf of another process by "no-wait send"</region>
      <outsider class="DoCO:TextBox" type="header" id="65" page="5" column="1">Firmware Engineering</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="66" page="5" column="1">53</outsider>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="67" page="5" column="1">J — SPECIFICATION OF GIVEN DESIGN PROBLEMS</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="68" page="5" column="1">PROBLEM-ORIENTED DATA OBJECTS OF PROBLEM-ORIENTED LEVEL DATA OBJECTS</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="69" page="5" column="1">INTRODUCTION OF BINARY REPRESENTATIONS</h1>
        <region class="unknown" id="70" page="5" column="1">1</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="71" page="5" column="1">BINARY REPRESENT- BINARY DATA OBJECTS ATION LEVEL ADJUSTMENT OF DATA FORMATS TO HARDWARE CARRIERS</h1>
        <region class="unknown" id="72" page="5" column="1">1</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="73" page="5" column="1">MACHINE-INDEPEND- BINARY DATA OBJECTS IN ENT HARDWARE- HARDWARE-ADJUSTED FORMATS ORIENTED LEVEL RESOURCE BINDING OF DATA OBJECTS</h1>
        <region class="unknown" id="74" page="5" column="1">1</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="75" page="5" column="1">BOUND BINARY DATA OBJECTS REPRESENTING HARDWARE-ORIENTED HARDWARE CARRIERS LEVEL</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="76" page="5" column="1">SPECIFICATION OF THE HOST MACHINE</h1>
        <region class="unknown" id="77" page="5" column="1">Figure 2—Specification and fundamental design decisions in data refinement and operational refinement</region>
        <region class="DoCO:TextChunk" id="79" confidence="possible" page="5" column="1">a value on a register transfer "pass" through an abstract functional unit. If the identity operation is included into the set of operations that may be carried out on a register transfer, then any register transfer defines an operation and vice versa. The register transfer thus becomes the basic microoperation of a machine. Within a microoperation, there may be a number of operations performed by appropriate functional units. At the machine-independent level, however, abstract functions rather than actual functional units are specified. <xref ref-type="table" rid="TIII" id="78" class="deo:Reference">Table III</xref> presents a sample of possible operations of a computer hardware. Besides such data-transforming operations there also are operations, to be executed within a microoperation cycle, to make possible the register transfers, i.e., establish the necessary connections between carriers and functional units via switching facilities such as multiplexors and gates. At the machine-independent level, these path-controlling operations are not explicitly specified but are implied by the register-</region>
        <region class="DoCO:FigureBox" id="Fx80">
          <image class="DoCO:Figure" src="62py.page_005.image_05.png" thmb="62py.page_005.image_05-thumb.png"/>
        </region>
        <region class="unknown" id="81" page="5" column="2">•</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="82" page="5" column="2">OPERATIONS ON DATA OBJECTS OF PROBLEM ORIENTED DATA TYPES</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="83" page="5" column="2">INTRODUCTION OF OPERATIONS ON BINARY DATA OBJECTS</h1>
        <region class="unknown" id="84" page="5" column="2">1</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="85" page="5" column="2">OPERATIONS ON BINARY DATA OBJECTS</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="86" page="5" column="2">ADJUSTMENT TO AVAILABLE MICROOPERATIONS</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="87" page="5" column="2">OPERATIONS SIMILAR TO MICROOPERATIONS</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="88" page="5" column="2">RESOURCE BINDING OF OPERATION</h1>
        <region class="unknown" id="89" page="5" column="2">1 OF THE HOST MACHINE n I</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="90" page="5" column="2">OPERATIONS SIMULATING MICROOPERATIONS OF THE HOST MACHINE WITH REGARD TO EXCLUSION OF SIMULTANEOUS EXECUTION CAUSED BY COMMON FUNCTIONAL UNITS AND CONTROL WORD ORGANIZATION AND DESCRIP- TION OF THING CHARACTERISTICS</h1>
        <region class="DoCO:TextChunk" id="92" page="5" column="2">transfer statements. There usually is no semantic connection between the operations within one microinstruction. Only the microoperations cause state changes of the machine, and it is the control constructs in a microprogram which determines the order of register transfers that must take place in the execution of the underlying algorithm. It is a specialty of microprogramming that several microoperations may be un- der execution during a given microinstruction cycle and, therefore, microoperations may be executed concurrently, partly overlapping or completely in parallel. The control constructs listed in <xref ref-type="table" rid="TII" id="91" class="deo:Reference">Table II</xref> in connection with the timing specifications allow the designer to deal with such concurrencies. Timing specifications allow the designer to deal with such concurrencies. Timing specifications designate the execution time of operations as a basis for synchronization and performance validation. Performance validation is carried out by executing programs written in L which execute the same func-</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="93" page="6" column="1">54</outsider>
        <outsider class="DoCO:TextBox" type="header" id="94" page="6" column="1">National Computer Conference, 1981</outsider>
        <region class="DoCO:TextChunk" id="96" confidence="possible" page="6" column="1"> <xref ref-type="table" rid="TIII" id="95" class="deo:Reference">TABLE III</xref>—A sample of abstract hardware functions</region>
        <region class="unknown" id="97" page="6" column="1">CARRY C</region>
        <region class="DoCO:TextChunk" id="98" confidence="possible" page="6" column="1">Notation A ADD2 (B) A MULT2 B A DIV2 B AG7B</region>
        <region class="DoCO:TextChunk" id="99" confidence="possible" page="6" column="1">Operation Addition or Subtraction Multiplication Division Greater than Greater equal Equal Less equal Less than Not equal Logical and Logical or Logical not Logical nand Logical nor Rotation</region>
        <region class="unknown" id="100" page="6" column="1">AGEB AEQB ALEB ALTB A NEB A AND B A ORB NOT A ANAND B A NOR B KROTB</region>
        <region class="DoCO:TextChunk" id="101" confidence="possible" page="6" column="1">(B) C</region>
        <region class="DoCO:TextChunk" id="102" confidence="possible" page="6" column="1">K A</region>
        <region class="DoCO:TextChunk" id="103" confidence="possible" page="6" column="1">iL i2</region>
        <region class="unknown" id="104" page="6" column="1">SHIFT FILL LINK B A MASK INCR A DECR A DEC B</region>
        <region class="unknown" id="105" page="6" column="1">KBIND</region>
        <region class="DoCO:TextChunk" id="106" confidence="possible" page="6" column="1">Shift and fill Concatenation Portion of a vector Incrementation Decrementation Binary-to-decimal conversion Decimal-to-binary conversion Index generator Register initialization Register initialization</region>
        <region class="unknown" id="107" page="6" column="1">INDX SET RESET</region>
        <region class="DoCO:TextChunk" id="108" confidence="possible" page="6" column="1">iL i2 "list of register names" "list of register names'</region>
        <region class="DoCO:TextChunk" id="109" confidence="possible" page="6" column="1">tion (the same machine operation) at different levels of abstraction. The time consumed by the execution of a program, P,-i,y, is measured against the time specification of the function//,, to which it is related by the mapping m,,,. In the same manner it can be tested whether a certain operation is executed within a given subcycle.</region>
        <region class="unknown" id="110" page="6" column="1">The Bound Hardware-Oriented Level</region>
        <region class="DoCO:TextChunk" id="111" confidence="possible" page="6" column="1">At the bound level an appropriate model of the real machine must be given as a prerequisite for the firmware design. The documentation of the real machine behavior, as given by the hardware designer, must be sufficiently precise, complete, and understandable in order to provide the required model without major deficiencies. Deficiencies in the model may not be recognized until microprograms are executed on the real machine. An essential assumption for any formal specification method is that there exist a sufficiently well-defined model of the operations, data objects, and control constructs. At the hardware-oriented levels of a firmware design process, the primary question is not whether the design should be verified by correctness proof or validated by testing, but whether the underlying hardware behavior is sufficiently well-defined. In the design process depicted in Figure 2, this problem is miti- gated by the fact that the method allows for arbitrary mod-</region>
        <region class="DoCO:FigureBox" id="Fx112">
          <image class="DoCO:Figure" src="62py.page_006.image_06.png" thmb="62py.page_006.image_06-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="113" confidence="possible" page="6" column="2">Comment (in APL notation) A,B are 2's-complement numbers, C is the carry-in A x B, 2's-complement operands A -s- B, 2's-complement operands</region>
        <region class="unknown" id="114" page="6" column="2">A&gt;B A&gt;B A=B A&lt;B A&lt;B A*B AAB AvB</region>
        <region class="DoCO:TextChunk" id="115" confidence="possible" page="6" column="2">~A AAB AVB Rotates argument B k steps for k &gt; 0 to the left for k &lt; 0 to the right k = number of shifts, B = argument, C = fill element A,b(p(A,B) = (pA) + (pB) A[il + *(i2-i)] (0-origin!) a&lt;-A+l A^-A-l B = binary number in 2's-complement, result = decimal equivalent D-decimal integer, result = 2's-complement, k-digit binary number representation il +1 (i2 - il) ( 0 - origin!) all positions in the named registers are filled with l's all positions in the named registers are filled with 0's</region>
        <region class="DoCO:TextChunk" id="116" confidence="possible" page="6" column="2">ifications and refinements of the model of the real machine and the consequent corrections of design decisions made at the higher levels. Programs constructed at the higher levels of firmware design have the inherent potential of parallel execution, limited only by the existing data dependencies among the operations. At the lower levels of the design process the possibility of parallel operations are further reduced by the constraints given by the microinstruction format and the need to avoid resource contention. The mappings introduced by the bindings of the higher level data objects to carriers of the real machine consist in addressing functions or identities. The operational specification can introduce the highest possible degree of parallelism and subsequently restrict it according to resource bindings and other constraints. In connection with time specifications and mappings, this allows the designer to carry out performance estimates for alternative resource bindings, providing data to optimize the system. The real machine performs state changes by the clocking of registers. Therefore, in a microprogram specification at the bound level, the register-transfer statements of the machine-independent level are substituted for by clock statements. The data objects are bound to real carriers, and the abstract operations are bound to real functional units of the host machine, such as ALUs, shift units, multiplexors, gates, and decoders. Since most of these functional units have a control input in addition to the data inputs, the microprogram specification must comprise</region>
        <outsider class="DoCO:TextBox" type="header" id="117" page="7" column="1">Firmware Engineering</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="118" page="7" column="1">55</outsider>
        <region class="DoCO:TextChunk" id="119" page="7" column="1">specifications pertaining to the generation of the control signals. With each clock statement, the time elapsed since the occurrence of the last clock statement must be specified. These timing specifications, in connection with the clock statements which mark cycle points of state transitions, indicate the beginning of cycles and subcycles. An example of a machine-independent level specification of a microprogram and its refinement to a bound level specification can be found 7 in Giloi et al.</region>
        <region class="DoCO:TextChunk" id="120" confidence="possible" page="7" column="1">CONCLUSION</region>
        <region class="DoCO:TextChunk" id="123" page="7" column="1">The main goal of software engineering is to implement a reliable and maintainable software system that provides a required functionality. The performance aspect may be of secondary importance. However, performance is the major goal of firmware design. Emulators are, in general, less complex than software systems and cannot be designed in a straight- forward top-down fashion, since there usually are rigid constraints to meet as given by the underlying hardware. In our opinion, the primary problem in firmware design is not so much "decomposition of complexity" that is important in software design but rather the problem of resource binding. Dif- ferences between firmware and software must be considered when one adapts methods and techniques of software engineering to firmware engineering. In particular, these differences affect the decision whether to take an axiomatic or an operational approach to firmware specification and design. Unquestionably, the axiomatic approach offers the highest possible degree of abstraction. However, such a high degree of abstraction can be utilized only at the higher levels of firmware design, e.g., in vertical migration problems. At the lower levels of firmware implementation there usually exist many predefined constraints to be taken into account concerning data representations, resource bindings, and timing problems. Models for the definition of resource binding, hardware-related semantics and timing characteristics, however, do not exist in the axiomatic specification method in a practically usable form. It has been predicted that eventually whole application programs rather than just individual functions will be migrated into firmware. In this case, it would be highly desirable to have a uniform software/firmware development system. Such a uniform approach, in which the firmware design is to be- <marker type="column" number="2"/><marker type="block"/> come an additional refinement step in the software design process, would not support the use of an operational firmware specification. However, we do not expect the large-scale migration of entire application programs into firmware to ma- terialize. The vertical migration of application programs offers a performance advantage only if the control store is con- siderably faster than the main memory. In future LSI based architectures, this condition will not hold true. The firmware development system based on an operational specification and procedural design method presented in this paper has been implemented at the Technical University of Berlin. The core of the interactive system, named FIT (Firmware Imple- 7 mentation Tool), is a mnemonic, self-descriptive, and exten- sible specification language. A simulator interprets the microprogram specifications given in FIT at various levels of abstraction and executes them. Simulation runs include time bookkeeping and allow for performance measurements. A report generator provides the user with a numerical and/or graphical presentation of the results obtained. The realization of a microcode generator for a particular host machine, which will automatically translate the hardware-level specification of a microprogram into microcode, seems feasible, but remains yet to be done. The system is implemented in VSAPL and thus portable to computers supporting that language.</region>
        <region class="DoCO:FigureBox" id="Fx122">
          <image class="DoCO:Figure" src="62py.page_007.image_07.png" thmb="62py.page_007.image_07-thumb.png"/>
        </region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="124" confidence="possible" page="7" column="2">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="125" confidence="possible" page="7" column="2">1. Miller, E.F. (ed.). Special issue on "Program Testing," COMPUTER 11,4 (April 1978).</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="126" confidence="possible" page="7" column="2">2. Davidson, S., and B.D. Shriver. "An Updated Overview on Firmware Engineering." In W.K. Giloi (ed), Firmware Engineering. Berlin-Heidelberg- New York: Springer-Verlag, 1980.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="127" confidence="possible" page="7" column="2">3. Davidson, S., "Design and Construction of a Virtual Machine Resource Binding Language." PhD Dissertation, Computer Science Department, University of Southwestern Louisiana, Lafayette, Louisiana, August, 1980.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="128" confidence="possible" page="7" column="2">4. Robinson, L., and K.N. Levitt. "Proof Techniques for Hierarchically Struc- tured Programs." CACM 20,4 (April 1977), 271-283.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="129" confidence="possible" page="7" column="2">5. Liskov, B., and S. Zilles. "Specification Techniques for Data Abstraction," IEEE TRANS. SOFTWARE ENGINEERING 1,3 (March 1975), 7-19.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="130" confidence="possible" page="7" column="2">6. Liskov, B., and V. Berziens. "An Appraisal of Program Specifications." In P. Wegner (ed.), RESEARCH DIRECTIONS IN SOFTWARE TECH- NOLOGY, MIT Press, Cambridge, Mass. 1979.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="131" confidence="possible" page="7" column="2">7. Giloi, W.K., P. Behr, and R. Gueth. "FIT—A System for Firmware Specification, Implementation, and Validation." In G. Chroust (ed.), PROC. OF THE IFIP WORKING CONF. ON FIRMWARE, MICROPROGRAM- MING, AND RESTRUCTURABLE HARDWARE, North-Holland, Am- sterdam 1980.</ref>
        </ref-list>
        <region class="DoCO:FigureBox" id="Fx132">
          <image class="DoCO:Figure" src="62py.page_008.image_08.png" thmb="62py.page_008.image_08-thumb.png"/>
        </region>
      </section>
    </body>
  </article>
</pdfx>
