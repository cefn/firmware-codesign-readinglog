<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>81c42b575ce24e0bd012fc4c6c2132cb4d18d77fbbea1efa08b35468fd175a10</job>
    <base_name>62ff</base_name>
    <doi confidence="possible">http://dx.doi.org/10.1007/11860990_8</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Feature Oriented Domain Analysis Expressions</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="2">Pietu Pohjalainen</name>
        </contrib>
      </contrib-group>
      <region class="unknown" id="4">Department of Computer Science, University of Helsinki <email id="3">pietu.pohjalainen@cs.helsinki.fi</email></region>
      <abstract class="DoCO:Abstract" id="5">Feature oriented domain analysis (FODA) is a known method for modeling variability. It is often used to express requirements on different possible configurations of a discussed concept. To build a bridge between the configuration model and actual implementation we present a regular expression- related language that can be used to define FODA models. These FODA expressions can be used as a common representation between the source code implementation and different representations.</abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="6" page="1" column="1">1. Introduction</h1>
      </section>
      <region class="DoCO:TextChunk" id="9" page="1" column="1">FODA models are often expressed as diagrams consisting of a set of graphical symbols forming a configuration tree. Czarnecki and Eisenecker [ <xref ref-type="bibr" rid="R1" id="7" class="deo:Reference">1</xref>] present a review of the symbols and corresponding formal definitions for constructing configuration models. The graphical representation allows model definitions to be communicated between different stakeholders; the formal definition gives precision to discussion. Implementing a system that allows configurability via FODA models can be conducted in various ways. We discuss how a subset of regular expressions, named FODA expressions language, can be used to express the models. As the presented language is a subset of regular expressions, simple model checking can be implemented trivially by matching a proposed configuration against the regular expression. For more advanced scenarios we present a compiler for translating a FODA model to a deterministic finite state machine with support for implementing model constraints via post-augmentation of the compiled state machines. The rest of this paper is structured as follows. Section 2 presents basic components of FODA models and their corresponding FODA expressions. Section 3 presents automata-based and generative grammar-<marker type="column" number="2"/><marker type="block"/> based approaches to validating FODA models. Section 4 discusses related work and potential future research.</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="10" page="1" column="2">2. Feature oriented domain analysis</h1>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="15" page="2" column="1">2.1 FODA diagram types</h2>
          <region class="DoCO:TextChunk" id="17" page="2" column="1">This section gives a quick reference to different node types and their corresponding FODA expressions. Diagrams in FODA consist of a root node, called concept, which has a number of sub nodes, called features. Features can then again have sub features ad infinitum. The basic variation point types are listed in <xref ref-type="table" rid="T1" id="16" class="deo:Reference">Table 1</xref>.</region>
          <region class="DoCO:TextChunk" id="18" confidence="possible" page="2" column="1">Dimension Feature (or concept) of which all sub features are alternative.</region>
          <region class="DoCO:FigureBox" id="Fx19">
            <image class="DoCO:Figure" src="62ff.page_002.image_02.png" thmb="62ff.page_002.image_02-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="20" confidence="possible" page="2" column="1">Dimension with optional features Feature (or concept) of which all sub features are alternative optional features</region>
          <region class="DoCO:FigureBox" id="Fx21">
            <image class="DoCO:Figure" src="62ff.page_002.image_03.png" thmb="62ff.page_002.image_03-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="22" confidence="possible" page="2" column="1">Extension point Feature that has at least one optional sub feature or at least one set of or-sub features</region>
          <region class="DoCO:FigureBox" id="Fx23">
            <image class="DoCO:Figure" src="62ff.page_002.image_04.png" thmb="62ff.page_002.image_04-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="24" confidence="possible" page="2" column="1">Extension point with optional features Feature of which all sub features are optional</region>
          <region class="DoCO:FigureBox" id="Fx25">
            <image class="DoCO:Figure" src="62ff.page_002.image_05.png" thmb="62ff.page_002.image_05-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="26" confidence="possible" page="2" column="1">Extension point with or- features Feature of which all direct sub features are or-features</region>
          <region class="DoCO:FigureBox" id="Fx27">
            <image class="DoCO:Figure" src="62ff.page_002.image_06.png" thmb="62ff.page_002.image_06-thumb.png"/>
          </region>
          <region class="DoCO:TableBox" id="T1">
            <caption class="deo:Caption" id="28" page="2" column="1">Table 1: basic variation point types FODA diagrams are simple, yet</caption>
          </region>
          <region class="DoCO:TextChunk" id="29" confidence="possible" page="2" column="1">surprisingly effective for modeling commonalities and variability on abstract level. However, using any modeling technique also poses practical problems. Using a modeling technique always raises the question on how to implement the models in a future-proof way. A traditional way is to write semantically compatible implementation of the model in a programming language. This is however a problematic approach, as</region>
          <region class="DoCO:TextChunk" id="32" page="2" column="2">changing the implementation according to every model change is tedious. Problems may rise with the model and implementation getting out of synchronization, as afterwards both artifacts can evolve independently. For this reason, pragmatic programmers Hunt and Thomas have developed a simple clause for implementers to follow: don’t repeat yourself [<xref ref-type="bibr" rid="R3" id="30" class="deo:Reference">3</xref>], which states that software artifacts should reside in one place only. In this context this means that using FODA models requires a way to programmatically access them. Also noted by van Deursen and Klint, they construct a domain-specific language, called Feature Description Language (FDL) for expressing FODA models [4]. Using this language, the configuration model from <xref ref-type="fig" rid="F1" id="31" class="deo:Reference">Figure 1</xref> can be expressed as:</region>
          <region class="DoCO:TextChunk" id="33" confidence="possible" page="2" column="2">Car: all(carBody, Transmission, Engine, pullsTrailer?) Transmission: one-of(automatic, manual) Engine: more-of(electric, gasoline)</region>
          <region class="DoCO:TextChunk" id="34" page="2" column="2">FDL fully implements all aspects of FODA models, and then extends it with new constructs, such as the possibility to define default values features. Most importantly, FDL gives possibility to express FODA models in textual form, thus enabling easier processing, such as automatic analysis and normalizing transformations, than the graphical diagramming language would allow.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="35" page="2" column="2">2.2 Grammars as feature diagrams</h2>
          <region class="DoCO:TextChunk" id="40" page="2" column="2">Building a new domain-specific language is, however, not a trivial task. Besides the grammar specification, in order to being useful, a language needs supporting software: parsers and compilers; debuggers and interpreters. Authors de Jonge and Visser have explored this route. They notice the relationship between FODA models and context-free languages and have implemented a converter from a feature diagram, expressed in FDL, to a context free grammar [5]. By using their translation system, the model from <xref ref-type="fig" rid="F1" id="36" class="deo:Reference">Figure 1</xref> translates to a context free grammar as follows:<marker type="block"/> where T and E mark non-terminals of Transmission and Engine, respectively. In this analogy, atomic features (features that have no sub features) are expressed as terminals of the grammar and features with sub features are non-terminals of the grammar.<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> By expressing the feature model as a grammar the authors build on tradition of compiler building tools: a validity checker of the model is exactly the same as a parser for the language. By feeding the grammar to a grammar-aware editor, it is possible to automatically obtain an interactive editor for doing configuration editing.</region>
          <region class="unknown" id="38" page="2" column="2">“carBody” T E “pullsTrailer”? -&gt; Car “automatic” | “manual” -&gt; T (“electric”, “gasoline”)+ -&gt; E</region>
        </section>
      </section>
      <region class="DoCO:TextChunk" id="12" page="1" column="2">This section gives a fast course to FODA models and present how regular expressions can be used to check whether certain configuration conforms to the specified model. <xref ref-type="fig" rid="F1" id="11" class="deo:Reference">Figure 1</xref> shows an example model, as presented by Czarnecki and Eisenecker [2]. As a prototypical model, it specifies possible configurations for a car, which has mandatory parts car body, transmission and engine. The transmission can exclusively be automatic or manual while the engine can be an electric engine or gasoline driven – or both. Optionally the car in question can pull a trailer.</region>
      <region class="DoCO:FigureBox" id="F1">
        <image class="DoCO:Figure" src="62ff.page_001.image_01.png" thmb="62ff.page_001.image_01-thumb.png"/>
        <caption class="deo:Caption" id="14" confidence="possible" page="1" column="2">Figure 1: An example FODA model When implementing a system that has some of its requirements expressed as FODA models, one of problems is how to check for conformity: when given a list of parts of a car, the system might need to decide whether this list is a car defined by the model. Our approach is to translate the model to a regular expression, which matches to the list when the model matches as well.</caption>
      </region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="41" page="3" column="1">3. FODA expressions</h1>
        <region class="DoCO:TextChunk" id="47" page="3" column="1">FODA expressions take a shorter route. Because the expressive power of basic variation point types is equal to finite state machines, we use regular expressions as the implementation language, as shown in <xref ref-type="table" rid="T2" id="42" class="deo:Reference">Table 2</xref>.<marker type="block"/> Dimension (f1 | f2 | f3) Dimension with optional (f1 | f2 | f3) ? features Extension point (f1? (f2 | f3)+) Extension point with (f1 | f2 | f3)* optional features Extension point with or- (f1 | f2 | f3)+ features <xref ref-type="table" rid="T2" id="44" class="deo:Reference">Table 2</xref>: Regular expressions as FODA models When using regular expressions to define FODA models, e.g. the definition in <xref ref-type="fig" rid="F1" id="45" class="deo:Reference">Figure 1</xref> states that the configuration for a car, written as a FODA expression is: car body transmission (automatic | manual) engine (electric | gasoline)+ pullsTrailer?<marker type="block"/> This solution has the benefit of building over existing concepts and notions. Instead of learning a new little language, such as the FDL, stakeholders need only basic knowledge of regular expressions. Another benefit lies within the strong tool support for regular expressions. Modern programming languages and/or libraries have decent support for regular expressions. Thus an implementation of a simple conformity checker can feed a candidate configuration to the regular expression, which is able to tell whether the configuration conforms to the specified model.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="48" page="3" column="2">3.1 Model checking of FODA expressions</h2>
          <region class="DoCO:TextChunk" id="54" page="3" column="2">Descriptions of regular expressions and their use for generating scanners (lexers) is available in every compiler book, such as [ <xref ref-type="bibr" rid="R5" id="49" class="deo:Reference">6</xref>]. Applying an algorithm that yields a deterministic finite automaton (DFA) from a given regular expression produces an automaton depicted in <xref ref-type="fig" rid="F2" id="50" class="deo:Reference">Figure 2</xref>.<marker type="block"/>  <xref ref-type="fig" rid="F2" id="53" class="deo:Reference">Figure 2</xref>: DFA generated from the regular expression When a configuration is given as input to this automaton, it decides whether the configuration is valid in the corresponding FODA model. Applying a path finding algorithm to the DFA can be used to give information about the current configuration, i.e. when being in state number three, the software could inform that the configuration will be valid after adding a gasoline or electric engine. However, while generation of similar automata for model checking is easy in modern languages, this short route does still have its shortcomings. A problem of this approach is the limited applicability in other contexts: being in state number seven doesn’t tell whether an electric engine is included in our configuration or not. ‘Pulls trailer’ ability can only be included after every other concept of the car has been chosen. Another problem is that validation after removal of components from the configuration often requires a full rematch.</region>
          <region class="DoCO:FigureBox" id="Fx52">
            <image class="DoCO:Figure" src="62ff.page_003.image_07.png" thmb="62ff.page_003.image_07-thumb.png"/>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="55" page="3" column="2">3.2 Enumeration based on the DFA solution</h2>
          <region class="DoCO:TextChunk" id="60" page="3" column="2">In the DFA solution, we associated the input automaton’s alphabet with the concepts in the model. By feeding the concepts in the correct order to the automaton we were able to check the validity of the configuration with only little effort. However, when we think a certain input that needs to be validated, we do not actually care about the order of the concepts; instead we need certain concepts to be present for the configuration to be valid. This leads to the idea of treating the FODA expression language as a generative grammar. From the model specification we can enumerate all valid configurations. For the car configuration example, we can generate every valid configuration, as listed in Figure 3 (only variable parts listed, as the concepts of car body, transmission and engine are always present in valid configurations). <marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> 1. {manual, gasoline} 2. {manual, gasoline, pulls trailer} 3. {manual, gasoline, electric} 4. {manual, gasoline, electric, pulls trailer} 5. {manual, electric} 6. {manual, electric, pulls trailer} 7. {automatic, gasoline} 8. {automatic, gasoline, pulls trailer} 9. {automatic, gasoline, electric} 10. {automatic, gasoline, electric, pulls trailer} 11. {automatic, electric} 12. {automatic electric, pulls trailer} Figure 3: An enumeration of valid configurations This approach has the problem of state explosion: a model with n concepts has potentially 2 n valid configurations. On the other hand, this representation allows the configuration state to be presented with one variable of n-bits. Adding the ‘Pulls trailer’ ability (changing from states <xref ref-type="bibr" rid="R5" id="57" class="deo:Reference">6</xref> or <xref ref-type="bibr" rid="R6" id="58" class="deo:Reference">7</xref> to 8 in <xref ref-type="fig" rid="F2" id="59" class="deo:Reference">Figure 2</xref>) can be done by raising the corresponding bit. Presence of a certain concept in a given configuration happens simply by observing the responsible flag.</region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="61" page="4" column="1">4. Related work and future research</h1>
        <region class="DoCO:TextChunk" id="64" page="4" column="1">Feature oriented domain analysis was originally presented by Kang et al [ <xref ref-type="bibr" rid="R6" id="62" class="deo:Reference">7</xref>]. Its later proponents include Czarnecki and Eisenecker [1, 2]. Deursen and Klint present a language for defining FODA models and an algebra for transforming the models for various needs, such as counting the number of model- conforming configurations and expanding the model language expressiveness [4]. Various parties have proposed associating grammars and feature models. A grammar with direct linking between van Deursen and Klint’s FDL has been proposed by de Jonge and Visser [5]. In another context, Dawes has proposed similar grammar for expressing feature diagrams for the boost.org project to use [8]. We suggested that FODA models could be implemented by employing existing language features and concepts. Instead of inventing a new small language, a subset of regular expressions gives a fast route to FODA model validation checking. While this is a good start, it is currently unclear how the FODA expressions should be expanded to address real world problems: our current concerns are related on how to express domain knowledge of certain configurations, such as default values, configuration<marker type="column" number="2"/><marker type="block"/> implications and constraints while retaining the simplistic approach of the core FODA expression language.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="65" page="4" column="2">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="66" page="4" column="2">[1] Krzysztof Czarnecki and Ulrich Eisenecker. Generative Programming: Methods, Tools, and Applications, Addison- Wesley Professional, 2000, pp. 82-130.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="67" page="4" column="2">[2] Krzysztof Czarnecki and Ulrich Eisenecker. Synthesizing Objects. In Proceedings of ECOOP’99 – Object-Oriented Programming, R. Guerraoui, (Ed.) LNCS 1628, Springer-</ref>
          <ref class="deo:BibliographicReference" id="69" confidence="possible" page="4" column="2">Verlag, Berlin and Heidelberg, Germany, 1999, p. 18-42, <ext-link ext-link-type="uri" href="http://www.prakinf.tu-ilmenau.de/" id="68">http://www.prakinf.tu-ilmenau.de/</ext-link>~czarn/ecoop99/</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="70" page="4" column="2">[3] Andrew Hunt and David Thomas. The Pragmatic Programmer: From Journeyman to Master, Addison- Wesley, 1999, pp. 27. [4] Arie van Deursen and Paul Klint. Domain-Specific Language Design Requires Feature Descriptions. Journal of</ref>
          <ref class="deo:BibliographicReference" id="71" confidence="possible" page="4" column="2">Computing and Information Technology (2002), Vol 10, No 1, pp. 1-17. [5] Merijn de Jonge, Joost Visser, Grammars as Feature Diagrams. In Workshop of Generative Programming 2002</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="73" confidence="possible" page="4" column="2">(GP2002), Austin, Texas, April 2002. <ext-link ext-link-type="uri" href="http://www.cwi.nl/events/2002/GP2002/GP2002-CfP.html" id="72">http://www.cwi.nl/events/2002/GP2002/GP2002-CfP.html</ext-link></ref>
          <ref rid="R5" class="deo:BibliographicReference" id="74" page="4" column="2">[6] Alfred Aho, Ravi Sethi and Jeffrey D. Ullman. Compilers: Principles, Techniques, and Tools, Addison- Wesley, 1988.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="75" page="4" column="2">[7] Kyo Kang, Sholom Cohen, James Hess, William Novak and Spencer Peterson. Feature-Oriented Domain Analysis (FODA) Feasibility Study. Technical Report CMU/SEI-90- TR-21, Software Engineering Institute, Carnegie Mellon University, 1990. [8] Beman Dawes, Feature Model Diagrams in text and</ref>
          <ref class="deo:BibliographicReference" id="76" confidence="possible" page="4" column="2">HTML, Revised at 26 August 2004. Accessed 4 September 2007.</ref>
          <ref class="deo:BibliographicReference" id="78" confidence="possible" page="4" column="2"> <ext-link ext-link-type="uri" href="http://www.boost.org/more/feature_model_diagrams.htm" id="77">http://www.boost.org/more/feature_model_diagrams.htm</ext-link></ref>
        </ref-list>
      </section>
    </body>
  </article>
</pdfx>
