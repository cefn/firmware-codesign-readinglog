<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>4b1a1dfb6383cc05aea8fdaca4be198f7fc9d20a53145e8413ad5ecb094ba84b</job>
    <base_name>62nn</base_name>
    <doi>http://dx.doi.org/10.1007/978-1-4612-4230-7</doi>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="outsider" id="1">Q1 University of Colorado at Boulder</outsider>
      <outsider class="DoCO:TextBox" type="outsider" id="2">Gerhard Fischer</outsider>
      <region class="unknown" id="4">Department of Computer Science ECOT 7-7 Engineering Center Campus Box 430 Boulder, Colorado 80309-0430 (303)492-1502,FAJ(:(303)492·2844 e-mail: <email id="3">getbard@cs.coIorado.edu</email> Putting the Owners of Problems in Charge with Domain-Oriented Design Environments</region>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="5">Gerhard Fischer</name>
        </contrib>
      </contrib-group>
      <region class="DoCO:TextChunk" id="7" confidence="possible">Department of Computer Science and Institute of Cognitive Science, University of Colorado, Boulder, Colorado 80309 email: <email id="6">gerhard@cs.colorado.edu</email> )~S. D. Gilmore, R. Winder, F. Detienn~: "User-Centered Requirements for Software Engineering Environments", Springer Verlag, Heidelberg f992" \ 9q,+) f e' Z P f1- 301.:.</region>
      <abstract class="DoCO:Abstract" id="8">Abstract: Domain workers should gain considerably more independence from computer specialists. Just as the pen was taken out of the hands of the scribes in the middle ages, the role of the high-tech scribes should be redefined and the owners of problems should be put in charge. With this goal in mind, we have developed conceptual frameworks, innovative prototypes and an architecture for integrated, domain-oriented, knowledge-based design environments. Domain-oriented architectures do not only constitute an incremental improvement over current software design practices, but represent a major change to the nature of software development. They reconcep- tualize our understanding of the proper role of computing as an empowering technology for all of us.</abstract>
      <region class="DoCO:TextChunk" id="9" confidence="possible">Acknowledgments. The author would like to thank the members of the Human-Computer Communication group at the University of Colorado who contributed to the conceptual framework and the systems discussed in this article. The research was supported by the National Science Foundation under grants No. CDA-8420944, IRI-8722792, and IRI-9015441; by the Army Research Institute under grant No. MDA903-86-C0143, and by grants from the Intelligent Interfaces Group at NYNEX, from Software Research Associates (SRA). Tokyo, and by the Software Designer's Associate (SDA) Consortium. Tokyo.</region>
      <region class="unknown" id="10">Putting the Owners of Problems in Charge with Domain-Oriented Design Environments</region>
      <region class="DoCO:TextChunk" id="11" confidence="possible">Gerhard Fischer</region>
      <region class="DoCO:TextChunk" id="12" confidence="possible">Department of Computer Science and Institute of Cognitive Science, University of Colorado, Boulder, Colorado 80309</region>
      <region class="DoCO:TextChunk" id="14" confidence="possible">Tel: 303-492-1502 Fax: 303-492-2844 Email: <email id="13">gerhard@cs.colorado.edu</email></region>
      <region class="DoCO:TextChunk" id="67">Abstract: Domain workers should gain considerably more independence from computer specialists. Just as the pen was taken out of the hands of the scribes in the middle ages, the role of the high-tech scribes should be redefined and the owners of problems should be put in charge. <marker type="block"/> With this goal in mind, we have developed conceptual frameworks, innovative prototypes and an architecture for integrated, domain-oriented, knowledge-based design environments.<marker type="block"/> Domain-oriented architectures do not only constitute an incremental improvement over current software design practices, but represent a major change to the nature of software development. They reconcep- tualize our understanding of the proper role of computing as an empowering technology for all of us.<marker type="block"/> Keywords: integrating problem setting and problem solving, ill-defined problems, languages of doing, incremental problem formulation, owning problems, domain-oriented design environments, high-tech scribes<marker type="block"/> Most current computers systems are approachable only through complex jargon that has nothing to do with the tasks for which people use computers - requiring high-tech scribes (programmers, knowledge engineers) who are able to master this jargon. The role of high-tech scribes should be redefined, eliminating the distinction between programmers and non-programmers as two disjoint classes, and defining programming as the mean for users to make computer do what they y.tant them to do, thereby putting the owners of problems in charge. In this paper, I will (1) identify problems facing user-centered software engineering environments, (2) describe domain-oriented design environments as systems addressing these problems, and (3) assess to what extent we have succeeded or failed in putting the owners of problems in charge.<marker type="block"/> Computing needs to be deprofessionalized. The monopoly of highly trained computing professionals, the high-tech scribes, should be eliminated just as the monopoly of the scribes was eliminated during the reformation in Europe. In order to avoid misunderstandings: This does not mean that there is no place for professionals programmers and professional system designers in the future. It means that the profes-<marker type="page" number="3"/><marker type="block"/> sional computing community should create systems to make computer literacy desirable and achievable. Some of the problems and challenges behind this approach are briefly described in this section.<marker type="block"/> Convivial tools. Convivial tools and systems, as defined by IIlich [<xref ref-type="bibr" rid="R17" id="26" class="deo:Reference">lilich 73</xref>], allow users "to invest the world with their meaning, to enrich the environment with the fruits of their vision and to use them for the accomplishment of a purpose they have chosen" (emphasis added). Conviviality is a dimension that sets computers apart from other communication and information technologies (e.g., television) that are passive and cannot conform to the users' own tastes and tasks. Passive technologies offer some selective power, but they cannot be extended in ways that the designer of those systems did not directly foresee. Convivial systems encourage users to be actively engaged in generating creative extensions to the artifacts given to them. They have the potential to break down the counterproductive barrier between programming and using programs.<marker type="block"/> Unfortunately, in most current computer systems the potential for conviviality exists in principle only. Many users perceive computer systems as unfriendly and uncooperative, and their use as too time con- suming. They depend on specialists for help, notice that software is not soft (i.e., the behavior of a system can not be changed without reprogramming it substantially), and spend more time fighting the computer than solving their problems.<marker type="block"/> Problems In the Design of Software Systems. The field study by Curtis, Krasner, and Iscoe [<xref ref-type="bibr" rid="R5" id="30" class="deo:Reference">Curtis, Krasner, Iscoe 88</xref>] unveiled the following problems in creating large software systems: (1) the thin of application domain knowledge, indicating that the real problem is understanding the problem, not the representation of it as a program, (2) fluctuating and conflicting requirements, requiring that the owners of the problems remain part of the design team and that design in use [Henderson, Kyng 91] is indis- pensable, and (3) communication bottlenecks and breakdowns between deSigners, clients, and users, requiring representational means, such as "languages of doing" [<xref ref-type="bibr" rid="R7" id="31" class="deo:Reference">Ehn 88</xref>], that can achieve a shared understanding between these groups.<marker type="block"/> Beyond Programming Languages: From Supply-Side to Demand-Side Computing. Dertouzous (as reported in [<xref ref-type="bibr" rid="R6" id="33" class="deo:Reference">Denning 88</xref>]) argues that the computer science community should operate less on the supply side (i.e., specifying and creating technology and "throwing the resulting goodies over the fence into the world"). More emphasis should be put on the demand side creating computational environments fitting the needs of professionals of other disciplines outside the computer science community. Modern application needs are not satisfied by traditional programming languages that evolved in response to systems programming needs [<xref ref-type="bibr" rid="R24" id="34" class="deo:Reference">Shaw 89</xref>; <xref ref-type="bibr" rid="R32" id="35" class="deo:Reference">Winograd 79</xref>]. Most computer users are interested in results, not in programming per se. Shaw [<xref ref-type="bibr" rid="R24" id="36" class="deo:Reference">Shaw 89</xref>] claims that "the major current obstacle to widespread, effective ex- ploitation of computers is the inability of end users to describe and control the computations they need- or even to appreciate the computations they could perform- without the intervention of software experts."<marker type="block"/> Understanding Problems - Beyond Creating Implementations for Given Specifications. Histori- cally, most software engineering developments (e.g., structured programming, verification methods, etc.) were concentrated on "downstream activities" [<xref ref-type="bibr" rid="R2" id="38" class="deo:Reference">Belady 85</xref>]). Over the last decade, it has become increas- ingly obvious that the real problems of software design will be "upstream activities" [<xref ref-type="bibr" rid="R25" id="39" class="deo:Reference">Sheil 83</xref>] (see Figure<marker type="block"/> While there is growing evidence that system requirements are not so much analytically specified as they are collaboratively evolved through an iterative process of consultation between end-users and software<marker type="page" number="4"/><marker type="block"/> developers [CSTB 90), many research efforts do not take this into account. CASE tools are limited, because they devise more elaborate methods of insuring that software meets its specification, hardly ever questioning whether there might be something wrong with the specifications themselves. One may argue that they provide support after the problem has been solved. A consequence of the thin spread of application knowledge [<xref ref-type="bibr" rid="R5" id="57" class="deo:Reference">Curtis, Krasner, Iscoe 88</xref>) is that specifications often occur when deSigners do not have sufficient application knowledge to interpret the customer's intentions from the requirement statements a communication breakdown based on a lack of shared understanding- [<xref ref-type="bibr" rid="R21" id="58" class="deo:Reference">Resnick 91</xref>].<marker type="block"/> Integrating Problem Setting and Problem Solving. DeSign methodologists (e.g., [<xref ref-type="bibr" rid="R23" id="60" class="deo:Reference">Schoen 83</xref>; Rittel 84]) demonstrated with their work the strong interrelationship between problem setting and problem solving. They argue convincingly that (1) one cannot gather information meaningfully unless one has understood the problem, but one cannot understand the problem without information about it [Rittel 84], and (2) professional practice has at least as much to do with defining a problem as with solving a problem [<xref ref-type="bibr" rid="R23" id="61" class="deo:Reference">Schoen 83</xref>]. New requirements emerge during development, because they can not be identified until portions of the system have been designed or implemented. The conceptual structure underlying complex software systems are too complicated to be specified accurately in advance, and too complex to be build faultlessly [<xref ref-type="bibr" rid="R3" id="62" class="deo:Reference">Brooks 87</xref>]. Specification and implementation have to co-evolve [<xref ref-type="bibr" rid="R30" id="63" class="deo:Reference">Swartout, Balzer 82</xref>] requiring that the owners of the problems need to be present in the development. If these observations and findings describe the state of affairs adequately, one has to wonder why waterfall models are still alive despite the overwhelming evidence that they are not suited for most of today's software problems.<marker type="block"/> In our own work, we have conducted an empirical study in a large hardware store to clarify the depen- dencies between problem setting and problem solving [<xref ref-type="bibr" rid="R15" id="65" class="deo:Reference">Fischer, Reeves 92</xref>]. <xref ref-type="fig" rid="F2" id="66" class="deo:Reference">Figure 2</xref> illustrates how the problem setting is changed in an attempt to solve the problem. The customer came to the store to buy a heater. The interaction between the sales agent and the customer led to a reconceptualization of the problem from "generating more heat," to "containing heat" redefining the problem itself.</region>
      <region class="unknown" id="19">1 Introduction</region>
      <region class="unknown" id="21">2 Problems for Future User-Centered Software Engineering Environments</region>
      <region class="DoCO:FigureBox" id="Fx22">
        <image class="DoCO:Figure" src="62nn.page_002.image_02.png" thmb="62nn.page_002.image_02-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="24">2</outsider>
      <region class="unknown" id="29">spread</region>
      <region class="unknown" id="41">1) .</region>
      <region class="DoCO:FigureBox" id="Fx43">
        <image class="DoCO:Figure" src="62nn.page_003.image_03.png" thmb="62nn.page_003.image_03-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="44">3</outsider>
      <region class="unknown" id="45">Problem T Specification T Implementation Upstream Downstream</region>
      <region class="unknown" id="46">type of problem:</region>
      <region class="unknown" id="47">ill-defined problems we/I-defined problems</region>
      <region class="unknown" id="48">prime objectives:</region>
      <region class="unknown" id="49">correct</region>
      <region class="unknown" id="50">supporting system architecture:</region>
      <region class="unknown" id="51">adequate, understandable, enjoyable domain-oriented design environments</region>
      <region class="unknown" id="52">general-purpose programming environments</region>
      <region class="unknown" id="53">Interaction paradigm:</region>
      <region class="unknown" id="54">human problem-domain communication</region>
      <region class="unknown" id="55">human computer communication</region>
      <region class="DoCO:FigureBox" id="F1">
        <caption class="deo:Caption" id="56">Figure 1: Upstream Versus Downstream Activities</caption>
      </region>
      <region class="DoCO:FigureBox" id="Fx68">
        <image class="DoCO:Figure" src="62nn.page_004.image_04.png" thmb="62nn.page_004.image_04-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="69" confidence="possible">Why Owners of Problems Need to be In Charge. As the previous example shows, "problems are often</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="70">4</outsider>
      <region class="unknown" id="71">CUSTOMER: I want to get a couple of heaters for a downstairs hallway.</region>
      <region class="unknown" id="72">SALESPERSON: What are you tring to heat? Is it insulated? How tall are the ceilings? (Remark: They figure out that two of the heaters would work .</region>
      <region class="DoCO:TextChunk" id="73" confidence="possible">CUSTOMER: The reason it gets so cold is that right at the end of the hallway is where the stairs are and the stairs just go up to this great big cathedral ceiling.</region>
      <region class="DoCO:TextChunk" id="74" confidence="possible">SALESPERSON: Well maybe the problem isn't that you're not getting enough heat downstairs, maybe your problem is that you're not keeping the heat downstairs. Do you have a door across the stairs?</region>
      <region class="unknown" id="75">CUSTOMER: No.</region>
      <region class="DoCO:TextChunk" id="76" confidence="possible">SALESPERSON: Well that's the problem. You can put a ceiling fan and blow the hot air back down, or cover it up with some kind of door.</region>
      <region class="DoCO:FigureBox" id="F2">
        <caption class="deo:Caption" id="77">Figure 2: Reconceptualizing a Problem: From Generating to Containing Heat</caption>
      </region>
      <region class="DoCO:TextChunk" id="95">dilemmas to be resolved, rarely problems to be solved" [ <xref ref-type="bibr" rid="R18" id="78" class="deo:Reference">Lave 88</xref>]. III-defined problems cannot be delegated (e.g., from clients to professional software designers or professional architects), because the problems are not understood well enough that they can be described in sufficient detail. The owners of the problems need to be part of the problem solving team. Imagine in the above example, the customer would have not gone to the store himself but send someone else with a problem description to buy a heater. This person would have lacked the necessary background knowledge [Winograd, Flores 86] as well as the authority to redefine the problem on the fly.<marker type="block"/> In order to put problem owners in charge, future software environments must be able to interact with their users at the level of the task and not only on the level of the medium. Over the last decade, we have designed and evaluated several prototypes addressing this goal. This section will briefly describe the steps leading towards our current version of domain-oriented design environments as well as one example of such an environment.<marker type="block"/> The first step towards creating more human-centered computational environments was the development of general purpose programming environments exploiting the capabilities of modern workstations. While these environments were powerful and functionality rich, they required users to build their systems from scratch. Object-oriented design environments (such as Smalltalk, Clos, C++) represented an effort to create a market place [<xref ref-type="bibr" rid="R28" id="83" class="deo:Reference">Stefik 86</xref>] for software objects by providing substrates for reuse and redesign at the programming level. Their value is based on the empirical fact [Simon 81} that complex systems develop faster if they can be built on stable subsystems.<marker type="block"/> But domain-independent object-oriented systems are limited in the support they can provide at the problem level. They consist of low-level abstractions (e.g., statements and data structures in programming languages, primitive geometric objects in computer-aided design, etc.). Abstractions at that level are far removed from the concepts that form the basis of thinking in the application domains in which these artifacts are to operate. The great transformation distance between the design substrate and the application domain is responsible for the high cognitive costs and the great effort necessary to construct artifacts using computers.<marker type="page" number="6"/><marker type="block"/> Domain-oriented construction kits [<xref ref-type="bibr" rid="R14" id="88" class="deo:Reference">Fischer, Lemke 88</xref>] intentionally sacrifice generality for more elaborate support of domain semantics. But construction kits do not in themselves lead to the production of inter- esting artifacts [<xref ref-type="bibr" rid="R14" id="89" class="deo:Reference">Fischer, Lemke 88</xref>], because they do not help designers perceive the shortcomings of the artifact they are constructing. Artifacts by themselves do often not "talk back" [<xref ref-type="bibr" rid="R23" id="90" class="deo:Reference">Schoen 83</xref>] sufficiently, except to the most experienced designers. Critics [<xref ref-type="bibr" rid="R8" id="91" class="deo:Reference">Fischer et a</xref>l. 91 a] operationalize the concept of a situation that "talks back." They use knowledge of design principles to detect and critique partial and suboptimal solutions constructed by the designer.<marker type="block"/> JANUS: An Example. To illustrate some of the possibilities and limitations of these systems, we will use the JANUS system [<xref ref-type="bibr" rid="R8" id="93" class="deo:Reference">Fischer, McCa</xref>ll, Morch 89] as an "object-to-think-with." JANUS supports kitchen designers in the developments of floorplans. JANUS-CONSTRUCTION (see <xref ref-type="fig" rid="F3" id="94" class="deo:Reference">Figure 3</xref>) is the construction kit for the system. The palette of the construction kit contains domain-oriented building blocks such as sinks, stoves, and refrigerators. Designers construct by obtaining design units from the palette and placing them into the work area. In addition to design by composition (using the palette for constructing an artifact from scratch), JANUS-CONSTRUCTION also supports design by modification (by modifying existing designs from the catalog in the work area).</region>
      <region class="unknown" id="80">3 Domain·Oriented Design Environments</region>
      <region class="unknown" id="82">Towards Integrated, Domain-Oriented Design Environments.</region>
      <region class="DoCO:FigureBox" id="Fx86">
        <image class="DoCO:Figure" src="62nn.page_005.image_05.png" thmb="62nn.page_005.image_05-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="87">5</outsider>
      <region class="unknown" id="96">Cle:ar Woric Area Load</region>
      <region class="unknown" id="97">All Save 111 Catalo9</region>
      <region class="unknown" id="98">Edit Global Context</region>
      <region class="unknown" id="99">Jesnus-Const;ruct;ion AppJlanc#I PaJtJtt.</region>
      <region class="unknown" id="100">•• ••</region>
      <region class="DoCO:TextChunk" id="101" confidence="possible">I</region>
      <region class="unknown" id="102">Ii Í Catalog .. .. .. L-Shaped-Kltchsn ' •• •• 11-..... I:l ,</region>
      <region class="DoCO:FigureBox" id="F3">
        <caption class="deo:Caption" id="103">Figure 3: JANUS-CONSTRUCTION: The Work Triangle Critic</caption>
      </region>
      <region class="DoCO:TextChunk" id="104" confidence="possible">JANus-CoNsTRUCTION is the construction part of JANUS. Building blocks (design units) are selected from the Palette and moved to desired locations inside the Work Area. Designers can reuse and redesign complete floor plans from the Catalog. The Messages pane displays critic messages automatically after each design change that triggers a critic. Clicking with the mouse on a message activates JANUS-ARGUMENTATION and displays the argumentation related to that message.</region>
      <region class="DoCO:TextChunk" id="105" confidence="possible">The critics in JANUS-CONSTRUCTION identify potential problems in the artifact being designed. Their</region>
      <region class="DoCO:FigureBox" id="Fx106">
        <image class="DoCO:Figure" src="62nn.page_006.image_06.png" thmb="62nn.page_006.image_06-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="107">6</outsider>
      <region class="DoCO:TextChunk" id="160">knowledge about kitchen design includes design principles based on building codes, safety standards, and functional preferences. When a design principle (such as "the length of the work triangle is greater than 23 feet") is violated, a critic will fire and display a critique in the messages pane of <xref ref-type="fig" rid="F3" id="108" class="deo:Reference">Figure 3</xref>. This identifies a possibly problematic situation (a breakdown). and prompts the designer to reflect on it. The designer has broken a rule of functional preference, perhaps out of ignorance or by a temporary over- Sight.<marker type="block"/> Our original assumption was that designers would have no difficulty understanding these critic messages. Experiments with JANUS [<xref ref-type="bibr" rid="R8" id="110" class="deo:Reference">Fischer, McCa</xref>ll, Morch 89] demonstrated that the short messages the critics present to designers do not reflect the complex reasoning behind the corresponding deSign issues. To overcome this shortcoming, we initially developed a static explanation component for the critic messages [Lemke, <xref ref-type="bibr" rid="R10" id="111" class="deo:Reference">Fischer 90</xref>]. The design of this component was based on the assumption that there is a "right" answer to a problem. But the explanation component proved to be unable to account for the deliberative nature of design problems. Therefore, argumentation about issues raised by critics must be supported, and argumentation must be integrated into the context of construction. JANUS-ARGUMENTATION is the argumentation component of JANUS [<xref ref-type="bibr" rid="R8" id="112" class="deo:Reference">Fischer et a</xref>l. 91 a]. It is an argumentative hypertext system offering a domain-oriented, generic issue base about how to construct kitchens. With JANUS-ARGUMENTATION, designers explore issues, answers, and arguments by navigating through the issue base. The starting point for the navigation is the argumentative context triggered by a critic message in JANUS- CONSTRUCTION. By combining construction and argumentation, JANUS was developed into an integrated design environment supporting "reflection-in-action" as a fundamental process underlying design activities [<xref ref-type="bibr" rid="R23" id="113" class="deo:Reference">Schoen 83</xref>].<marker type="block"/> But even integrated design environments have their shortcomings. Design in real world situations deals with complex, unique, uncertain, conflicted, instable situations of practice. Design knowledge as em- bedded in design environments will never be complete because design knowledge is tacit (i.e., competent practitioners know more than they can say [<xref ref-type="bibr" rid="R20" id="115" class="deo:Reference">Polanyi 66</xref>]), and additional knowledge is triggered and ac- tivated by situations and breakdowns. These observations require computational mechanisms in support of end-user modifiability [<xref ref-type="bibr" rid="R10" id="116" class="deo:Reference">Fischer, Girgensohn 90</xref>]. The end-user modifiability of JANUS allows users to introduce new design objects (e.g., a microwave). new critiquing rules (e.g., appliances should be against a wall unless one deals with an island kitchen), and (3) kitchen deSigns which fit the needs of a blind person or a person in a wheelchair.<marker type="block"/> A Historical Context. Computers in their early days were used to compute. The typical problem at the time was: take a given algorithm and code it in assembly language. The process of programming was totally computer-centered (<xref ref-type="fig" rid="F4" id="118" class="deo:Reference">Figure 4</xref>). A large transformation distance existed between the problem description and its solution as a computer program.<marker type="block"/> High-level programming languages (Fortran, Lisp, Cobol, Algol, etc.) became available in the 1960s. Certain problem domains could be mapped more naturally to programming languages (e.g., algebraic expressions, recursive functions, etc.). While all of the languages remained general purpose programming languages, a certain problem orientation was associated with individual languages (e.g., Lisp for AI, Fortran for scientific computing). The professional computing community started to become specialized: (1) compiler designer (creating programs that mapped from high-level languages to assembly language), and (2) software engineers (creating programs that mapped problems to programming languages).<marker type="page" number="8"/><marker type="block"/> In the 1970s and 1980s new classes of programs appeared: spreadsheets, query languages for databases, and powerful interactive programming environments. Spreadsheets were successful for three major reasons: (1) they relied on a model and packaged computational capability in a form that the user community was familiar with, (2) they added important functionality (propagation of changes) that did not exist in the non-computational media, and (3) they avoided the pitfall of excess generality: Instead of serving all needs obscurely, they serve a few needs well [<xref ref-type="bibr" rid="R24" id="126" class="deo:Reference">Shaw 89</xref>]. These types of systems can be considered to be construction kits with limited domain-orientation. In our own work, we demonstrated [<xref ref-type="bibr" rid="R8" id="127" class="deo:Reference">Fischer, Ra</xref>thke 88] that the spreadsheet model can be further enhanced by adding additional domain knowledge to it.<marker type="block"/> By extending construction kits with critiquing and argumentation components, design environments (<xref ref-type="fig" rid="F5" id="129" class="deo:Reference">Figure 5</xref>) have the potential to put domain experts (the problem owners) in charge. Computational environments based on design environment architectures lead to a further specialization among computer users: knowledge engineers in collaboration with domain workers create design environments (at least the seeds for them [Fischer et al. 91 b)) and domain workers use and evolve the seeded environments.<marker type="block"/> So far we used the concept of "ownership" in a way suggesting that there is "an owner" of a problem ignoring that realistic design problems are mUlti- person activities where ownership is distributed. The reason for this is that neither clients, system designers, nor users have a very good idea of what they want a system to do at the outset of a project. Rittel [Rittel 84] speaks of "a symmetry of ignorance" arguing that knowledge for design problems is distributed among many people, and that there is nobody among those carriers of knowledge who has a guarantee that her/his knowledge is superior to any other person's knowledge with regard to the problem at hand. The notion of "owning" is related to the amount of right, power, authority, responsibility for contributing to the definition of a problem, and how much people are affected by the solution.<marker type="block"/> By collaborating with an architectural firm, we recently encountered a convincing example illustrating<marker type="page" number="9"/><marker type="block"/> several of the issues discussed in this paper. The task the firm competed for was the design (and later construction) of the Denver Public Library. The final design competition took place in 1991, followed by construction to be finished by 1995. The City and County of Denver added as a constraint to the design that the library should not undergo major modifications for the first 15 years. While one may argue that the design task is to create a building, the real question is ''what is the function of a public library for a large city in the year 201 O?" Who is the owner of the problem? The client (I.e., the City and County of Denver, represented by librarians who have love affairs with books as well as techies who think there will be no books around in 20 years), the designers, and/or the customers who will eventually use the library?<marker type="block"/> In cases where is no single owner of a problem, the communication between all the "stakeholders" in the problem is of crucial importance. Shared understanding [<xref ref-type="bibr" rid="R21" id="142" class="deo:Reference">Resnick 91</xref>] needs to be created. One way to do this is to develop languages of doing [<xref ref-type="bibr" rid="R7" id="143" class="deo:Reference">Ehn 88</xref>] which create the possibility of mutual learning, thereby establishing a relationship of professional parity between system designers and system users.<marker type="block"/> How are Owners of Problem Put In Charge with Design Environments. The domain-orientation of design environments allows owners of problems to communicate with the systems at a level that is situated within their own world [<xref ref-type="bibr" rid="R14" id="145" class="deo:Reference">Fischer, Lemke 88</xref>; <xref ref-type="bibr" rid="R29" id="146" class="deo:Reference">Suchman 87</xref>; <xref ref-type="bibr" rid="R31" id="147" class="deo:Reference">Wenger 90</xref>]. By supporting languages of doing [<xref ref-type="bibr" rid="R7" id="148" class="deo:Reference">Ehn 88</xref>1 such as prototypes, mock-ups, scenarios, created images, or visions of the future, design environments have the advantage of making it easier for owners of problems to partiCipate in the design process, since the representations of the evolving artifacts are less abstract and less alienated from practical use situations. By keeping owners in the loop, they support the integration of problem setting and problem solving and allow software systems to deal with fluctuating and evolving requirements. By making information relevant to the task at hand [<xref ref-type="bibr" rid="R8" id="149" class="deo:Reference">Fischer, Na</xref>kakoji 91], they are able to deliver the right knowledge, in the context of a problem or a service, at the right moment for a human professional to consider.<marker type="block"/> The Costs of NOT Putting Owners of Problems In Charge. By requiring high-tech scribes as inter- mediaries, designers are limited in solving ill-defined problems [<xref ref-type="bibr" rid="R26" id="151" class="deo:Reference">Simon 73</xref>]. III-defined problems cannot be delegated because if they are delegated, situations do not "talk back" to the owners of the problems who<marker type="page" number="10"/><marker type="block"/> have the necessary knowledge to incrementally refine them. New requirements emerge during development, because they can not be identified until portions of the system have been designed or implemented. Traditional software design methodologies (such as the waterfall model, insisting on a strong separation between analysis and synthesis) have no chance to succeed in such situations. Alternatives approaches, such as methodologies allowing the co-evolution of specification and implementation, are needed [<xref ref-type="bibr" rid="R30" id="154" class="deo:Reference">Swartout, Balzer 82</xref>; <xref ref-type="bibr" rid="R8" id="155" class="deo:Reference">Fischer, Na</xref>kakoji 91].<marker type="block"/> Alexander [<xref ref-type="bibr" rid="R1" id="158" class="deo:Reference">Alexander 64</xref>] has introduced the distinction between an un-selfconscious culture of design and a self-conscious culture of design. In an un-selfconscious culture of design, the failure or inadequacy of the form leads directly to an action to change or improve it (e.g., the owner of a house is its own builder, the form makers do not only make the form but they lived with it). This closeness of contact between designer and product allows constant rearrangement of unsatisfactory details. By putting owners of problems in charge, the positive elements of an un-selfconscious culture of design can be exploited in the development of software systems. Some of the obvious shortcomings of un-selfconscious culture of design, such as that they offer few opportunities for reflection is reduced by incorporating critics into the environments [<xref ref-type="bibr" rid="R8" id="159" class="deo:Reference">Fischer et a</xref>t. 91 a].</region>
      <region class="DoCO:FigureBox" id="Fx120">
        <image class="DoCO:Figure" src="62nn.page_007.image_07.png" thmb="62nn.page_007.image_07-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="122">7</outsider>
      <region class="unknown" id="123">Assembly Languages</region>
      <region class="unknown" id="124">Problems</region>
      <region class="DoCO:FigureBox" id="F4">
        <caption class="deo:Caption" id="125">Figure 4: The 1950s: Describing Problems in the Computer's Internal Language</caption>
      </region>
      <region class="unknown" id="131">4 Assessment, Evaluation and Implications Is There an Owner or are There Owners of Problems?</region>
      <region class="DoCO:FigureBox" id="Fx133">
        <image class="DoCO:Figure" src="62nn.page_008.image_08.png" thmb="62nn.page_008.image_08-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="135">8</outsider>
      <region class="DoCO:FigureBox" id="Fx136">
        <image class="DoCO:Figure" src="62nn.page_009.image_09.png" thmb="62nn.page_009.image_09-thumb.png"/>
        <image class="DoCO:Figure" src="62nn.page_009.image_10.png" thmb="62nn.page_009.image_10-thumb.png"/>
      </region>
      <region class="unknown" id="137">Programming Languages</region>
      <region class="DoCO:FigureBox" id="Fx138">
        <image class="DoCO:Figure" src="62nn.page_009.image_11.png" thmb="62nn.page_009.image_11-thumb.png"/>
      </region>
      <region class="unknown" id="139">Design Environments Problem Domains</region>
      <region class="DoCO:FigureBox" id="F5">
        <caption class="deo:Caption" id="140">Figure 5: The 1990s: Domain-Oriented Design Environments</caption>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="153">9</outsider>
      <region class="unknown" id="157">Recreating Un-selfconsclous Cultures of Design.</region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="161" page="10" column="1">5 Conclusions</h1>
        <region class="DoCO:TextChunk" id="164" page="10" column="1">Achieving the goal of putting problem owners in charge by developing design environments is not only a technical problem, but a considerable social effort. If the most important role for computation in the future is to provide people with a powerful medium for expression, then the medium should support them in working on the task, rather than requiring them to focus their intellectual resources on the medium itself. <marker type="block"/> The analogy to writing and its historical development suggest the goal "to take the control of computational media out of the hands of high-tech scribes." Pournelle (in BYTE, September 1990, p. 281 and p. 304) argues that "putting owners of problems in charge" has not always been the research direction of professional computer scientist: "In Jesus' time, those who could read and write were in a different caste from those who could not. Nowadays, the high priesthood tries to take over the computing business. One of the biggest obstacles to the future of computing is C. C is the last attempt of the high priesthood to control the computing business. It's like the scribes and the Pharisees who did not want the masses to leam how to read and write."<marker type="block"/> Design environments are promising architectures to put owners of problems in charge. They are based on the basic belief that humans enjoy deciding and doing. They are based on the assumption that the experience of having partiCipated in a problem makes a difference to those who are affected by the solution. People are more likely to like a solution if they have been involved in its generation; even though it might not make sense otherwise.</region>
        <region class="DoCO:FigureBox" id="Fx165">
          <image class="DoCO:Figure" src="62nn.page_010.image_12.png" thmb="62nn.page_010.image_12-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="166" confidence="possible" page="10" column="1">Acknowledgments The author would like to thank the members of the Human-Computer Communication group at the University of Colorado who contributed to the conceptual framework and the systems discussed in this article. The research was supported by the National Science Foundation under grants No. CDA-8420944, IRI-8722792, and IRI-9015441; by the Army Research Institute under grant No. MDA903-86-C0143, and by grants from the Intelligent Interfaces Group at NYNEX, from Software Research Associates (SRA), Tokyo, and by the Software Designer's Associate (SDA) Consortium, Tokyo.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="167" page="11" column="1">10</outsider>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="168" page="11" column="1">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="169" page="11" column="1">[Alexander 64] C. Alexander, The Synthesis of Form, Harvard University Press, 1964.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="170" page="11" column="1">[Belady 85] L. Belady, MCC: Planning the Revolution in Software, IEEE Software, November 1985, pp. 68-73.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="171" page="11" column="1">[Brooks 87] F.P. Brooks Jr., No Silver Bullet: Essence and Accidents of Software Engineering, IEEE Computer, Vol. 20, No.4, April 1987, pp. 10-19.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="172" page="11" column="1">[CSTB 90} Computer Science and Technology Board, Scaling Up: A Research Agenda for Software Engineering, Communications of the ACM, Vol. 33, No.3, March 1990, pp. 281-293.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="173" page="11" column="1">[Curtis, Krasner, Iscoe 88] B. Curtis, H. Krasner, N. Iscoe, A Field Study of the Software Design Process for Large Systems, Communications of the ACM, Vol. 31, No. 11, November 1988, pp. 1268-1287.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="174" page="11" column="1">[Denning 88] P. Denning, Awakening, Communications of the ACM, Vol. 31, No. 11, November 1988, pp. 1254-1255.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="175" page="11" column="1">[Ehn 88] P. Ehn, Work-Oriented Design of Computer Artifacts, Almquist &amp; Wiksellinternational, 1988.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="176" page="11" column="1">[Fischer et al. 91 a] G. Fischer, A.C. Lemke, R. McCall, A. Morch, Making Argumentation Serve Design, Human Computer Interaction, Vol. 6, No. 3-4, 1991, pp. 393-419.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="177" page="11" column="1">[Fischer et al. 91 bJ G. Fischer, A.C. Lemke, T. Mastaglio, A.1. Morch, Critics: An Emerging Approach to Knowledge-Based Human Computer Interaction, International Journal of Man-Machine Studies, Vol. 35, No.5, 1991, pp. 695-721.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="178" page="11" column="1">[Fischer, Girgensohn 90] G. Fischer, A. Girgensohn, End-User Modifiability in Design Environments, Human Factors in Computing Systems, CHI'90 Conference Proceedings (Seattle, WA), ACM, New York, April 1990, pp. 183-191.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="179" page="11" column="1">[Fischer, Lemke 88] G. Fischer, A.C. Lemke, Construction Kits and Design Environments: Steps Toward Human Problem-Domain Communication, Human-Computer Interaction, Vol. 3, No.3, 1988, pp. 179-222.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="180" page="11" column="1">[Fischer, McCall, March 891 G. Fischer, R. McCall, A. Morch, Design Environments for Constructive and Argumentative Design, Human Factors in Computing Systems, CHI'89 Conference Proceedings (Austin, TX), ACM, New York, May 1989, pp. 269-275.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="181" page="11" column="1">[Fischer, Nakakoji 91] G. Fischer, K. Nakakoji, Making Design Objects Relevant to the Task at Hand, Proceedings of MAI-91, Ninth National Conference on Artificial Intelligence, AMI Pressrrhe MIT Press, Cambridge, MA, 1991, pp. 67-73.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="182" page="11" column="1">[Fischer, Rathke 88] G. Fischer, C. Rathke, Knowledge-Based Spreadsheet Systems, Proceedings of MAI-88, Seventh National Conference on Artificial Intelligence (S1. Paul, MN), Morgan Kaufmann Publishers, San Mateo, CA, August 1988, pp. 802-807.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="183" page="11" column="1">[Fischer, Reeves 92] G. Fischer, B.N. Reeves, Beyond Intelligent Interfaces: Exploring, Analyzing and Creating Success Models of Cooperative Problem Solving, Applied Intelligence, Special Issue Intelligent Interfaces, 1992, (in press).</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="184" page="11" column="1">[Henderson, Kyng 911 A. Henderson, M. Kyng, There's No Place Like Home: Continuing Design in Use, in J. Greenbaum, M. Kyng (eds.), Design at Work: Cooperative Design of Computer Systems, Lawrence Erlbaum Associates, Hillsdale, NJ, 1991, pp. 219-240, ch. 11.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="185" page="11" column="1">[lilich 73] I. IIlich, Tools for Conviviality, Harper and Row, New York, 1973.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="188" page="12" column="1">[Lave 88] J. Lave, Cognition in Practice, Cambridge University Press, Cambridge, UK, 1988.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="189" page="12" column="1">[Lemke, Fischer 90) A.C. Lemke, G. Fischer, A Cooperative Problem Solving System for User Interface Design, Proceedings of AAAI-90, Eighth National Conference on Artificial Intelligence, AMI PressfThe MIT Press, Cambridge, MA, August 1990, pp. 479-484.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="190" page="12" column="1">[Polanyi 66] M. Polanyi, The Tacit Dimension, Doubleday, Garden City, NY, 1966.</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="191" page="12" column="1">[Resnick 91] l.B. Resnick, Shared Cognition: Thinking as Social Practice, in l.B. Resnick, J.M. Levine, S.D. Teasley (eds.), Perspectives on Socially Shared Cognition, American Psychological Association, Washington, D.C., 1991, pp. 1-20, ch. 1.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="192" page="12" column="1">[RitteI84] H.W.J. Rittel, Second-Generation Design Methods, in N. Cross (ed.), Developments in Design Methodology, John Wiley &amp; Sons, New York, 1984, pp. 317-327.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="193" page="12" column="1">[Schoen 83] D.A. Schoen, The Reflective Practitioner: How Professionals Think in Action, Basic Books, New York, 1983.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="194" page="12" column="1">[Shaw 89] M. Shaw, Maybe Your Next Programming Language Shouldn't Be a Programming Language, in Computer Science and Technology Board (eds.), Scaling Up: A Research Agenda for Software Engineering, National Academy Press, 1989, pp. 75-82.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="195" page="12" column="1">[Sheil 83] B.A. Sheil, Power Tools for Programmers, Datamation, February 1983, pp. 131-143.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="196" page="12" column="1">[Simon 73] H.A. Simon, The Structure of /II-Structured Problems, Artificial Intelligence, No.4, 1973, pp. 181-200.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="197" page="12" column="1">[Simon 81] H.A. Simon, The Sciences of the Artificial, The MIT Press, Cambridge, MA, 1981.</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="198" page="12" column="1">[Stefik 86] M.J. Stefik, The Next Knowledge Medium, AI Magazine, Vol. 7, No.1, Spring 1986, pp. 34-46.</ref>
          <ref rid="R29" class="deo:BibliographicReference" id="199" page="12" column="1">[Such man 87] l.A. Suchman, Plans and Situated Actions, Cambridge University Press, Cambridge, UK, 1987.</ref>
          <ref rid="R30" class="deo:BibliographicReference" id="200" page="12" column="1">[Swartout, Balzer 82] W.R. Swartout, R. Balzer, On the Inevitable Intertwining of Specification and Implementation, Communications of the ACM, Vol. 25, No.7, July 1982, pp. 438-439.</ref>
          <ref rid="R31" class="deo:BibliographicReference" id="201" page="12" column="1">[Wenger 90] E. Wenger, Toward a Theory of Cultural Transparency: Elements of a Social Discourse of the Visible and the Invisible, Dissertation, Information and Computer Science, University of California, Irvine, CA, 1990.</ref>
          <ref rid="R32" class="deo:BibliographicReference" id="202" page="12" column="1">[Winograd 79] T. Winograd, Beyond Programming Languages, Communications of the ACM, Vol. 22, No.7, July 1979, pp. 391-401.</ref>
          <ref rid="R33" class="deo:BibliographicReference" id="203" page="12" column="1">[Winograd, Flores 86) T. Winograd, F. Flores, Understanding Computers and Cognition: A New Foundation for Design, Ablex Publishing Corporation, Norwood, NJ, 1986.</ref>
        </ref-list>
        <region class="DoCO:FigureBox" id="Fx186">
          <image class="DoCO:Figure" src="62nn.page_011.image_13.png" thmb="62nn.page_011.image_13-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="187" page="12" column="1">11</outsider>
        <region class="DoCO:FigureBox" id="Fx204">
          <image class="DoCO:Figure" src="62nn.page_012.image_14.png" thmb="62nn.page_012.image_14-thumb.png"/>
        </region>
      </section>
    </body>
  </article>
</pdfx>
