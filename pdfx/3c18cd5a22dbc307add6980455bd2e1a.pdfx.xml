<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>b27985ebce9d49462a75db69b0c436985b546372e658bb0f3e043158f083f0a5</job>
    <base_name>62q8</base_name>
    <doi confidence="possible" alt_doi="http://dx.doi.org/10.1007/978-3-642-61340-1_6">http://dx.doi.org/10.1145/322609.322655</doi>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">Purdue University</outsider>
      <region class="unknown" id="2">Purdue e-Pubs Computer Science Technical Reports Department of Computer Science</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="3">1985</outsider>
      <title-group>
        <article-title class="DoCO:Title" id="4">A Survey of Program Design Languages (PDLs)</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="5">Brian A. Nejmeh Herbert E. Dunsmore</name>
        </contrib>
      </contrib-group>
      <outsider class="DoCO:TextBox" type="sidenote" id="6">Purdue</outsider>
      <region class="unknown" id="8">University, <email id="7">dunsmore@cs.purdue.edu</email></region>
      <region class="unknown" id="9">Number:</region>
      <outsider class="DoCO:TextBox" type="sidenote" id="10">Report 85-510</outsider>
      <outsider class="DoCO:TextBox" type="sidenote" id="11">Nejmeh, Reports.</outsider>
      <region class="unknown" id="13">Brian A. and Dunsmore, Herbert E., "A Survey of Program Design Languages (PDLs)" (1985). Computer Science Technical Paper 432. <ext-link ext-link-type="uri" href="http://docs.lib.purdue.edu/cstech/432" id="12">http://docs.lib.purdue.edu/cstech/432</ext-link></region>
      <outsider class="DoCO:TextBox" type="footer" id="15">This document has been made available through Purdue e-Pubs, a service of the Purdue University Libraries. Please contact <email id="14">epubs@purdue.edu</email> for additional information.</outsider>
      <region class="DoCO:TextChunk" id="16" confidence="possible">A SURVEY OF PROGRAM DESIGN LANGUAGES (POLs)</region>
      <region class="unknown" id="17">Brian A. Nejmeh</region>
      <region class="unknown" id="18">H. E. Dunsmore</region>
      <region class="DoCO:TextChunk" id="19" confidence="possible">CSD-TR-510</region>
      <region class="unknown" id="20">April, 1985</region>
      <region class="DoCO:FigureBox" id="Fx21">
        <image class="DoCO:Figure" src="62q8.page_002.image_01.png" thmb="62q8.page_002.image_01-thumb.png"/>
      </region>
      <region class="unknown" id="22">A Survey of Program Design Lsngnages (PDLs)</region>
      <region class="unknown" id="23">CSD·TR·SlO</region>
      <region class="unknown" id="24">Brian A. Nejmeh and H. E. Dunsmore *</region>
      <region class="unknown" id="25">Department of Computer Sciences Purdue University</region>
      <region class="unknown" id="26">Wed Lafayette, IN 47906</region>
      <region class="unknown" id="27">Abstract</region>
      <outsider class="DoCO:TextBox" type="sidenote" id="28">a</outsider>
      <outsider class="DoCO:TextBox" type="sidenote" id="29">of</outsider>
      <region class="unknown" id="30">The need to improve software productivity and reliability has become an area of increasing importance to the software engineering community. During the early phases of the software life cycle, there is a strong need to emphasize the usc of tools which provide representation of the program structure that can be easily understood and modified. Thus, a significant usage of Program Design Languages (PDLs) as a design tool in practical environments has surfaced in recent years. This paper discusses the desired characteristics such a design tool and surveys a representative sample of existing program design languages. Finally, a new POL is proposed for consideration.</region>
      <region class="DoCO:TextChunk" id="31" confidence="possible">Index Terms - design ~oolsJ program design languages, formally defined design constructs, sof~ware reusability, software metrics, PDL Environment.</region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="32" page="3" column="1">1 Introduction</h1>
        <region class="unknown" id="33" page="3" column="1">in</region>
        <region class="DoCO:TextChunk" id="34" confidence="possible" page="3" column="1">This paper surveys the state of ~he ar~ the area of program design languages (POLs). Section 2 defines the classical software life cycle, while Sections 3 and 4 of the paper focus more on ~he software design phase and motiva~e ~he need for software design tools. Section 5 of the paper discusses existing software design tools and establishes POLs as ~he design</region>
        <region class="DoCO:TextChunk" id="35" confidence="possible" page="3" column="1">"' This research was 1298-50-13985 and In~ernational</region>
        <region class="DoCO:TextChunk" id="36" confidence="possible" page="3" column="1">by the Na~ional Science Foundation under contract number Business Machines under contract D1nr..ber 0266-57-13985.</region>
        <outsider class="DoCO:TextBox" type="footer" id="37" page="3" column="1">1</outsider>
        <region class="DoCO:FigureBox" id="Fx38">
          <image class="DoCO:Figure" src="62q8.page_003.image_02.png" thmb="62q8.page_003.image_02-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="header" id="39" page="4" column="1">,</outsider>
        <region class="DoCO:TextChunk" id="40" page="4" column="1">tool of choice for further consideration. Section 6 of the paper defines PDLs more Connally and describes eight desired characteristics of them. Section 7 surveys seven existing PDLs in terms of these desired characterist.ics. Section 8 of the paper offers a perspective on the future of program design languages in software engineering and proposes a new PDL Environment.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="41" page="4" column="1">2 The Software Life-Cycle</h1>
        <region class="DoCO:TextChunk" id="48" page="4" column="1">There are basically six phases of the traditional software life cycle, each phase having a fairly well-defined starting and ending point. However, it should be noted that overlap is typical when making the transition from one phase into the next phase of the life cycle. A brief description of the essential phases of the software life cycle, assuming the feasibility of the project has been established, now follows. For a more complete definition of the software life cycle phases see [BoehmS!]: <marker type="block"/> Requirements Analysis During this initial phase of the life cycle a complete, val· idated specification of the required functions, interfaces, and performance of the software system is specified. It is during this phase of the software life cycle that the issues of resource needs and preliminary budget estimates should be addressed'.<marker type="block"/> Software Design In this phase of the software development process th~ determi- nation, specification, and review of software architecture, program design, and data base design necessary to meet the requiremt'nts of the software system are completed.<marker type="block"/> Coding/Implementation In this phase of the development process a complete, verified set of program components are constructed.<marker type="block"/> Integration During this part of the software life cycle, a properly functioning software system composed of the software componcnts is assembled.<marker type="block"/> Testing At this point in the software life cycle the verification and validation of the software system is performed.<marker type="block"/> Maintenance Upon the delivery of the software system to the user, the maintenance phase of the software life cycle begins. During this final phase of thc software life cycle the correction, modification, and enhancement of the software system takes place.</region>
        <outsider class="DoCO:TextBox" type="footer" id="49" page="4" column="1">2</outsider>
        <region class="DoCO:FigureBox" id="Fx50">
          <image class="DoCO:Figure" src="62q8.page_004.image_03.png" thmb="62q8.page_004.image_03-thumb.png"/>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="51" page="5" column="1">3 The Design Phase</h1>
        <region class="DoCO:TextChunk" id="52" confidence="possible" page="5" column="1">Since this paper focuses primarily on the design phase, a closer look at this phase of the software life cycle now follows.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="53" page="5" column="1">3.1 Transition from Requirem.ents Analysis to Software Design</h2>
          <region class="DoCO:TextChunk" id="54" page="5" column="1">II; has become common practice during the requirements phase of the software life cycle to retain some ambiguity. It is important to note, however, that any items which are vague, missing, undefined, or contradictory should be resolved prior to entering program design. That is, the prevailing attitude of "It is always too early to specify desires, and never too late to make a change" should be prevented; otherwise schedule slippages, low reliability, and cost overl'UllS will be commonplace. Indeed this phenomenon of changing or inadequate requirements is a major !=,bstacle in the software development proccss [Zolno82J. Once the requirements phase has been thoroughly completcd, design should begin. Each of the requirements should be mapped onto segments of the design that satisfy them. In short, a set of requircments form a specification for design.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="55" page="5" column="1">3.2 The Essence of Software Design</h2>
          <region class="DoCO:TextChunk" id="56" confidence="possible" page="5" column="1">3.2 The Essence of Software Design As suggested by DeMarco IDeMarco82], a specific software design can be considered a model of one particular way of meeting the software requirements. Thc best designs are formal representatiom: of the software to be implemented. DeMarco further suggests that design is the thinking process that has to precede the action of implementation. A software design can be thought of as a "rigorous blueprint for implementation." There are many different design methodologies. Generally, one uses a structured (i.e., top-down) design which involves the analysis of the functions of a process and their refine- mcnt to modules small enough to be effectively developed and managed. Typically, modules should not exceed one page of code; some empirical data suggests that modules in excess of one page of code are very error prone (Potier]. One of the most widely used design methodologies, the Jackson Method [Jack75], involves the following four basic steps. 1. Design the structure of the input data. 2. Design the structure of the output data. 3. Indicate the required mapping from input to output data (i.c., which input yielw which output). 4. Design the program to produce the desired traIl8(ormation from inputs to outputs.</region>
          <region class="DoCO:TextChunk" id="57" confidence="possible" page="5" column="1">Another popular design methodology is Parnas' [Parnas72, Parnas79] "information hiding" concept. This methodology contends that software systcms should be designed with</region>
          <outsider class="DoCO:TextBox" type="footer" id="58" page="5" column="1">3</outsider>
          <region class="DoCO:FigureBox" id="Fx59">
            <image class="DoCO:Figure" src="62q8.page_005.image_04.png" thmb="62q8.page_005.image_04-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="60" page="6" column="1">change in mind, so that they can remain basically the same throughout the life of the sy::ltem. This will help to decrease the overall effort required to make the changes which eventually come about in a system. Pamas also suggests that the details of how a particular module makes use of infonnation and does its processing should be "'hidden" from the person using the module. Regardless of the design methodology one employs, the design process itself is typically divided into two general phases - the general program design and the detailed program design phase. General program design involves deciding what functions are needed to fulfill the software requirements. Detailed program design involves the consideration of how to implement these functions. In order to make the transition from general to detailed program design, design by iteration is often used. Design by iteration takes place in the following manner: 1) Initial design (General Design) partitions the over-all problem into a set of related functions. 2) Design is then repeatedly refined as more and more detail is added to the functions. 3) The first few iterations constitute general design, while the later iterations constitute the detailed design phase.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="61" page="6" column="1">3.3 Transition from Design to Implementation</h2>
          <region class="DoCO:TextChunk" id="62" page="6" column="1">When the software design has been completed and approved, subsequent iterations convert the design into code which constitntes the delivered software product. Each segment of the design can be mapped onto code. The implementation (coding) process yields a more complete understanding of the design, and hence may bring about changes in the design. If this is indeed the case, one should expect to perfonn several iterations from design to coding. In short, design forms a specification for implementation. Hence, there should be a strong relationship between the design, and the code implemented from the design. The following five relationships should be maintained in the this transition: 1. I-Many relationship between design constructs and the lines of code necessary to implement the constructs. 2. 1-1 relationship between modules. 3. 1-1 relationship between module interfaces. 4. 1-1 relationship between control How (While, For, H-Then,ctc) 5. I-I relationship between intermodule cODDections.</region>
          <outsider class="DoCO:TextBox" type="footer" id="63" page="6" column="1">4</outsider>
          <region class="DoCO:FigureBox" id="Fx64">
            <image class="DoCO:Figure" src="62q8.page_006.image_05.png" thmb="62q8.page_006.image_05-thumb.png"/>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="65" page="7" column="1">4 Motivation for Software Design Tools</h1>
        <region class="DoCO:TextChunk" id="66" confidence="possible" page="7" column="1">The need to improve software productivity and reliability has been increasingly important to the software engineering community. A potential step toward improvement in these areas is the emphasis on tools during the early phases of the software life cycle which provide a representation of the program structure and which can be easily understood and modified. The "motivating factors for useful software design tools follow.</region>
        <region class="DoCO:TextChunk" id="71" page="7" column="1">4.1 Software Development Costs Continue to Soar Software development costs continue to soar ( <xref ref-type="bibr" rid="R3" id="67" class="deo:Reference">BoehmS</xref>!, <xref ref-type="bibr" rid="R32" id="68" class="deo:Reference">Vick84</xref>, WilliamsB4), hence there<marker type="block"/> programming environments could help increase programmer productivity, thereby reducing costs.</region>
        <region class="unknown" id="70" page="7" column="1">is a need for programming environments that support the entire software life cycle. Such</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="72" page="7" column="1">4.2 Schedule Slippages Are Comm.onplace</h2>
          <region class="DoCO:TextChunk" id="73" confidence="possible" page="7" column="1">In addition to the cost overruns associated with the development of today 's software systems, we are having increasing difficulty in delivering software in a timely manner. Boehm [Boehm8!J and others cite cases of 100 to 200 % delay in the delivery of software. Effective design tools might help in the delivery of software in a more timely manner.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="74" page="7" column="1">4.3 Increasing Importance of Software Reliability</h2>
          <region class="DoCO:TextChunk" id="75" confidence="possible" page="7" column="1">Software reliability has become a problem of increased importance as real-time applications of computers emerge in (for example) financial arenas, the military, and the medical profession. In these domains there is an increasing need for software to do precisely what it was designed to do. Thus, a high degree of reliability is essential, so as Dot to cause huge economic loss or endanger human life. The ability to develop reliable software is of extreme importance. Menws !Mend82J reports that up to 60 % of software errors can be traced back to design errors. Beregi [Beregi84] also found that over 50 % of the "post_release" errors in software developed at IBM were found to be traceable to errors in product design. Moreover, it is a well-known fact that the later in the software life cycle a design error is found, the more costly it is to fix the error. Lack of good, reliable design tools can lead to very high software development costs and low levels of software reliability. Thus, better software design tools arc essential if we are to produce more reliable software systems.</region>
          <outsider class="DoCO:TextBox" type="footer" id="76" page="7" column="1">5</outsider>
          <region class="DoCO:FigureBox" id="Fx77">
            <image class="DoCO:Figure" src="62q8.page_007.image_06.png" thmb="62q8.page_007.image_06-thumb.png"/>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="78" page="8" column="1">4.4 Ivlonitor Changing Requirements</h2>
          <region class="DoCO:TextChunk" id="79" page="8" column="1">~ was noted in section 3.1, there bas been increasing concern over the problem of cbanging or inadequate requirements. At least one researcher (Zolllo82] has pointed out that the we of automated design tools could be of assistance in monitoring the problems of changing user requirements. The "fingerprinting" technique proposed by Wang [Wang84J could be used to mo:aitor cbanging requirements (and the like) during software development. In general, a closer monitoring of the mapping from requirements to design would give one some indication of the stability of system requirements.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="80" page="8" column="1">4.5 Test Plan Specifics.tion</h2>
          <region class="unknown" id="81" page="8" column="1">a</region>
          <region class="DoCO:TextChunk" id="82" page="8" column="1">Testing and debugging costs range from 50% to 80% of the cost to produce a software system [Beizer84J. This implies that more effective ways of managing the testing of software systems is certainly needed. A good design tool sbould enhance our ability to draft an priori test plan to check such conditions as: 1. interface verification 2. boundary value data exceptions 3. proper tenninating sequences 4. constraint violations 5. singular points When drafting such a test plan one should refer back to the software requirements as well; doing so will lead to a more thorough and complete test plan for the software system.</region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="83" page="8" column="1">5 Existing Design Tools</h1>
        <region class="DoCO:TextChunk" id="87" page="8" column="1">For the past several years, researchers have been working on design tools to improve the software development process. However, although many design tools have been introduced, no single design tool has gained wide acceptance. Typically, software developers find themselves in a. situation where DO single design tool suits all their needs [Bracon83]_ This is due to the fact that design is very dependent on software quality factors such as efficiency, reliability, testability, reusability, maintainability, and portability. Thus, the software engineering community is in quest of a design tool which promotes a high level of software quality across the board. Given the number of software design tools, design is often expressed in a variety of notations, including graphic displays, Bow charts, mathematical representations, and programming language-oriented representations. Often multiple notations are used for a single project [Beregi84]. This forces designers to transfer from one design notation to another as they redefine the design. This can lead to problems of increased software defects, decreased <marker type="page" number="9"/><marker type="block"/> understandability, and increased levels of effort required to produce a software system. Hence, the ideal situation would be the emergence of one superior design tool. A closer look at the different classes of design tools follows.</region>
        <outsider class="DoCO:TextBox" type="footer" id="85" page="8" column="1">6</outsider>
        <region class="DoCO:FigureBox" id="Fx86">
          <image class="DoCO:Figure" src="62q8.page_008.image_07.png" thmb="62q8.page_008.image_07-thumb.png"/>
        </region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="88" page="9" column="1">5.1 Graphic Approaches</h2>
          <region class="DoCO:TextChunk" id="89" page="9" column="1">Structured flow charts INassi731 and HIPO diagrams [8tay76J typify this class of software design tools. These provide a high-level overview of a program. They describe in general terms what data and procedural components make up the program. The advantages of such a design tool are that it yields a design specification which is understan9.ab1e to nonprogrammers, and it provides a good pictorial display of module dependencies and the like. The disadvantages of using a graphic-oriented design tool are as follows: 1) it is difficult to modify such graphic design representations 2) there are few standards to enforce design and coding that proceed from these tools 3) there is a lack of formal verification tools available for use with graphic design tools 4) it may be difficult for software developers to go from graphic oriented representation of software design to the actual implementation of the software system specified by the graphic representation.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="90" page="9" column="1">5.2 Requirements Oriented Tools</h2>
          <region class="DoCO:TextChunk" id="91" page="9" column="1">Requirements/Design tools such as SSL [Buckles77J, PSL [Tcich77]' and SADT !Dick77] fit into this category. Such tools concentrate on identifying input f.LDd output data but not on the algorithmic steps necessary to transform the input into the output. At best there are comments describing the steps required for the transfonnation. In short, such tools cover the requirements phase of software development rather than the software design phase. The focus of this paper is on the design phase of software development.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="92" page="9" column="1">5.3 HOS· High Order Specification Language</h2>
          <region class="DoCO:TextChunk" id="93" page="9" column="1">HaS [HamH77J is a design tool often related to "proof of correctness" efforts. When using this design tool, the designer prepares boolean expressions which must remain true throughout some subset of the design. For instance, a designer may specify that some vari- able must remain positive. Since such a design tool does Dot address the central problem of describing a program's procedural steps, it yields little insight into the algorithmic structure of the software system.</region>
          <outsider class="DoCO:TextBox" type="footer" id="94" page="9" column="1">7</outsider>
          <region class="DoCO:FigureBox" id="Fx95">
            <image class="DoCO:Figure" src="62q8.page_009.image_08.png" thmb="62q8.page_009.image_08-thumb.png"/>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="96" page="10" column="1">5.4 Program Design Langnages (PDLs)</h2>
          <region class="DoCO:TextChunk" id="97" page="10" column="1">In order to facilitate the early stages of software development, a large nwnber of design languages have surfaced. Such languages are typically an outgrowth of the original design language POL, proposed by Caine and Gordon [Caine75}. Such design languages can provide the software developer with the capabilities of algorithmic specification, automation, and verification. Moreover, while flowcharts emphasize explicit flow of control, PDLs have a greater emphasis on program structure. In a recent study [Ramsey83], it was suggested that PDLs have the advantages of lower cost and easier maintainability, relative to flow charts and other graphics-based design tools. The study also suggested that the designer's use of a POL encourages more detailed specification of the design than does the use of flow charts. In summary, this study appears to provide a fairly strong case for the use of PDLs over flowcharts for the expression of detailed software designs by the designer. PDLs are the design tool of choice for further investigation. A closer look at PDLs now follows.</region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="98" page="10" column="1">6 Program Design Languages (PDLs)</h1>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="99" page="10" column="1">6.1 PDL. Defined</h2>
          <region class="DoCO:TextChunk" id="100" page="10" column="1">A program design language (PDL) is a tool which uses the vocabulary of a natural language and the overall syntax of a programming language (e.g., Pascal). Thus, a PDL can be thought of as "'stmctured English." We view a PDL as a tool to be used during the detailed design phase of software development independent of the design methodology in use. In short, PDLs should allow for the description of algorithms which are to be implemented in software.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="101" page="10" column="1">6.2 Putting PDLs in Perspective</h2>
          <region class="DoCO:TextChunk" id="103" page="10" column="1"> <xref ref-type="fig" rid="F1" id="102" class="deo:Reference">Figure 1</xref> depicts where PDLs fit in among requirements tools (i.e., SSL, PSL, SADT), very high, high-level languages (VHHLs) such as SETL [Dewar82] and APL [Pakin72J, and traditional high-level programming languages such as Pascal, C, or Ada.</region>
          <outsider class="DoCO:TextBox" type="footer" id="104" page="10" column="1">8</outsider>
          <region class="DoCO:FigureBox" id="Fx105">
            <image class="DoCO:Figure" src="62q8.page_010.image_09.png" thmb="62q8.page_010.image_09-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="106" confidence="possible" page="11" column="1">Requirements Tools</region>
          <region class="unknown" id="107" page="11" column="1">(SSL. PSL.SADT)</region>
          <region class="DoCO:TextChunk" id="108" confidence="possible" page="11" column="1">PDLs</region>
          <region class="DoCO:TextChunk" id="109" confidence="possible" page="11" column="1">Very-High, High-Level Languages</region>
          <region class="unknown" id="110" page="11" column="1">(SEIL. APL)</region>
          <region class="DoCO:TextChunk" id="111" confidence="possible" page="11" column="1">High-Level La.nguages (Pascal, C, Ada)</region>
          <region class="DoCO:FigureBox" id="F1">
            <caption class="deo:Caption" id="112" page="11" column="1">Figure 1: Putting POLs in perspective.</caption>
          </region>
          <region class="DoCO:TextChunk" id="113" page="11" column="1">There are essentially two noteworthy points to make at this time. First, requirements tools do not specify the algorithmic stepB necessary to realize a solution, whereas POLs encourage the specification of such steps. In this sense, PDLs are a level of abBtraction below that of requirements tools such as SSL, PSL, and SAOT. Secondly, while PDLs allow for the specification of design, they do not go so far as to allow for the high-level or very high· level fonnal specification of requirements which would result in a full-scale software system. In the figure above, VHLLs appear to the right of POLs because while they allow for a lower· level of abstraction than do PDLs, they are not at a level of abstraction entirely below that of PDLs, as is the case with high-level languages.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="114" page="11" column="1">6.3 Desired Characteristics of PDLs</h2>
          <region class="DoCO:TextChunk" id="119" page="11" column="1">There are many PDLs in use today, but it is not clear that their use will ensure the overall quality of the resulting system. In this section we outline the desired characteristics of a. POL if it is to enhance the overall qua.lity of the design process. <marker type="block"/> 6.3.1 Functional Characteristics From the functional point of view, there are basically two different types of POLs, semi·formal and fonnal POLs. Semi-formal POLs have a minimal amount of syntactic and semantic constraint; the terms and expressions used are basically determined by the user. In general, such a language is able to stay close to natural language. On the other hand, formal POLs have highly constrained syntax and semantics; the user is restricted to using keywords like READ and WRITE. Some critics of fonnal POLs argue that it is difficult for nonprogrammers to understand such a PDL and that they rest on very precisely defined concepts. These may prove sometimes to be too tightly defined to describe \UlUBual or new<marker type="page" number="12"/><marker type="block"/> situations. Many argue that, while a formal POL is more precise than an informal POL, a formal PDL is also more difficult to learn and use. Nonetheless, we believe that a certain amount of formalism should be supported by the POL. This could include a fixed syntax of keywords that provides the necessary structured constructs, data declarations, and modularity characteristics, as well as a fixed syntax of design constructs used to convey design ideas. The advantages of using formally defined design constructs in the design phase, as opposed to actual code, arf: really three-fold: 1. Design constructs are more easily understood by all involved parties. 2. Criticisms, suggestions, and modifications can be obtained early in the software life cycle. 3. Software size and effort estimation models baaed on a POL version of"a program may be obtainable earlier in the software life cycle than is typically the case.</region>
          <outsider class="DoCO:TextBox" type="footer" id="117" page="11" column="1">9</outsider>
          <region class="DoCO:FigureBox" id="Fx118">
            <image class="DoCO:Figure" src="62q8.page_011.image_10.png" thmb="62q8.page_011.image_10-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="120" confidence="possible" page="12" column="1">The desired functional characteristics of a program design language arc now detailed.</region>
          <region class="DoCO:TextChunk" id="143" page="12" column="1">Promotion of Structured Coding During Implementation The notation used within a PDL should allow one to sta.te program logic and function in a structured and top-down fashion. This will promote the use of structured programming during the implementation of the eventual system. Thw a POL should exhibit a syntax of pseudo-natural language that describes processing features such as: 1. da.ta type specifications (i.e., int, real, ... ) 2. block structures (i.e., Begin ... End) 3. conditionals (i.e., if-then-else) 4. control structures (i.e., Do While, For Next, ... ) 5. formally-defined design constructs (see next section) 6. procedure specifications (i.e., Proc name paramlist) 7. procedure calls (i.e., Call name paramlist) 8. input and output (i.e., Read and Write) 9. e.rror/exception clauses (i.e., On(Cond) Do) <marker type="block"/> Use of Formalized Design Constructs The fundamental difference between a PDL and a high-level programming language lies in the usc of high-level primitives to describe a software aystem. That is, the number of detailed specification points in a PDL-defined software system should be an order of magnitude less than the ultimate software system implemented in some high-level programming language. The advantages of using formally defined constructs during the design phase, as opposed to actual code, were d;scussed earlier. In addition, the notion of executable designs, as provided through the use of formally-defined design constructs, allows a prototype of the system to exist at an early stage in development which reflects the software design decisions that have been made. This in turn can result<marker type="page" number="13"/><marker type="block"/> in feedback to the designer on the consequences of a proposed design. Likewise, the use of such Cormally-defined design constructs could allow users to change requirements early in the software life cycle, before full-scale development proceeds further. In order to reduce the number of specification points by the previously-mentioned "order of magnitude" from that of the eventual implementation, a POL should have a set of formally-defined de5ign COD8trncts. For example, Create_Socket and SendTo..socket might be examples of design primitives :or a network application. Moreover, it should be possible to extend the set oC formally-defined design constructs when it is deemec. that an additional design construct would prove to be beneficial.<marker type="block"/> Programming Language Independence While several re!learchers have promoted the use of programming language-dependent POLs [Boehm-Davis82, Sheffield83, Sammet81), only few have realized the harmful effects of using low-level code during design. The danger associated with the use of a programming language-dependent POL is that there is a ten- dency to be too detailed in the design, with the net result that the PDL description is (at least in some instances) nothing less than detailed code. In short, a PDL should encourage design rather than coding. Hence, we believe that pro{;Tamming language independent PDLs arc essential.<marker type="block"/> Good "Code-tol'l Ability The POL should possess constructs which have a good "code-to" ability. That is, while the POL constructs should allow for program design to be expressed independent of a programming language, they should also lend themselves to be easily coded into m&lt;:JlY high-level programming languagcs. It is the ease with which a POL description is converted into code that makes it particularly suited to representing software design.<marker type="block"/> Promote Reusability A PDL should promote the use of reusable designs and code. Raising the level of abstraction of design constructs is likely to bring about the use of similar design constructs, and hence similar code. One could think about incorporating the use of a macro expansion facility to substitute the code from previous implementations of a given design construct, thereby facilitating reuse oC code.<marker type="block"/> 6.3.2 Support Characteristics There are basically three different areas in which PDLs should support or complement thc other phases of the software life cycle. The use of. a PDL (1) should ensure that the 60ftware documentation for a system comes about in a timely manner, (2) should provide automated support toolS tha.t assist the developer during the development of the system,<marker type="page" number="14"/><marker type="block"/> and (3) should lend itself to early software metric and effort modeling. Each of these three different areas are next discussed in more detail.<marker type="block"/> Timely Documentation The use of a PDL should give rise to an excellent design document to guide the implementation. Such a document can also serve the purpose of software documentation during the debugging and maintenance stages of the life cycle. The PDL should help in the goal that design documents be of high quality and be produced at the appropriate time as opposed to after the system has been fully devcloped.<marker type="block"/> Automated Tool Support The PDL description of a software system should serve several useful purposes, including the following: 1. The description should be machine rea~able so that various tests, including interface consistency, can be automated at the design phase. 2. It should be possible to produce a design graph of the software system indicating the intermodule dependencies and such. 3. It should be possible to produce a table specifying which constructs used in the POL software specification are undefined. 4. It should provide a trace facility which displays the mapping from system requirements to design specifications. 5. An Emulation Tool similar to the one described by [Freedmau80] should be available. This tool should enable a software designer to "walkthrough his design so that the control logic of the design can be verified." However, it should be pointed out that since the "walkthrough" of design "...does not entail the execution of instructions, the emulator has no way of evaluating whether a test condition is true or not. Thus, whenever a Do While or H statement is encountered, the operator must indicate which course of action to take." While it is difficult to fully test a design during a walkthrough, the emulator does provide a meanB of ensuring that sequencing errors are minimized. This is likely to result in a higher level of confidence in the correctness of the design. In addition, the emulator can also provide a "data flow diagram for each emulation." 6. A Language Conversion Tool similar to the one dc~cribed by [Freedman80] should be available to convert automatically as much of the design as possible to code. That is, where possible, the programming language-specific constructs corresponding to the generic design language-construct should bc gcncrated from the PDL version.<marker type="block"/> Early Metric and Model Availability The earlier in the :mftwarc life rydc that accurate software metrics arc available, the marc likely it is that costly rcdcsib'11 and rcim- plementation can be avoided. Hence a. PDL should promote our ability to compute thesc metrics at the design phase.<marker type="page" number="15"/><marker type="block"/> The use of software metrics to develop measures of software quality and reliability have become commonplace in the software engineering community [<xref ref-type="bibr" rid="R13" id="138" class="deo:Reference">Gilb77</xref>, Pcrlis81J. Commonly used software metrics include <xref ref-type="bibr" rid="R15" id="139" class="deo:Reference">Halstead's Software Science measures [Halstead77</xref>]' McCabe's Control Flow Complexity metric v(G) [McCabe76J, and source lines of code. Moreover, DeMarco [DeMarco82J defines several software design metrics that should be computable from a program design language specification. Obtaining accurate estimates of eventual software metric values during the design pha.sc of the software life cycle would be of great economic and managerial benefit. Through the use of a PDL and the metrics available from a PDL software description, one could use existing software estimation models (e.g., [Boehm8l, <xref ref-type="bibr" rid="R30" id="140" class="deo:Reference">Thib83</xref>]) to predid the effort required to develop the given software system. Likewise, one may be able to deduce accurate expansion factors from a PDL specification to its equivalent coded implementation, thereby yielding accurate software size estimates early in the software life cycle. This too would be of great help to the software community as well, since most of the existing software effort estimation models rely upon software size as the major parameter.<marker type="block"/> A representative ~alllple consisting of seveu different program design languages has been surveyed in this study. The seven different program design languages considered are BYRON (lntermetrios), PDL-Caine, SLAN-4 (IBM), PDLfAda (IBM), Ada-PDL (TRW), PDL-Ard~ (UC-Irvine), and ADL (Ford Aerospace). In Appendix B of this paper the interested reader can find an example design specification written in each of the seven PDLs. Below we discuss brieRy each of the PDLs and then evaluate them according to the desired characteristics outlined in the previous section.</region>
          <outsider class="DoCO:TextBox" type="footer" id="123" page="12" column="1">10</outsider>
          <region class="DoCO:FigureBox" id="Fx124">
            <image class="DoCO:Figure" src="62q8.page_012.image_11.png" thmb="62q8.page_012.image_11-thumb.png"/>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="130" page="13" column="1">11</outsider>
          <region class="DoCO:FigureBox" id="Fx131">
            <image class="DoCO:Figure" src="62q8.page_013.image_12.png" thmb="62q8.page_013.image_12-thumb.png"/>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="136" page="14" column="1">12</outsider>
          <region class="DoCO:FigureBox" id="Fx137">
            <image class="DoCO:Figure" src="62q8.page_014.image_13.png" thmb="62q8.page_014.image_13-thumb.png"/>
          </region>
          <region class="unknown" id="142" page="15" column="1">7 PDL Survey</region>
          <region class="unknown" id="144" page="15" column="1">7.1 The PDL. Introduced</region>
          <region class="DoCO:TextChunk" id="145" confidence="possible" page="15" column="1">The seven program design languages surveyed in this paper are discussed briefly below.</region>
          <region class="unknown" id="146" page="15" column="1">7.1.1</region>
          <region class="DoCO:TextChunk" id="164" page="15" column="1">BYRON BYRON [Gordon83J is the program design language used by Intermetrics as part of their Ada Integrated Environment (AlE). In addition to supporting the Ada programming language, BYRON also adds constructs to Ada programs as legal Ada comments which have some meaning. In turn, these comments are used by a BYRON processor to generate design documentation and to perform some design analysis. There are several different BYRON constructs, each of which is prefixed by a . - . The first type of BYRON construct, directives, takes on the form· - KEYWORD TEXT. <marker type="page" number="16"/><marker type="block"/> There are several different BYRON KEYWORDS which address issues of data abstraction, program description, timing requirements, exception handling, and performance analysis. The TEXr part of each BYRON directive is used to detail or describe the given directive more thoroughly. The second type of BYRON construct, flags, take on the form - - -, and are used to denote the scope of BYRON statements. That is, the lines processed by the BYRON processor are those which a.ppear between the two flags. It should be noted that there are also several other characters which can follow the BYRON prefix construct that serve a similar purpose.<marker type="block"/> 7.1.2 PDL-Caine POL is the program design language outlined by Caine and Gordon [Caine75]. This program design language is especially significant in that it was the first to appear in the literature. For brevity, in the remainder of this section we shall refer to POL-Caine as simply "POL". POL was developed for the "production of structured designs in a top-down manner." It allows the designer to specify a complete design - including interface definitions, procedure definitions and calls, data declarations, control blocks, varying level algorithm processing specifications, and error definitions. POL is supported by a processor which takes as input "control information plus designs for procedures" and produces as output a working design document.<marker type="block"/> The language SLAN·4 [Beich83, Beich84.J was developed at IBM as an aid in the specification and design of software systems. "SLAN-4 is a language spanning the complete range from an almost natural language to an almost compilablt~ language. It can be used as a software specification, design, communication, aud dOClllllelltatioll t.ool." [DcichS3, p.aGS] SLAN-4 allows for algebraic and axiomatic specification, generic data types, and modules. The programming constructs supported by SLAN-4, are very similar to those used in high-level programming languages such as Pascal and Ada. That is, all of the basic data types and operations associated with them, operatiom on sets and lists, and control structures from the traditional programming languages are part of the SLAN-4 language. Also, SLAN-4 introduces a semaphore construct as a synchronization tool. In addition to offering constructs for detailed specification, a subset of the SLAN-4 language allows the designer to express software design as well. This sublanguage of SLAN-4 is called "pseudocode" , and contaim control structures for sequential and concurrent processing, as well as assignment and procedure call constructs. In addition, pseudocode supports<marker type="page" number="17"/><marker type="block"/> the assign, assert, and goto constructs. Furthermore, comments may appear anywhere within a design specification. Such comments are started by a "«" and ended by a"»". Thus pseudocode "allows a user of SLAN-4 to start with a specification written in natural language, but in a structured way." Pseudocode is designed to offer "a way of presenting al- gorithm6 independently of the language in which the final program is to be written." Then, as the development of the system progresses, these informal pseudocode specifications can be made more precise by formalizing the infonnal constructs (i.e., comments) by making full use of the SLAN-4 language.<marker type="block"/> 7.1.4 PDL/Ada POL/Ada [Sammet81] is a program design language (based on Ada) which was developed at IBM. The design language includes formal specifications for procedures, control structures, assignment statements, functions, procedures, limited generics, data declarations and data typing, modules (packaging), and comments. A comment starts with a double hyphen (- -) and is terminated by the end of the line. A significant motivating factor for POLlAda is the use of an Ada translator as a design tool. Although the translator CanDot generate code from POL/Ada design specifications, it can perform syntax checking and type checking in parameter lists of invoked procedures. Thus, POL/Ada design specificatioDS are acceptable by an Ada translator. However, abstract functions and predicates written simply as comments would not be accepted by a translator. Thus, a special means of specifying 6uch abstractions was devised. In particular, to combat such difficulties, POLl Ada has a specially-defined predicate CONDITION and a null procedure called THENPART. The figure below illustrates the point. Unacceptable by Ada Translator Acceptable by Ada Translator<marker type="block"/> new satellite detected CONDITION new satellite detected then then -- compute its orbit THENPART; -- compute its orbit endif ; andif; Thus, by using the two previously mentioned constructs, CONDITION and THENPART, the original design notation is acceptable to an Ada translator.<marker type="block"/> 7.1.5 Ada-PDL The progra.m design language Ada-POL [Spoon84j was developed at TRW for recording designs at all levels of the software design/development process. The developers of Ada-PDL<marker type="page" number="18"/><marker type="block"/> state that the two primary objectives of Ada-POL are (a) to provide a more complete and structured POL thUl POL-Caine 60 that more detailed automated analysis is possible, and {b} to address and exploit the introduction of Ada in the dt:velopment of software systems. Ada-POL maintains the flavor of POL-Caine and ..dds new capabilitic:l to support software design by providing additional items such as structured data, hierarchical design structures, d.etailed interface specifications, and inter-module dependencies. While Ada·PDL is based on the programming language Ada, it is not itself Ada. Ada- POL is a combination of formal and informal constructs. The formal constructs of Ada- PDL must be written using specific syntax much like Ada, while the informal constructs are "'almost free of syntactic constraints, allowing nearly all English constructions." Ada-POL offers the designer a. rich set of constructs including conditional and iterative constructs, data defiuition/namir:.g constructs, modularity constructs (e.g. subprograms, packaging, tasking, and modules), and context specification constructs (e.g., import, with, use, and separate) all of which are Ada-based. In addition to these Ada-specific constructs discussed in the previous paragraph, Ada- POL has two other constructs: design narratives and comment constructs. These two constructs place virtually no restrictions or constraints on Ada-POL. The difference between these two constructs lies in the fact that "'if an Ada·PDL keyword begins a line, then that line is identified as part of a more fonnal Ada-POL construct (name-declaring or conditional) that may, itself, allow design narrative following the keyword." In contrast, the second kind of text that may appear in both name-declaring and algorithm constructs is a comment. A comment begins with two hyphens (- -) and includes all of the text until the end of the line is reached. Ada-POL is 6upported by the Ada-POL processor that analyzes input design text to do such things as producing a "variety of reports useful during th(; design phase, deter· mine those aspects of design that are deferred/incomple~e, check inter-module interfaces for consistent use, and maintain and control a database of design library units."<marker type="block"/> 7.1.6 PDL-Arcturus Arcturus [Tadman84, Standish83a] is an Ada-based pr03nmming environment und.er development at the Univ~rs!t.y of California· Irvine. One component of the Arcturus environment is a program design language. The Arcturus progral.J. desib"D. language wes normal Ada syntax forms in which text in braces can be substituted for declarations, expressions, Dames, statements, or types. Some examples of PDL comments follow. while {Interval is non empty} loop</region>
          <outsider class="DoCO:TextBox" type="footer" id="148" page="15" column="1">13</outsider>
          <region class="DoCO:FigureBox" id="Fx149">
            <image class="DoCO:Figure" src="62q8.page_015.image_14.png" thmb="62q8.page_015.image_14-thumb.png"/>
          </region>
          <region class="unknown" id="152" page="16" column="1">7.1.3 SLAN-4</region>
          <outsider class="DoCO:TextBox" type="footer" id="154" page="16" column="1">14</outsider>
          <region class="DoCO:FigureBox" id="Fx155">
            <image class="DoCO:Figure" src="62q8.page_016.image_15.png" thmb="62q8.page_016.image_15-thumb.png"/>
          </region>
          <region class="unknown" id="158" page="17" column="1">if</region>
          <outsider class="DoCO:TextBox" type="footer" id="161" page="17" column="1">15</outsider>
          <region class="DoCO:FigureBox" id="Fx162">
            <image class="DoCO:Figure" src="62q8.page_017.image_16.png" thmb="62q8.page_017.image_16-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="165" confidence="possible" page="18" column="1">raise exception to be defined later};</region>
          <outsider class="DoCO:TextBox" type="footer" id="166" page="18" column="1">16</outsider>
          <region class="DoCO:FigureBox" id="Fx167">
            <image class="DoCO:Figure" src="62q8.page_018.image_17.png" thmb="62q8.page_018.image_17-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="168" confidence="possible" page="19" column="1">{code generator declarations};</region>
          <region class="DoCO:TextChunk" id="169" confidence="possible" page="19" column="1">type integer queue is {a queue of integers};</region>
          <region class="DoCO:TextChunk" id="170" confidence="possible" page="19" column="1">{print list (seqlist)};</region>
          <region class="DoCO:TextChunk" id="171" page="19" column="1">if k = {new satellite} then return {computed orbit}; endif; Procedures, functions, packages, types, etc. with POL comments are defined in a manner similar to Ada. Subprograms and packages containing POL comments can be executed in a manner such that any POL comment except a statement will cause the "break package" to be invoked; thereby halting program execution. In situations where a POL statement is encountered, the break package is invoked, and execution may continue just as if the procedure "break" had been called. In addition to allowing PDL constructs to be included in a program, the Arcturus environment also provides for a "Rapid Prototyping Language." This. language aUows POL comments to be refined by defining macros for each PDL comment. In this case, the POL comment is referred to as e. "calling form." When a calling form is encountered during the execution of a program and no macro is defined for such a POL comment, then the break package, as previously described, is entered. If, however, a calling form is defined, it is executed and "the results of the macro is substituted into the program before execution continues. The result actually replaces the calling form so that each macro is executed and replaced only once during execution." Arcturus also provides a mechanism whereby the calling forms in a program can be replaced without executing the program. An example of a calling form follows. Given the definition of the following macro, macro {print list (seqlist)} return stmtnode is begin return genstmt( "for i in 1.. $seqlist'last loop " " "put(liet(i)); put (' ');" &amp;: "end loop;" &amp;I: • 'newline; , .) ; end; The use of the calling form in a program such as {print list (list)};</region>
          <outsider class="DoCO:TextBox" type="footer" id="172" page="19" column="1">17</outsider>
          <region class="DoCO:FigureBox" id="Fx173">
            <image class="DoCO:Figure" src="62q8.page_019.image_18.png" thmb="62q8.page_019.image_18-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="174" confidence="possible" page="20" column="1">results in the following macro expansion of this PDL comment in the program:</region>
          <region class="unknown" id="175" page="20" column="1">for i in 1 .. list 'last loop put ClistCi»; put C' '); loop;</region>
          <region class="DoCO:TextChunk" id="176" confidence="possible" page="20" column="1">end</region>
          <region class="DoCO:TextChunk" id="185" page="20" column="1">The Arcturus environment also provides many support tools such as pretty-printing, directory listings, and editing tools. <marker type="block"/> ADL is an Ada-based program desil,'ll language developed at Ford Aerospace and Communications (<xref ref-type="bibr" rid="R31" id="179" class="deo:Reference">Thompson83a</xref>, Thompson83bj to provide detailed software design specifications. ADL supports a subset of the Ada programming language in which correct Ada syntax is checked. In particular, ADL supports a large subset of the data types and control structures found in Ada. A rich set of arithmetic and string operators are also supported by ADL. Furthermore, the Ada language constructs - procedures, functions, and packaging are also part of ADL. In order to permit the verification of detailed design interfaces, ADL requires all procedures and function calls, along with passed parameters, to be written in compilable Ada code. ADL provides a TBD ("to be done") construct which allows for the fact that during early design some interfaces may not be specified. In order to alleviate the problems inherent with interface consistency checking in this case, ADL has a special package PACK· AGE_TBD defined, in which types, recorda, and arrays will be defined as TBD as well. Another facility offered by PACKAGE_TBD is the procedure CALL_TBD, which has no parameters and performs no action. CALL_TBD allows the designer to call a procedure without concern for whether or not the interface with that procedure has changed since it was last called. The benefit of using the CALL_TBD procedure call is that it eliminates the necessary recompilation which result when the interfaces change. In addition, variables within procedures can later be declared to be one of the above types once the necessary information becomes known. Another Ada construct which is used in ADL is the comment statement which contains text. The developers of ADL suggest that "ADL comments lshould] be included in structured English format for all detailed processing required of a procedure or function. These comments Ishould] include all processing requirements in sufficient detail to allow independent coding of modules in Ivarious programming languagesj." The NYU interpreter is the only support tool available, and is used to perform syntax and semantic checks of ADL source code.<marker type="page" number="21"/><marker type="block"/> The evaluation of functional characteristics for each of the Program Design Languages included in this survey now follows. A summary of the evaluation of functional characteristics appears as <xref ref-type="fig" rid="F2" id="184" class="deo:Reference">Figure 2</xref> in Appendix A.</region>
          <region class="unknown" id="178" page="20" column="1">7.1.7 ADL</region>
          <outsider class="DoCO:TextBox" type="footer" id="181" page="20" column="1">18</outsider>
          <region class="DoCO:FigureBox" id="Fx182">
            <image class="DoCO:Figure" src="62q8.page_020.image_19.png" thmb="62q8.page_020.image_19-thumb.png"/>
          </region>
          <region class="unknown" id="183" page="21" column="1">7.2 Evaluation of Functional Characteristics</region>
          <region class="DoCO:TextChunk" id="186" confidence="possible" page="21" column="1">7.2.1 Promotion of Structured Coding During Implementation</region>
          <region class="DoCO:TextChunk" id="189" page="21" column="1">Above Average: BYRON, SLAN-4, PDL/Ada, PDL-Arcturus, ADL All of the POLs in this category, with the exception of SLAN-4, are closely tied to the Ada programming language. Hence such program design languages strongly promote structured coding in the same way that Ada supports structured coding. However, it could be tnat some of the Ada-specific detailed constructs which are a part of these POLs may be too difficult, if not impossible, to simulate using structured coding when the implementation language is something other than Ada. For instance, the Ada packaging or tasking construct would be very difficult, if not impossible, to implement if Fortran were the implementation language. The software designs resulting from the designer's use of SLAN-4 may promote the use of structured coding during implementation. The reason for this is that SLAN-4 provides many of the control structures, procedure specifications, and data declarations provided by the traditional high-level languages. However, it should be pointed out that SLAN-4 does allow the use of the "goto" statement which is not a construct which promotes structu,red coding IDijkstra68J. Likewise, SLAN-4 supports concurrency and semaphore constructs which are not generally available in high-level programming languages. <marker type="block"/> Average: Ada·PDL While Ada-POL is bound to the data declarations and module specifications of Ada, it does not support the detailed programming constructs of Ada. As such, it does not strongly promote structured coding during implementation.<marker type="block"/> Below Average: PDL-Caine POL-Caine may do a reasonable job in promoting the use of structured coding during implementation since it provides control flow constructs, procedure specifications, and data declarations, as part of its own language. Moreover, the constructs provided by this program design language are available in any high·level programming language. However, it is never stated that the designer is required to use any part of these structured constructs. Hence, we conclude that the designer is at liberty to design without the usc of structured control flow constructs and the like. Thus, the use of this rOL may not promote structured coding during implemcntation.</region>
          <outsider class="DoCO:TextBox" type="footer" id="190" page="21" column="1">19</outsider>
          <region class="DoCO:FigureBox" id="Fx191">
            <image class="DoCO:Figure" src="62q8.page_021.image_20.png" thmb="62q8.page_021.image_20-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="192" confidence="possible" page="22" column="1">T.2.2 Use of FormaHzed Design Constructs</region>
          <region class="DoCO:TextChunk" id="193" page="22" column="1">Above Average: PDL-Arcturus More so than with any other program design language included in this survey, we found POL-Arcturus to exhibit the capability of allowing formally-defined design constructs to exist. This is not to say that the calling form anno- tation of formally-defined design con:&gt;tructs meets our criterion established in the "Desired Characteristics" section of this paper; it simply allows for, but does not require, such formally defined design constructs to exist. Nonetheless the fact that they have included such a capability in their POL implies that it would require only simple modification of the POL-Arcturus language to require an exact and formal syntax for all design constructs. This modifica.tion will be outlined in the "Future Directions" scction of the paper.</region>
          <region class="DoCO:TextChunk" id="194" confidence="possible" page="22" column="1">Average: BYRON, Ada-PDL While neither BYRON nor Ada-POL provides formaJly- defined design constructs, both provide a means of imerting narrative design text in well- defined locations in a program. Byron supports an algorithm directive construct which can be placed in certain places throughout a program. However, since any text may appear within an instance of an algorithm directive, this implies that it is quite possible to do software implementation during the software design phase of the development. Several examples in the literature describing BYRON were such that the POL description had a number of specification points far less than the corresponding software implementation. But, this certainly may not be the case in. general. Similarly, Ada-POL provides two such COlliltructS, namely design narratives and comments. While the locations in which such constructs can appear is limited, the fact that the text which may appear within either of these constructs is virtually unlimited, leads us to the conclusion that the Ada-POL environment, as it is currently defined, does not have the capability of recognizing or defining formal design constructs.</region>
          <region class="DoCO:TextChunk" id="195" page="22" column="1">Below Average: PDL-Caine, SLAN·4, PDL/ Ada, ADL When designing software systems with any of these program design languages, there is no notion of formally defined design constructs. The only trace of a design construct is ill the use of comments describing the processing which a given segment of code is to achieve. However, the fact that such comments can appear anywhere within the program and are written simply using English text, certainly does not demonstrate any formal notion of a design construct.</region>
          <outsider class="DoCO:TextBox" type="footer" id="196" page="22" column="1">20</outsider>
          <region class="DoCO:FigureBox" id="Fx197">
            <image class="DoCO:Figure" src="62q8.page_022.image_21.png" thmb="62q8.page_022.image_21-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="198" confidence="possible" page="23" column="1">7.2.3 Programming Language Independence</region>
          <region class="DoCO:TextChunk" id="200" page="23" column="1">Independent: PDL-Caine, SLAN-4, Ada-PDL Both PDL-Caine and SLAN-4 are programming l&lt;.:.nguage-independent program design languages. However, in the case of SLAN-4 we conclude that since the syntax and structures it supports are so unconven- "i;ional, it does not have all of the advantages of programming language-dependent POLs as previously described. On the other hand, clearly POL-Caine possesses the advantages previously described. While Ada-POL is dependent upon the data declaration and module specification constructs of the Ada programming language, it does not support the use of detailed Ada coding constructs. It is this independence from Ada-specific coding c.onstructs which allows it to be classified as a proc;:ramming language independent POL. <marker type="block"/> Dependent: BYRON, PDL/ Ada, PDL-Ardurus, ADL These program desib'l1 languages arc very much tied to the Ada programming lauguage. The fact that these program design languages possess this strong programming language dependence surely implies that they have the shortcomings associated with programming language-dependent POLs that were described earlier.</region>
          <region class="DoCO:TextChunk" id="201" confidence="possible" page="23" column="1">7.2.4. "Code To" Ability</region>
          <region class="DoCO:TextChunk" id="203" page="23" column="1">Above Average: PDL-Caine, Ada~PDL Since POL-Caine and Ada-POL are not tied to a particular programming language, there is a good possibility that these program design languages will yield a good "code to" ability at the implementation level. However, the lack of formally defined design constructs implies that it is quite poss:Qle for ambiguous design descriptions to exist. Such a design specification would clearly not possess a good code-to ability. Likewise. the fact that Ada-POL is not closely tied to any particular programming language and that it supports a rich set of structured constructs, implies that it will possess a good "code to" ability. <marker type="block"/> Average: PDL~Arcturus POL-Arcturus has the possibility of possessing a very good "code_to" ability, provided liberal use of "calling forms" exists. This is because such constructs provide a clear, concise description to be mapped into an implementation. However, care must be taken when making such a statement. For, if minimal use is made of</region>
          <outsider class="DoCO:TextBox" type="footer" id="204" page="23" column="1">21</outsider>
          <region class="DoCO:FigureBox" id="Fx205">
            <image class="DoCO:Figure" src="62q8.page_023.image_22.png" thmb="62q8.page_023.image_22-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="206" confidence="possible" page="24" column="1">Ada constructs, PDL-Arcturus may</region>
          <region class="DoCO:TextChunk" id="207" confidence="possible" page="24" column="1">calling forms and excessive use made of possess a very good code-~o abili~y.</region>
          <region class="DoCO:TextChunk" id="208" page="24" column="1">Below Average: BYRON, SLAN-4, PDL/Ada, ADL Since each of ~hese program design languages is supported by a rich and heal~hy set of operators, it is unlikely tha~ a good code-to ability would exist if the program design specification is to be implemented in a language other than the one supported by the given program design language. The point here is that it may be very difficult to take constructs such as Ada Packages and Tasking from the design specification, and implement such constructs in some other language.</region>
          <region class="DoCO:TextChunk" id="209" confidence="possible" page="24" column="1">7.2.5 Promote Reusability</region>
          <region class="DoCO:TextChunk" id="218" page="24" column="1">Above Average: PDL-Arcturus POL-Arcturus has the most promise in terms of its ability to promote software reusability. This is due to the fact that the calling form macro facility allows one to associate coded implementation with a d~sign construct. Moreover, it provides a means by which it can determine whether or not such an exact match exists between a POL comment currently being used, and a POL comment defined and used in the past. This decreases the likelihood of having multiple formally-defined design constructs which perform the same function. Also, providing an on-line document describing the exact syntax of existing fonnally-defined design constructs, and their associated semantics, would also promote reusability. In short, POL-Arcturus has a strong potential to promote reusability. In fact, the developers of POL-Arcturus cite a case in which a 62 % software reuse factor was realized in the construction of a prototype system [Standish83bJ. <marker type="block"/> Average: ADL The only notion of reusability addressed in ADL is in the "data dictionary packages" which allow a designer to make reference to data in the dictionary without redefining the data types, range of values, etc. within each package. However, due to the lack of formally-defined design constructs in AD L, it is not possible to automate the reuse of design constructs and their respective implementations.<marker type="block"/> Below Average: BYRON, PDL-Caine, SLAN-4, PDL/ Ada, Ada-PDL None of these program design languages provide a mechanism by which a designer can formally define design constructs. This suggests that they do not promote the reuse of code. That is, given a high-level design construct and an implementation for this construct, one should be able to associate the original implementation of the design construct with later uses of the same design construct. However, the lack of formally-defined design constructs could<marker type="page" number="25"/><marker type="block"/> result in a situation whereby several different design descriptiow exist for the same design construct, thereby making it very difficult to detect that reuse is even possible.<marker type="block"/> The evaluation of support characteristics for each of the program design languages included in this survey follows. A summary of the evaluation of support characteristics appears as <xref ref-type="fig" rid="F3" id="217" class="deo:Reference">Figure 3</xref> in Appendix A.</region>
          <outsider class="DoCO:TextBox" type="footer" id="213" page="24" column="1">22</outsider>
          <region class="DoCO:FigureBox" id="Fx214">
            <image class="DoCO:Figure" src="62q8.page_024.image_23.png" thmb="62q8.page_024.image_23-thumb.png"/>
          </region>
          <region class="unknown" id="216" page="25" column="1">7.3 Evaluation of Support CharaeteriBticB</region>
          <region class="DoCO:TextChunk" id="219" confidence="possible" page="25" column="1">1.3.1 Timely Documentation</region>
          <region class="DoCO:TextChunk" id="225" page="25" column="1">Above Average: PDL~Arcturu8 PDL-Arcturus support!! the use of formally- defined design constructs (calling forms) at a high-level of abstraction. This implies that this design language is likely to yield timely and meaningful documentation. However, care must be taken not to overemphasize this aspect of the Arcturus environment. It is quite possible that a designer may choose to use a minimal number of calling forms, in which case the design specification produced is very close to actual Ada code. Clearly such a design specification would not yield very timely or meaningful documentation. <marker type="block"/> Average: BYRON, Ada-PDL Both of these design languages provide a means of formally defining locations in a program where narrative design constructs can exist. Thus, it is possible for these design languages to yield reasonable documentation. This is because the use of design narratives is encouraged at certain locations in a program. However, the fact that the degree of detail specified within each of the design constructs is unlimited, implies that the design specifications written in either of these design languages may be nothing less than complete programs written in Ada. Surely if this is the case, the use of BYRON or Ada-PDL will not result in reasonable documentation.<marker type="block"/> Below Average: PDL-Caine, SLAN·4, PDL/Ada, ADL It is unlikely that the use of anyone of these design languagcs would yield timely or meaningful documentation. None of these design languages provide a means of formally defining design constructs; program comments are the only means by which design can be cOllvcyed. Thus, it is likely (or design specifications written in these design languages to be nothing less than complete programs written in the low level primitives provided by the givcn dcsign language. Thus, we conclude that the degree to which these program design languages yield timely and usable documentation is a function of the level at which the specification is written. Hence, since each of these design languages supports low level primitive operations, complemented<marker type="page" number="26"/><marker type="block"/> by the fact that they do not support formally-defined design constructs, implies that such design languages will yield inadequate documentation.</region>
          <outsider class="DoCO:TextBox" type="footer" id="223" page="25" column="1">23</outsider>
          <region class="DoCO:FigureBox" id="Fx224">
            <image class="DoCO:Figure" src="62q8.page_025.image_24.png" thmb="62q8.page_025.image_24-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="226" confidence="possible" page="26" column="1">7.3.2 Automated Tool Support</region>
          <region class="DoCO:TextChunk" id="232" page="26" column="1">Above Average: BYRON, Ada·PDL Both BYRON and Ada-PDL are supported by a very healthy set of tools to aid in the design of software systems. A brief discussion of the tools available for each of the design languages now follows. BYRON is supported by five different tools (I) The _&lt;I. Analyzer" is a tool which checks BYRON source code for correct Ada syntax and semantics (optional). Hit does not detect any errors it stores an internal representation of the source code in a program library. The analyzer also checks for the proper use of BYRON constructs. (2) The &lt;l.Call Tree" is a tool which displays the functions and procedures that a specific program unit calls. In addition, this tool also displays the functions and procedures which call the specific program unit. (3) The "DataDiet" is a tool which displays information such as declaration of types, subprograms, packages, tasks, entries, or any combination, in a selected set of program units. (4) The "DepTab" is a tool which displays the dependencies among program units. It generates a report which shows the units which would have to be recompiled if a given unit is recompiled. (5) The &lt;l.UserMan" is a tool which creates a report describing the external interface to a subprogram or package in the program library. This report also displays all of the infonnation necessary for someone who wishes to use a predefined subprogram or package. Ada-PDL has a processor capable of producing several different reports. There are basically two different types of reports which can be generated by the processor: "Pretty Printed Listings" and reports derived from the structure of the design. A summary of the reports availablc by Ada-PDL now follows. (1) The "Cross Refercnce Listing" report contains entries for all names that are referenced in the specified design unit, along with their declared type, the line on which each name was declared, and the number of the line(s) which reference the name. (2) The &lt;l.Name Directory Listing" report contains the names declared in a specified design unit, along with the location of their declarations. In addition a set of attributes for each name, including its type, is provided. When using Ada-POL, the designer also has the option of producing a simple source listing in which an exact copy of the input stream is produced; or a "Pretty Printer Listing," <marker type="page" number="27"/><marker type="block"/> in which keywords are highlighted and structure indentation takes place. In addition to the above, the following reports are currently under development: Module Dependency Reports, Subprogram Call and Tasking Entry Call Hierarchy Reports, and a Parameter Checking Report to validate the correctness of module interfaces.<marker type="block"/> Average: PDL-Arcturu8 POL-Arcturus is supported by a reasonable sct of tools to aid in the designing of software systems. In general, the same tools which process normal Ada. programs are available for use when expressing design in POL-Arcturus. Such tools include syntax analysis, pretty program listings, execution-time performance monitoring via a color graphics monitor, and a template-driven (syntax-directed) Ada text editor to aid in the stepwise refinement of programs.<marker type="block"/> Below Average: PDL-Caine, SLAN-4, PDL/ Ada, ADL The program design langua.ges in this category provide a minimal amount of tool support. A closer look at the tool support available with each of these dcsign languages follows. There is a limited amount of tool support when working in the POL-Caine environment. In particular, the POL processor yields a document consisting of the following five things: a title page a table of contents the body of the design in pretty printed form a "reference tree" showing how design segment references are nested a cross-reference listing indica.ting the page and line number where each design segment is referenced. There is really no mention of any tool support in either one of the two references on SLAN-4 available to us for this survey IBeich83, Beich841. The only form of tool support in existence seems to be an interface verification facility and a syntax/semantic checker. The same is true for POL!Ada. There is 8. limited amount of tool support available whcn dcsigning with ADL. The first tool allows items that have been defined to be stored in a data dictionary. In turn, modules which later reference previously· defined items can simply reference the data in the dictionary without redefining the data types or range of values. Secondly, the NYU Ada Interpreter is used to check ADL syntax and semantics. While no mention is made of the fact that it is feasible to produce a deferred development report of the TBD constructs in an ADL specification, certainly such a report would be noteworthy.</region>
          <outsider class="DoCO:TextBox" type="footer" id="228" page="26" column="1">24</outsider>
          <region class="DoCO:FigureBox" id="Fx229">
            <image class="DoCO:Figure" src="62q8.page_026.image_25.png" thmb="62q8.page_026.image_25-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="233" confidence="possible" page="27" column="1">7.S.S Early Metric and Model A vBilability</region>
          <outsider class="DoCO:TextBox" type="footer" id="234" page="27" column="1">25</outsider>
          <region class="DoCO:FigureBox" id="Fx235">
            <image class="DoCO:Figure" src="62q8.page_027.image_26.png" thmb="62q8.page_027.image_26-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="238" page="28" column="1">Above Average: PDL-Arcturus Provided that extensive reuse of design calling forms a.re used, timely and accurate software metric estimates could be made based on a POL-ArcturuJ3 design specification. However, if extensive reuse of calling forms does not take place, then POL-ArctU1"US would have to be classified along with the other Ada specific program design languages below. <marker type="block"/> Average: BYRON, SLAN-4., PDL/Ada, ADL All of these program design languages allow one to accurately estimate the software metrics of systems to be developed in Ada. However, the fact that these design languages allow for detailed Ada constructs to be used, implies that accurate software mctrics will come about too late in the development process to be of much value. Furthermore, the usefulness of metric estimates based on an Ada-specific design language could prove to be of minimal value in cases where a language other than Ada is used for implementation. It should be pointed out that the developers of POL/Ada [Sammet81] state that the software design metrics "may be closely related to those for the [implementation] language. Thus if one is counting source lines of code or software science metrics, this can be done automatically on the design statements. This then measures the design, not the implementation resulting from it." The developers fail to note the fact that the correlation between software metrics computed at the design phase and those computed on the resulting imple- menta.tion is very important. A poor correlation between software metrics computed during the design phase, as compared to those metric values obtained from the resulting implementation, is not very helpful. If such a scenario is realized, one can be lead to erroneous conclusions concerning the reliability of the system or testing effort required of the actual system.<marker type="block"/> Below Average: PDL-Caine, Ada-PDL Due to the fact that both of these POLs are supported by control structures, procedure calls, and data declarations, it may be possible to derive reasonable estimates for some software metrics based on the design specifications they yield. However, the level at which the design specification is written will determine how early in the development process these metric estimates are available, as well as the accuracy of such estimates. Thus, since there is DO formally-defined syntax for detailed constructs of these PDLs, we conclude that it is unreasonable to consider software metric modeling when using such program design languages.</region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="239" page="28" column="1">8 Perspectives for the Future</h1>
        <region class="DoCO:TextChunk" id="243" page="28" column="1">There is a widespread dem~lild for safe, verifiable, and reliable software to be delivered in a timely manner. It has been a goal of this paper to demonstrate that program design <marker type="page" number="29"/><marker type="block"/> languages can make a valuable contribution toward this goal. This survey has discwsed the positive and negative aspects of existing program design language. While no single program design language emerged as the POL of choice, many positive POL attributes have been revealed through this survey. We believe it is the union of all the positive attributes from the various POLs, complemented by some additional features, which will give rise to a class of PDLs that will emerge as the superior software design tools. A discussion of such a POL Environment follows.</region>
        <outsider class="DoCO:TextBox" type="footer" id="241" page="28" column="1">26</outsider>
        <region class="DoCO:FigureBox" id="Fx242">
          <image class="DoCO:Figure" src="62q8.page_028.image_27.png" thmb="62q8.page_028.image_27-thumb.png"/>
        </region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="244" page="29" column="1">8.1 The PDL Environment</h2>
          <region class="DoCO:TextChunk" id="246" page="29" column="1">The ideal program design language environment would be one which supported software design assumiug a number of implementation languages. That is, for purposes of module, data, and control Bow specification, we believe such constructs should be programming language-dependent (as is the case with Ada-POL, assuming the implementation language is Ada). H this were not the case, module interface verification, accurate metric estimates, and the promotion of structured coding during implementation would be difficult for any universal POL to achieve. However, we do not believe a POL Environment should support the low level, detailed constructs of any particular programming language. Suppose, for purposes of illwtration, that the implementation languages supported in a given development environment include Pascal, C, and Ada. In such a case the POL Environment is depicted in <xref ref-type="fig" rid="F4" id="245" class="deo:Reference">Figure 4</xref>..</region>
          <outsider class="DoCO:TextBox" type="footer" id="247" page="29" column="1">27</outsider>
          <region class="DoCO:FigureBox" id="Fx248">
            <image class="DoCO:Figure" src="62q8.page_029.image_28.png" thmb="62q8.page_029.image_28-thumb.png"/>
          </region>
          <region class="unknown" id="249" page="30" column="1">PDL</region>
          <region class="DoCO:TextChunk" id="250" confidence="possible" page="30" column="1">Environment</region>
          <region class="unknown" id="251" page="30" column="1">I "-</region>
          <region class="DoCO:TextChunk" id="252" confidence="possible" page="30" column="1">POL-Pascal POL-Ada/ POL-Generic</region>
          <region class="unknown" id="253" page="30" column="1">---- PDL-C I</region>
          <region class="DoCO:FigureBox" id="F4">
            <caption class="deo:Caption" id="254" page="30" column="1">Figure 4:</caption>
          </region>
          <region class="DoCO:TextChunk" id="255" confidence="possible" page="30" column="1">The PDL Environment In this the POL Environment should support the module, data, and control flow speci· fications available in each of these languages. Then, on command, the designer could invoke a particular instance of the POL Environment based on the implementation language to be used. In such a case only the module, data, and control How constructs supported by the specified design language would be permitted during this instance of the POL Environment. In situations where the implementation language is unknown or unsupported in the POL Environment at the time of software design, a generic POL instance should be supported. Such a POL instance should enable the specification of modules, data, and control How constructs in a language independent, but fonnal manner.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="256" page="30" column="1">8.2 DeBign CODBtructs</h2>
          <region class="DoCO:TextChunk" id="257" confidence="possible" page="30" column="1">Most POLs do not support formally-defined design constructs. Thus, it is impossible to enforce a "design rather than code" philosophy during the design phase when using such PQLs. In terms of supporting formally defined design constructs, clearly PDL-Arcturu5 stands out as the POL of choice. Likewise, the formally-defined constructs of PDL-ArctUI"Wl promote the reuse of code resultiug from the implementation of such constructs. However, the fact that it allows only Ada-specific low level constructs to be used during implementation, implies that POL-Arcturus only supports reuse of Ada code. Thus, a more general notion of formally-defined design constructs would be of great value. We promote the use of formally defined design constructs in which the language is supported in the environment. However, using the method of POL-Arcturus calling forms is thought to be quite adequate and generalizable beyond the Ada domam. There arc basically three key issues to be researched with respect to the development of design constructs. These three issues are the abstraction, the interface, and the transfor- mation of design constructs.</region>
          <region class="DoCO:TextChunk" id="258" confidence="possible" page="30" column="1">Abstraction The key to success in a POL Environment is to develop a way of ab- str"actly specifying the basic operations and objects while still promoting the desirable characteristics of the POL. In situations where formally-defined design constructs exist and are</region>
          <outsider class="DoCO:TextBox" type="footer" id="259" page="30" column="1">28</outsider>
          <region class="DoCO:FigureBox" id="Fx260">
            <image class="DoCO:Figure" src="62q8.page_030.image_29.png" thmb="62q8.page_030.image_29-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="266" page="31" column="1">accompanied by an implementation, the abstract specification of the design construct is not a problem, namely it is simply the formally-defined calling form. However, in situations where no formally-defined design construct exists for the given design construct, a mechanism of describing design, while avoiding environmental specifics such as programming languages, operating systems, and machine is needed. The description of such constructs, at an appropriate level, warrants further consideration. <marker type="block"/> Interface Another aspect of design constructs is the means by which the designer interfaces with formally-defined design constructs. The interface must provide an on-line mechanism to enable, on demand, a specification of the functionality of the construct, as well as the environmental conditions necessary for the construct to function properly. Likewise, such an interface must be accompanied by a mechanism to catalog, retrieve, and update formally-defined design construct libraries. We believe that the UNIX (tm of Bell Laboratories) "include" facility can be exploited to build a reasonable interface. Fo:, example, suppose a group of network oriented formally- defined design constructs have been developed in the C programming language and stored in the file "netfddc.C". Then, in order to access these formally defined design construct definitions during the design of a network application using PDL-C, the designer would simply put the statement "include &lt;netfddc.C&gt;" in the PDL-C design specification in order to legally make use of the fonnally defined design constructs which appear in this file. The location of a programming language-dependent library of formally defined design constructs in the PDL environment is depicted in <xref ref-type="fig" rid="F5" id="262" class="deo:Reference">Figure 5</xref>. It may also be possible to use formally-defined design constructs written in language X when using PDL-Y in the PDL Environment. That is, it may be possible to exploit existing software technologies to use a formally-defined design construct written in one language, while designing with a PDL based in a different language. Several researchers [Jones85, Tichy80, DeRemer76] have argued that structuring a large collection of modules to form a system is a distinctly different activity from that of constructing the individual modules. Correspondingly, they argue that distinctly different languages should be used for the two activities. An advantage of using a separate language for describing module interconnectiv- ity is that the modules themselves may more easily be coded in different languages. Systems such as MIL [DeRemer76]. INTERCOL [Tichy79, Tichy80], and Matchmaker lJones85] could each provide the capabilities for composing a large system from modules written in several different programming languages through the use of a module interconnection language. Such module interconnection techniques should be given further consideration in order to allow formally-defined design constructs written in one language to be used by a person designing in another language. The on-line mechanism could be to print the header and comment lines from implemented formally-defined design constructs based on an input generic command. For ex-<marker type="page" number="32"/><marker type="block"/> ample, the generic command "Socket" might result in the headers and comments from the functions Create_Socket, Bind..8ocket, SendTo..8ocket, and RccFr..5ocket (assuming such functions are defined in the library of formally·defined design constructs) to appear in re- sponse to this generic inquiry.</region>
          <outsider class="DoCO:TextBox" type="footer" id="264" page="31" column="1">29</outsider>
          <region class="DoCO:FigureBox" id="Fx265">
            <image class="DoCO:Figure" src="62q8.page_031.image_30.png" thmb="62q8.page_031.image_30-thumb.png"/>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="267" page="32" column="1">30</outsider>
          <region class="DoCO:FigureBox" id="Fx268">
            <image class="DoCO:Figure" src="62q8.page_032.image_31.png" thmb="62q8.page_032.image_31-thumb.png"/>
          </region>
          <region class="unknown" id="269" page="33" column="1">PDL</region>
          <region class="DoCO:TextChunk" id="270" confidence="possible" page="33" column="1">Environment</region>
          <region class="DoCO:TextChunk" id="271" confidence="possible" page="33" column="1">POL-Pascal PDL-C POL-Ada POL-Generic</region>
          <region class="DoCO:TextChunk" id="272" confidence="possible" page="33" column="1">netfddc.C</region>
          <region class="unknown" id="273" page="33" column="1">,.-/ I I -....--... I I I I I / I I \ radarfddc. Ada. unixextfddc. C</region>
          <region class="DoCO:TextChunk" id="274" confidence="possible" page="33" column="1">(Formally Defined Design Construct Library)</region>
          <region class="DoCO:FigureBox" id="F6">
            <caption class="deo:Caption" id="275" page="33" column="1">Figure 6:</caption>
          </region>
          <region class="DoCO:TextChunk" id="276" confidence="possible" page="33" column="1">The Detailed POL Environment</region>
          <region class="DoCO:TextChunk" id="281" page="33" column="1">Transformation The transforming of high-level, abstract design specifications into efficient and correct implementations of formally- defined design constructs in various high- levellanguagcs is of paramount importance for the development of an effective PDL Envi· ronment. Furthermore, the higher the level of abstraction, the more difficult it is to provide an effective transfonnation to code. <marker type="block"/> 8.3 Tool Support Both BYRON and Ada-PDL provide a healthy set of design support tools. In addition to the tools available in these environments, several other tools should be supported by the POL Environment. Surely an emulation tool, as described in section 6.3 would be beneficial. Second, a mechaI;lism to produce a design graph detailing module interconnectedness should be part of the tool environment. Another tool worth' exploring would be one that allowed for the expansion of £onnally defined design constructs to be turned "on" or "off". This is because managers may not be interested in detailed implementation, but merely in the abstract design specification of a software system. In such cases the formally defined design construct expansion mechanism can be turned off, thereby allowing the designer to "hide" the low level design details. On the other hand, when doing design reviews, one would want to turn the expansion facility on to enable the fully developed design to be revealed for review. Third, the whole notion of TBD constructs available in ADL should be made available in the PDL Environment. Such a construct could be exploited to generate<marker type="page" number="34"/><marker type="block"/> a "'Deferred Developmcnt" report of TBD constructs in a PDL specific:at.ion. Finally, a mcchanism to show the mapping from requirements specifications to design specifications is needed to ewure the traceability of requirements to design.</region>
          <outsider class="DoCO:TextBox" type="footer" id="279" page="33" column="1">31</outsider>
          <region class="DoCO:FigureBox" id="Fx280">
            <image class="DoCO:Figure" src="62q8.page_033.image_32.png" thmb="62q8.page_033.image_32-thumb.png"/>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="282" page="34" column="1">8.4 Software Metric Availability and Modeling</h2>
          <region class="DoCO:TextChunk" id="284" page="34" column="1">The difficulty of obtaining early and accurate software metric estimates through PDL specifications was emphasized earlier. For the PDLs included in this survey, <xref ref-type="fig" rid="F6" id="283" class="deo:Reference">Figure 6</xref> depicts this difficulty.</region>
          <outsider class="DoCO:TextBox" type="footer" id="285" page="34" column="1">32</outsider>
          <region class="DoCO:FigureBox" id="Fx286">
            <image class="DoCO:Figure" src="62q8.page_034.image_33.png" thmb="62q8.page_034.image_33-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="287" confidence="possible" page="35" column="1">Low-Level POL (e.g .• ADL)</region>
          <region class="DoCO:TextChunk" id="288" confidence="possible" page="35" column="1">------- accurate metric estimatee. but late in the</region>
          <region class="unknown" id="289" page="35" column="1">software life cycle</region>
          <region class="DoCO:TextChunk" id="290" confidence="possible" page="35" column="1">------- desired level of POL (e.g., none exist)</region>
          <region class="DoCO:TextChunk" id="291" confidence="possible" page="35" column="1">early in the software life cycle. but</region>
          <region class="unknown" id="292" page="35" column="1">inaccurate metric estimates</region>
          <region class="DoCO:TextChunk" id="293" confidence="possible" page="35" column="1">High- eve I POL (e.g .• POL-Caine)</region>
          <region class="DoCO:FigureBox" id="F6">
            <caption class="deo:Caption" id="294" page="35" column="1">Figure 6: Difficulty in obtaining usable software Metrics based on PDLs.</caption>
          </region>
          <region class="DoCO:TextChunk" id="295" page="35" column="1">The difficulty in obtaining usable metric estimates with Low-Level PDLs (e.g., ADL) is that while they yield very accurate metric estimates, such estimates are available only upon completion of the coding phase. Thus, such late metric estimates do not point out problems in design until the end of the coding phase. Clearly this is too late in the software life cycle to really make 8. significant difference in tenns of whether or not to redesign. On the other hand, high level POLs (e.g., POL-Caine) have the problem of yielding inaccurate software metric estimates based upon the design specifications which they yield. That is, it is difficult to accurately predict the characteristics of the corresponding implementation, and hence software metrics, based upon informal narrative text. Perhaps liberal use of formally-defined design construct calling forms in the proposed POL Environment will enable early and accurate software metric estimates to take place. Another area of the P DL Environment to be exploited with respect to software metrics, is monitoring the completeness of software design by observing the DC (design completeness) ratio defined as</region>
          <region class="DoCO:TextChunk" id="296" confidence="possible" page="35" column="1">Metric Estimate Based on POL Envir. Design Specification</region>
          <region class="unknown" id="297" page="35" column="1">DC =</region>
          <region class="DoCO:TextChunk" id="298" confidence="possible" page="35" column="1">Actual Metric Value Based on Implementation</region>
          <region class="unknown" id="299" page="35" column="1">In</region>
          <region class="DoCO:TextChunk" id="306" page="35" column="1">Thus, if DC equals 1, the design specification was very complete. A13 DC decreases from 1, the design specification does not accurately represent the resulting implementation. the latter csse, clearly this is a trigger to management that incomplete software design specifications are being developed. In addition, if the ratio DC( V(g) ), that is the DC ratio <marker type="page" number="36"/><marker type="block"/> for McCabe's V(G) metric IMcCabe76J, is not close to 1, this could result very grave consequences if management has based testing effort distribution on the V(G} estimate based on the design specification.<marker type="block"/> 8.5 Shifted Distribution of Life Cycle Effort The use of a PDL Environment, and its associated tools, will most likely result in more effort devoted to the requirements and design phases of the software life cycle. This is due to the more thorough assessment of requirements and formalisms associated with the usc of a PDL Environment. However, we suspect that the correct wage of the PDL Environment will decrease the coding, testing, and maintenance effort, and hence the overall effort required to develop a software system, while increasing the overall quality of delivered software. Surely this would be a well received improvement in the software development process.<marker type="block"/> 8.6 Summary Among the current software design tools, program design languages are certainly the most advanced and most useful. Such a design tool has been demonstrated to be supportive during several phases of the software life cycle in addition to the design phase. AJ:, such, program design languages are likely to become a standard tool in the integrated software engineering environments of the future.</region>
          <outsider class="DoCO:TextBox" type="footer" id="301" page="35" column="1">33</outsider>
          <region class="DoCO:FigureBox" id="Fx302">
            <image class="DoCO:Figure" src="62q8.page_035.image_34.png" thmb="62q8.page_035.image_34-thumb.png"/>
          </region>
          <region class="unknown" id="303" page="36" column="1">in</region>
          <outsider class="DoCO:TextBox" type="footer" id="307" page="36" column="1">34</outsider>
          <region class="DoCO:FigureBox" id="Fx308">
            <image class="DoCO:Figure" src="62q8.page_036.image_35.png" thmb="62q8.page_036.image_35-thumb.png"/>
          </region>
          <region class="unknown" id="309" page="37" column="1">Summary of PDL Evaluation</region>
          <region class="unknown" id="310" page="37" column="1">POL Name Structured Coding</region>
          <region class="unknown" id="311" page="37" column="1">AA</region>
          <region class="DoCO:TextChunk" id="312" confidence="possible" page="37" column="1">BA</region>
          <region class="unknown" id="313" page="37" column="1">AA AA</region>
          <region class="DoCO:TextChunk" id="314" confidence="possible" page="37" column="1">AV</region>
          <region class="unknown" id="315" page="37" column="1">BYRON POL-CEline SLAN-4 POL/Ada Ada-POL POL-Arcturus</region>
          <region class="DoCO:TextChunk" id="316" confidence="possible" page="37" column="1">ADL</region>
          <region class="unknown" id="317" page="37" column="1">AA AA</region>
          <region class="DoCO:FigureBox" id="F2">
            <caption class="deo:Caption" id="318" confidence="possible" page="37" column="1">Figure 2: Summary of Functional Characteristic Evaluation.</caption>
          </region>
          <region class="unknown" id="319" page="37" column="1">POL Name Timely</region>
          <region class="DoCO:TextChunk" id="320" confidence="possible" page="37" column="1">AV BA</region>
          <region class="unknown" id="321" page="37" column="1">B:.</region>
          <region class="DoCO:TextChunk" id="322" confidence="possible" page="37" column="1">BA AV</region>
          <region class="unknown" id="323" page="37" column="1">BYRON POL-Caine SLAN-4 POL/Ada Ada-POL POL-Arcturus</region>
          <region class="unknown" id="324" page="37" column="1">AA</region>
          <region class="DoCO:TextChunk" id="325" confidence="possible" page="37" column="1">ADL BA</region>
          <region class="DoCO:FigureBox" id="F3">
            <caption class="deo:Caption" id="326" confidence="possible" page="37" column="1">Figure 3: Summary of Support Characteristic: Evaluation.</caption>
          </region>
          <region class="DoCO:TextChunk" id="327" confidence="possible" page="37" column="1">KEY</region>
          <region class="unknown" id="328" page="37" column="1">AA</region>
          <region class="DoCO:TextChunk" id="329" confidence="possible" page="37" column="1">AV BA DE IN</region>
          <region class="DoCO:FigureBox" id="Fx330">
            <image class="DoCO:Figure" src="62q8.page_037.image_36.png" thmb="62q8.page_037.image_36-thumb.png"/>
          </region>
          <region class="unknown" id="331" page="37" column="2">Appendix A</region>
          <region class="unknown" id="332" page="37" column="2">Constructs Prog.Lang.</region>
          <region class="DoCO:TextChunk" id="333" confidence="possible" page="37" column="2">AV BA BA BA AV</region>
          <region class="unknown" id="334" page="37" column="2">AA</region>
          <region class="DoCO:TextChunk" id="335" confidence="possible" page="37" column="2">BA</region>
          <region class="unknown" id="336" page="37" column="2">Tool Support Metric Availability</region>
          <region class="unknown" id="337" page="37" column="2">AA</region>
          <region class="DoCO:TextChunk" id="338" confidence="possible" page="37" column="2">BA BA BA</region>
          <region class="unknown" id="339" page="37" column="2">AA</region>
          <region class="DoCO:TextChunk" id="340" confidence="possible" page="37" column="2">AV BA</region>
          <region class="unknown" id="341" page="37" column="2">Above Average Rating Average Rating Below Average Rating Prog. Lang. DEpendent POL Prog. Lang. POL</region>
          <region class="unknown" id="342" page="37" column="3">Code To Reuse</region>
          <region class="unknown" id="343" page="37" column="3">AA</region>
          <region class="DoCO:TextChunk" id="344" confidence="possible" page="37" column="3">DE IN IN DE</region>
          <region class="unknown" id="345" page="37" column="3">III</region>
          <region class="unknown" id="346" page="37" column="3">AA</region>
          <region class="unknown" id="347" page="37" column="3">AA</region>
          <region class="DoCO:TextChunk" id="348" confidence="possible" page="37" column="3">DE DE</region>
          <region class="DoCO:TextChunk" id="349" confidence="possible" page="37" column="3">BA BA BA BA BA BA BA BA AV BA AV</region>
          <region class="DoCO:TextChunk" id="350" confidence="possible" page="37" column="3">AV BA AV AV BA</region>
          <region class="unknown" id="351" page="37" column="3">AA</region>
          <region class="DoCO:TextChunk" id="352" confidence="possible" page="37" column="3">AV</region>
          <outsider class="DoCO:TextBox" type="footer" id="353" page="37" column="3">36</outsider>
          <region class="DoCO:TextChunk" id="354" confidence="possible" page="38" column="1">Appendix B</region>
          <region class="unknown" id="355" page="38" column="1">Program Design Language Examples</region>
          <region class="unknown" id="356" page="38" column="1">--I --I</region>
          <region class="DoCO:TextChunk" id="357" confidence="possible" page="38" column="1">find patterns in text Regular expression to search for)</region>
          <region class="DoCO:TextChunk" id="358" confidence="possible" page="38" column="1">procedure FIND( SearchPat: in string --I Modifies: StdOutput --I N/A: Errors, Raises</region>
          <region class="unknown" id="359" page="38" column="1">is</region>
          <region class="unknown" id="360" page="38" column="1">--I</region>
          <region class="DoCO:TextChunk" id="361" confidence="possible" page="38" column="1">Overvie\U' --I Find is a program used to scan standard input, searching for --I a pattern. The PatMat pattern matching package is used for --I pattern matching functions, Streams is used for I/O, and UIM --I is used to provide the standard user interface. - - 1 Requires --I SearcbPat must be a valid regular expression pattern.</region>
          <region class="DoCO:TextChunk" id="362" confidence="possible" page="38" column="1">type maxLine is range 1 .. 266;</region>
          <region class="DoCO:TextChunk" id="363" confidence="possible" page="38" column="1">Lin: string(MaxLine() Pat: pattern; M, string(MaxLine);</region>
          <region class="unknown" id="364" page="38" column="1">--I --I --I</region>
          <region class="DoCO:TextChunk" id="365" confidence="possible" page="38" column="1">a line from the text file a pattern text which matched Pat in Lin</region>
          <region class="DoCO:TextChunk" id="366" confidence="possible" page="38" column="1">--I -Algorithm</region>
          <region class="unknown" id="367" page="38" column="1">--I --I --I --I --I</region>
          <region class="DoCO:TextChunk" id="368" confidence="possible" page="38" column="1">If Se&amp;rchPat is empty then explain ueage and exit Convert search string into a pattern For each line in stdinput Display the line if it matches the pattern Exit</region>
          <region class="DoCO:TextChunk" id="369" confidence="possible" page="38" column="1">begin null; end Find;</region>
          <region class="DoCO:FigureBox" id="F7A">
            <caption class="deo:Caption" id="370" page="38" column="1">Figure 7A: BYRON High-Level Desigu Description to search for a pattern in text.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="371" page="38" column="1">36</outsider>
          <region class="DoCO:FigureBox" id="Fx372">
            <image class="DoCO:Figure" src="62q8.page_038.image_37.png" thmb="62q8.page_038.image_37-thumb.png"/>
          </region>
          <region class="unknown" id="373" page="39" column="1">--I --I</region>
          <region class="DoCO:TextChunk" id="374" confidence="possible" page="39" column="1">find patterns in text Regular expression to search for)</region>
          <region class="DoCO:TextChunk" id="375" confidence="possible" page="39" column="1">procedure FIND( SearchPat: in string --I Modifies: StdOutput --I N/A: Errors. Raises</region>
          <region class="unknown" id="376" page="39" column="1">is</region>
          <region class="unknown" id="377" page="39" column="1">--I --I --I --I --I --I --J</region>
          <region class="DoCO:TextChunk" id="378" confidence="possible" page="39" column="1">Overview Find is a program used to scan standard input. searching for a pattern. The PatMat pattern matching package is used for pattern matching functions. Streams is used for 110. and UIU is used to provide the standard user interface. Requires SearchPat must be a valid regular expression pattern.</region>
          <region class="DoCO:TextChunk" id="379" confidence="possible" page="39" column="1">type maxLine is range 1 .. 266;</region>
          <region class="DoCO:TextChunk" id="380" confidence="possible" page="39" column="1">Lin: string(NaxLine() Pat: pattern; M, string(MaxLine);</region>
          <region class="unknown" id="381" page="39" column="1">--I --I --I</region>
          <region class="DoCO:TextChunk" id="382" confidence="possible" page="39" column="1">a line from the text file a pattern text ~hich matched Pat in Lin</region>
          <region class="DoCO:TextChunk" id="383" confidence="possible" page="39" column="1">begin</region>
          <region class="unknown" id="384" page="39" column="1">--J If SearchPat is empty then sxplain usage and exit if searchpat = .... then PutLine(ErrOutput, "Usags: FIND pattern"); return; endif; --I Convert search string into a pattern Pat := MakePat(ArgV(l»; --I For each line in stdinput loop Lin := GetLine(Stdlnput); --I read a line --[ Display the line if it matches the pattern if MatchPat(Lin. Pat) then PutLine(StdOutput, Lin); endif; end loop; exception when StreamEmpty =) --I Raised when input exhausted --I Close the output file</region>
          <outsider class="DoCO:TextBox" type="footer" id="385" page="39" column="1">end Find;</outsider>
          <region class="DoCO:FigureBox" id="F713">
            <caption class="deo:Caption" id="386" confidence="possible" page="39" column="1">Figure 713: BYRON Low·Levd D{'~:.gu Descripliull ~o ~,·:~i't:h for a pa.ttern in text.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="387" page="39" column="1">37</outsider>
          <outsider class="DoCO:TextBox" type="footer" id="388" page="39" column="1">-'</outsider>
          <region class="DoCO:FigureBox" id="Fx389">
            <image class="DoCO:Figure" src="62q8.page_039.image_38.png" thmb="62q8.page_039.image_38-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="390" confidence="possible" page="40" column="1">PUSH "SOE" (START OF EXPRESSION) ONTO OPERATOR STACK PROCESS OPERAND DO WHILE NEXT TOKEN IS AN OPERATOR DO WHILE OPERATOR IS NOT SAME AS OPERATOR ON TOP OF OPERATOR / STACK AND ITS PRECEDENCE IS LESS THAN OR EQUAL TO I PRECEDENCE OF OPERATOR ON THE TOP OF THE OPERATOR STACK BUILD TOP NODE POP OPERATOR STACK ENDDO IF NEW OPERATOR IS S~IE AS TOP OPERATOR ON OPERATOR STACK INCREMENT OPERAND COUNT IN TOP OF OPERATOR STACK BY ONE</region>
          <region class="unknown" id="391" page="40" column="1">ELSE</region>
          <region class="unknown" id="392" page="40" column="1">2</region>
          <region class="DoCO:TextChunk" id="393" confidence="possible" page="40" column="1">PUSH NEW OPERATOR AND OPERAND COUNT OF ONTO OPERATOR STACK ErWIF PROCESS OPERAND</region>
          <region class="unknown" id="394" page="40" column="1">ENDDO</region>
          <region class="DoCO:TextChunk" id="395" confidence="possible" page="40" column="1">DO WHILE TOP OF OPERATOR STACK IS NOT "SOE" BUILD TOP NODE POP OPERATOR STACK</region>
          <region class="unknown" id="396" page="40" column="1">ENDOO</region>
          <region class="DoCO:TextChunk" id="397" confidence="possible" page="40" column="1">POP OPERATOR STACK (TOP OF OPERAND STACK CONTAINS TOP NODE IN EXPRESSION)</region>
          <region class="DoCO:FigureBox" id="F8">
            <caption class="deo:Caption" id="398" page="40" column="1">Figure 8: POL-Caine Design Description to Process an Expression.</caption>
          </region>
          <region class="DoCO:TextChunk" id="399" confidence="possible" page="40" column="1">g.:lt : module 1l.terface n : parameter(re~d) Posint, pos, buffer import(write). last. store: import(read). endinterface</region>
          <region class="DoCO:TextChunk" id="400" confidence="possible" page="40" column="1">last + 1</region>
          <region class="unknown" id="401" page="40" column="1">specification pre-get true post-get pos' = n and buffer' = store(n) exceptions: if n&gt;last ; pos' = I n = 0 : pos' = 1 endif endspecification eJidmodule get</region>
          <region class="DoCO:FigureBox" id="F9">
            <caption class="deo:Caption" id="402" page="40" column="1">Figure 9: SLAN-4 Design Specification to get charact.ers into a file.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="403" page="40" column="1">38</outsider>
          <region class="DoCO:FigureBox" id="Fx404">
            <image class="DoCO:Figure" src="62q8.page_040.image_39.png" thmb="62q8.page_040.image_39-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="405" confidence="possible" page="41" column="1">type index is range 0 .. 1023; type vector is array (index range &lt;» of value;</region>
          <region class="unknown" id="406" page="41" column="1">-- [ sort the target array into ascending order ] procedure singsort (target : in out vector) is pivot : value; type extent is record bot. top : index; end record; active. smaller. larger : extent; package ext_stk is new stack_facility (extent); use ext_stk; unsorted : stack; begin -- initialize the unsorted stack to contain the entire extent of -- the target array; while (unsorted) loop get_top (unsorted. active); [ repeatedly whittle the active extent down to an appropriate size, segregating elements between pairs of subextents and saving the smaller subextents on the unsorted stack ] while condition the active extent contains more than 10 elements or the active extent starts with the first element of the target array loop --[ sort three elements in the active extent of the target array (namely, the two boundary elements and the midpoint element) into ascending order, making the middleman the pivot value] (target, active, pivot); [ segregate the elements in the active extent of the target array according to whether they are greater than or less than the pivot value. and divide the active extent into a pair of nonoverlapping contiguous subextents. one smaller and one larger in size ] segregate_and_divide (target, active, pivot, smaller, larger); put_top (unsorted. smaller); active := larger; end loop; siftsort the active extent of the target array; end loop; end singsort;</region>
          <region class="DoCO:FigureBox" id="F10">
            <caption class="deo:Caption" id="407" page="41" column="1">Figure 10: POL/Ada Design Specification to sort a vector.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="408" page="41" column="1">39</outsider>
          <region class="DoCO:FigureBox" id="Fx409">
            <image class="DoCO:Figure" src="62q8.page_041.image_40.png" thmb="62q8.page_041.image_40-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="410" confidence="possible" page="42" column="1">PACKAGE Bank_Account IS</region>
          <region class="DoCO:TextChunk" id="411" confidence="possible" page="42" column="1">PROCEDURE Open_Account(Id : OUT Integer) PROCEDURE Make_Deposit(Id : IN Integer; Money : IN Money_Type) PROCEDURE Make_Withdra~al(Id : IN Integer; Money : OUT Money_Type) PROCEDURE Close-Account(Id : IN Integer; Money : OUT Money_Type)</region>
          <region class="DoCO:TextChunk" id="412" confidence="possible" page="42" column="1">Account_Closed : EXCEPTION Overdrawn : EXCEPTION</region>
          <region class="DoCO:TextChunk" id="413" confidence="possible" page="42" column="1">PACKAGE BODY Bank_Account IS</region>
          <region class="DoCO:TextChunk" id="414" confidence="possible" page="42" column="1">--the following type and object definitions describe the variables</region>
          <region class="DoCO:TextChunk" id="415" confidence="possible" page="42" column="1">name of account mailing address character format of account number running total of funds in the account</region>
          <region class="DoCO:TextChunk" id="416" confidence="possible" page="42" column="1">TYPE Account_Info_Type IS RECORD Name: String(1 .. 30) Address: String(1 .. 60) Account_Number: String(1 .. 8) Current_Balance : Money_Type END RECORD</region>
          <region class="DoCO:TextChunk" id="417" confidence="possible" page="42" column="1">PROCEDURE Open_Account (Id OUT Integer) IS SEPARATE PROCEDURE Make_Deposit (Id IN Integer; Money : IN Money_Type) IS SEPARATE PROCEDURE Make_Withdrawal (Id IN Integer; Money OUT Money_Type) IS SEPARATE PROCEDURE Close_Account (Id ; IN Integer; Money : OUT Money_Type) IS SEPARATE END Bank_Account</region>
          <outsider class="DoCO:TextBox" type="footer" id="418" page="42" column="1">40</outsider>
          <region class="DoCO:FigureBox" id="Fx419">
            <image class="DoCO:Figure" src="62q8.page_042.image_41.png" thmb="62q8.page_042.image_41-thumb.png"/>
          </region>
          <outsider class="DoCO:TextBox" type="header" id="420" page="43" column="1">SEPARATE (B~_Account) PROCEDURE Open_Account (Id OUT Integer) IS BEGIN get new Id number -- the next empty slot in the array initialize all fields of the new account (Id) record</outsider>
          <region class="unknown" id="421" page="43" column="1">END Open_Account</region>
          <region class="DoCO:TextChunk" id="422" confidence="possible" page="43" column="1">SEPARATE (B~_Account) PROCEDURE Make_Depoeit(Id : IN Integer; Money : IN Money_Type)</region>
          <region class="unknown" id="423" page="43" column="1">BEGIN</region>
          <region class="DoCO:TextChunk" id="424" confidence="possible" page="43" column="1">add Money to TRW_Credit_Union_Share_Draft_Info(Id).Current_Balance END Make_Deposit</region>
          <region class="DoCO:TextChunk" id="425" confidence="possible" page="43" column="1">SEPARATE (Bank_Account) PROCEDURE Close_Account(Id IN Integer; Money Out Money_Type)</region>
          <region class="unknown" id="426" page="43" column="1">IS</region>
          <region class="DoCO:TextChunk" id="427" confidence="possible" page="43" column="1">BEGIN indicate that the account is closed to future transactions IF TRW_Credit_Union_Share_Draft_Info (Id).Current_Balance ) 0.00 THEN return Money to the customer ENDIF END Close_Account</region>
          <region class="DoCO:TextChunk" id="428" confidence="possible" page="43" column="1">--design text for an application making use of</region>
          <region class="DoCO:TextChunk" id="429" confidence="possible" page="43" column="1">IMPORT Bank_Account PROCEDURE Daily_Transaction</region>
          <region class="unknown" id="430" page="43" column="1">IS</region>
          <region class="DoCO:TextChunk" id="431" confidence="possible" page="43" column="1">Cash_In_Hand : Noney_Type My_Id : CONSTANT Integer is top secret</region>
          <region class="DoCO:TextChunk" id="432" confidence="possible" page="43" column="1">BEGIN</region>
          <region class="DoCO:TextChunk" id="433" confidence="possible" page="43" column="1">Make_Deposit (My_Id, Paycheck_Amount) Nake_Withdra~al (My_Id. 2 • Paycheck_Amount)</region>
          <region class="DoCO:TextChunk" id="434" confidence="possible" page="43" column="1">EXCEPTIDN WHEN Account_Closed =) print "account closed" on teller screen WHEN Overdrawn =) print "nice try, but you don't have enough funds to cover the withdrawal"</region>
          <region class="DoCO:TextChunk" id="435" confidence="possible" page="43" column="1">END Daily_Tranaaction</region>
          <region class="DoCO:FigureBox" id="F11">
            <caption class="deo:Caption" id="436" page="43" column="1">Figure 11: Ada-PDL Design Specification for Bank Account Application.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="437" page="43" column="1">41</outsider>
          <region class="DoCO:FigureBox" id="Fx438">
            <image class="DoCO:Figure" src="62q8.page_043.image_42.png" thmb="62q8.page_043.image_42-thumb.png"/>
          </region>
          <outsider class="DoCO:TextBox" type="header" id="439" page="44" column="1">function Binary_Search-Design(K: in {Key}; T: in {Table}) return Integer is {Left Boundary}; --Integer := T'First - 1; {Right Boundary}; --Integer := T'Last + 1; {Mid Point}; --Integer; begin {Initialize Mid Point and Left and Right Interval Boundariee};</outsider>
          <region class="unknown" id="440" page="44" column="1">while {Interva.l is non empty} loop if K = {The Key at the ({mid point}) in Table (T)} then return {mid point}; elseif K &gt; {The Key a.t the ({midpoint}) in Table (Tn then {Search the Right Ha.lf Interval}; else {Search the Left Half Interva.l}; end if ; {Compute new mid point}; end loop; return {A va.lue to indica.te Key (K) was not in Ta.ble (T)}; end Binary_Search_Design;</region>
          <region class="DoCO:FigureBox" id="F12">
            <caption class="deo:Caption" id="441" page="44" column="1">Figure 12: POL-Arcturus Design Specification for Binary Search.</caption>
          </region>
          <region class="DoCO:TextChunk" id="442" confidence="possible" page="44" column="1">package STACK is</region>
          <region class="DoCO:TextChunk" id="443" confidence="possible" page="44" column="1">--specification</region>
          <region class="DoCO:TextChunk" id="444" confidence="possible" page="44" column="1">procedure PUSH ( %: INTEGER) function POP return INTEGER;</region>
          <region class="DoCO:TextChunk" id="445" confidence="possible" page="44" column="1">end STACK;</region>
          <region class="DoCO:TextChunk" id="446" confidence="possible" page="44" column="1">--body</region>
          <region class="DoCO:TextChunk" id="447" confidence="possible" page="44" column="1">package body STACK is MAX: constant:= 100 S: array (1. .KAX) of INTEGER; TOP: INTEGER range 0</region>
          <region class="unknown" id="448" page="44" column="1">.. MAX: cO;</region>
          <region class="DoCO:TextChunk" id="449" confidence="possible" page="44" column="1">procedure PUSS (X: INTEGER) is begin TOP:= TOP +</region>
          <region class="unknown" id="450" page="44" column="1">1; S (rOp):= X,</region>
          <region class="DoCO:TextChunk" id="451" confidence="possible" page="44" column="1">end PUSH;</region>
          <region class="unknown" id="452" page="44" column="1">function POP return INTEGER is begin TOP:= TOP - 1; return S (TOP + 1); end POP;</region>
          <outsider class="DoCO:TextBox" type="footer" id="453" page="44" column="1">end STACK;</outsider>
          <region class="DoCO:FigureBox" id="F13A">
            <caption class="deo:Caption" id="454" page="44" column="1">Figure 13A: ADL Design Specification for Stack.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="455" page="44" column="1">42</outsider>
          <region class="DoCO:FigureBox" id="Fx456">
            <image class="DoCO:Figure" src="62q8.page_044.image_43.png" thmb="62q8.page_044.image_43-thumb.png"/>
          </region>
          <region class="DoCO:TextChunk" id="457" confidence="possible" page="45" column="1">procedure EMVPRC -- process Element Msg Values (GP_ELSET_COUNT in out INTEGER) is ARGl, ARG2. ARG3. ARG4. ARG6. AROO : TYPE_TBD;</region>
          <region class="DoCO:TextChunk" id="458" confidence="possible" page="45" column="1">-- ADD GP Element set</region>
          <region class="DoCO:TextChunk" id="459" confidence="possible" page="45" column="1">procedure EMVADD (ARGl : in TYPE_TBD; ARG2 : out TYPE_TBD) is begin null; end ElofVADD;</region>
          <region class="DoCO:TextChunk" id="460" confidence="possible" page="45" column="1">-- Update GP Element set</region>
          <region class="DoCO:TextChunk" id="461" confidence="possible" page="45" column="1">procedure EMVUPD (ARG3 : in TYPE_TBD; ARG4 : out TYPE_TBD) is begin null; end ENVUPD;</region>
          <region class="DoCO:TextChunk" id="462" confidence="possible" page="45" column="1">-- Delete GP Element set</region>
          <region class="DoCO:TextChunk" id="463" confidence="possible" page="45" column="1">procedure EMVDEL (ARG6 : in TYPE_TBDi ARGB : out TYPE_TBD) is begin null; end EMVDEL;</region>
          <region class="DoCO:TextChunk" id="464" confidence="possible" page="45" column="1">begin -- select the case which applies case 1 : Add GP element Bet</region>
          <region class="unknown" id="465" page="45" column="1">EMIIADD (ARG1. ARG2);</region>
          <region class="DoCO:TextChunk" id="466" confidence="possible" page="45" column="1">case 2 : Update GP element set</region>
          <region class="unknown" id="467" page="45" column="1">EMVUPD (ARG3. ARG4);</region>
          <region class="DoCO:TextChunk" id="468" confidence="possible" page="45" column="1">-- case 3 : Delete OP element set EMVDEL (ARG6. AROO); end case;</region>
          <region class="unknown" id="469" page="45" column="1">-- GP_ELSET_CDUNT = GP_ELSET_CDUNT - 1</region>
          <region class="DoCO:TextChunk" id="470" confidence="possible" page="45" column="1">end EMVPRC;</region>
          <region class="DoCO:FigureBox" id="F13B">
            <caption class="deo:Caption" id="471" page="45" column="1">Figure 13B: ADL Design Specification for Maintaining Message Processing.</caption>
          </region>
          <outsider class="DoCO:TextBox" type="footer" id="472" page="45" column="1">43</outsider>
          <region class="DoCO:FigureBox" id="Fx473">
            <image class="DoCO:Figure" src="62q8.page_045.image_44.png" thmb="62q8.page_045.image_44-thumb.png"/>
          </region>
        </section>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="474" confidence="possible" page="46" column="1">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="475" confidence="possible" page="46" column="1">[Beichter83] F. Beichter, O. Herzog, and H. Petzs..:h, "SLAN-4: A !f'.nguage for the specification and design of large software systems," IBM J. Res. Develop., vol. 27, Nov. 1983. jBeichter84J F. Beichter, O. Herzog, and H. P.::tzsch, "SLAN-4- A software specification and</ref>
          <ref class="deo:BibliographicReference" id="476" confidence="possible" page="46" column="1">design language," IEEE Trans. on Software Engineering, vol. 8E·1O, March 1984.</ref>
          <ref class="deo:BibliographicReference" id="477" confidence="possible" page="46" column="1">IBeizer84] B. Beizer, Softwzce System Testing and Quality Assurance, Van Nostrand Reinhold, New York, 1984.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="478" confidence="possible" page="46" column="1">[Beregi84j W. Beregi, "Architecture prototyping in the software engineering environment," IBM Systems Journal, 23(1), January, 1984, 4·18.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="479" confidence="possible" page="46" column="1">[BoehmS!] B. Boehm, Engineering Economks, Englewood Cliffs, NJ: Prentice Hall, 198!.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="480" confidence="possible" page="46" column="1">[Boehm-Davis82J D. Boehm-Davis, S. Sheppard, and J. Bailey, "'An empirical evaluation of language-tailored PDLs," Proc. of Human Factors Society 1982, 984-988.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="481" confidence="possible" page="46" column="1">[Bracon83] G. Bracon, "Practical impact of an integrated workbench on the quality assur- ance of embedded software," Proc. ESAjESTEC Software Engineering Seminar, Noordwijk, Oct. 1983.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="482" confidence="possible" page="46" column="1">[Buckles77J B. Buckles, "'Fonnal module specification," Proceedings 1977 Annual Conference</ref>
          <ref class="deo:BibliographicReference" id="483" confidence="possible" page="46" column="1">of the ACM, New York, 1977.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="484" confidence="possible" page="46" column="1">[DeRemer761 F. DeRemer and H. Kron, vs. programming in the small," IEEE Trans. (.:J. Software Engineering, vol. 8E-2, June, 1976, 80-86. (Dcwar82] R. Dewar, E. Schonberg, and J. Schwartz, "High-level programming - an intro·</ref>
          <ref class="deo:BibliographicReference" id="485" confidence="possible" page="46" column="1">duction to the programming l'cLlguage SETL," New York: Couraut w::Ititute of Mathematical Scicnces, July 1982.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="486" confidence="possible" page="46" column="1">[Dick77] M. Dickover, C. McGowan, and D. Ross, "Software design u::ling SADT," Proceedings 1977 Annual Conference of the ACM, 125-133.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="487" confidence="possible" page="46" column="1">[Dijkstra68] E. Dijkstra, "Go to statcmcnt considered harmful,"CACM, vll(3) (March 1968), 147-148.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="488" confidence="possible" page="46" column="1">[Freedman80] M. Freeman, "Tools for the Efficicnt Design of in Software Engineering (H. Freeman and P. Lewis, Eds.), Academic Press, New York (1980), 111-119.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="489" confidence="possible" page="46" column="1">[Caine75] S. H. Caine and E. K. Gordon, "PDL - A tooi for software design," Proc. AFIPS Conference, vol. 44 (1975), 271-276.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="490" confidence="possible" page="46" column="1">[DeMarco82j T. DcMarco, Cor..trolling Software Projects, NY: YC'urdcn Press, 1982.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="491" confidence="possible" page="46" column="1">[Gilb77] T. Gilb, Software Metrics. Cambridge, MA: Winthrop Publishers, 1977.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="494" confidence="possible" page="47" column="1">[Gordon83] Gordon, "BYRON program development language," Journal of Pascal and Ada, June 1983.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="495" confidence="possible" page="47" column="1">[Halstead77] M. Halstea.d, Elements 01 Software Science. New York: Elsevier North-Holland, 1977.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="496" confidence="possible" page="47" column="1">[Hamil71J M. Hamilton and S. Zeldin, "Higber Order Software - a methodology for defining software,"IEEE Trane. on Software Engineering, July 1979, 387-40l.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="497" confidence="possible" page="47" column="1">[Jack75] M. Jackson, Principles of Program Design, Academic Press, Inc., New York (1975).</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="498" confidence="possible" page="47" column="1">[Jones85] M. Jones, R. Rashid, and M. Tbompson, "Matchmaker: an interactive specification language for distributed processing," Conf. Rec. 12th ACM Symp. on Prin. of Programming Languages, New Orleans, LA, Jan. 1985, 225-235.</ref>
          <ref class="deo:BibliographicReference" id="499" confidence="possible" page="47" column="1">\Kitch83] B. Kitcbenham, "Tbe use of software metrics to assess software production meth- ods,"13th IntI. Sym. on Fault-Tolerant Computing, Milan, Italy, 1983.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="500" confidence="possible" page="47" column="1">[McCabe761 T. McCabe, "A complexity measure,"IEEE Trans. on Software Engineering, vo1(SE-2), No. 12 (Dec. 1976), 308-320.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="501" confidence="possible" page="47" column="1">[Mend82] K. S. Mendis, "Quantifying software qualitY,"Quality Progress, 18-22, MAY 1982.</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="502" confidence="possible" page="47" column="1">[Nassi73) I. Nassi and B. Shneiderman, "Flowchart Techniques for structured program- ming,"SIGPLAN Notices, ACM, August, 1973.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="503" confidence="possible" page="47" column="1">[Pakin72J S. Pakin, APL/360 Reference Manual, Chicago: SRA, 1972. \pamas72J D. Pamas, "On the criteria to be used in decomposing systems into mod- ul","CACM 15(2), 1053-1058, De&lt;. 1972.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="504" confidence="possible" page="47" column="1">[Parnas79] D. Parnas, "Designing software for ease of extension and contraction,"IEEE Trans. of Software Enpneering, SE-5(2), 128-138, March 1978.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="505" confidence="possible" page="47" column="1">[Pedis81] A. Pedis, F. Sayward, and M. Shaw (Eds), Software Metrics. Cambridge, MA.: MIT Press, 1981. (Potier] D. Potier, J. Albin, R. Ferreol, and A. Bilodeau, "Experimenting with computer software complexity and reliabilitY,"unpublished paper.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="506" confidence="possible" page="47" column="1">[Ramsey83] H. Ramsey, M. Atwood, and J. Van Doren, "Flowcharts versus program design languages: an experimental comparison,"CACM 26(6), 445-449, June 1983. ISammet81] J. Sammet, D. Waugh, and R. Reiter, "POL/Ada - A design language based on Ada,"Proceedings of ACM Annual Conference, (November, 1981), 217-229.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="507" confidence="possible" page="47" column="1">[Spoon84] B. Spoon, "PDL user's manual,"Distributed Limited TRW Technical Report, September, 1984.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="508" confidence="possible" page="47" column="1">[Standish83] T. Standish, "Interactive Ada in the arctl1I'W environment," Ada Letters, III, 1, (July-Augu,t 1983), 23-35.</ref>
          <ref class="deo:BibliographicReference" id="511" confidence="possible" page="48" column="1">IStay76! J. Stay, "HIPO and integrated program design,"IBM Systems Journal, 15(2), 1976,</ref>
          <ref class="deo:BibliographicReference" id="512" confidence="possible" page="48" column="1">143-154.</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="513" confidence="possible" page="48" column="1">[Taylor84] F. Taylor, "The arcturus programming environment program design and rapid prototyping language,"Department of Information and Computer Science Technical Report, University of California - Irvine, January, 1984.</ref>
          <ref class="deo:BibliographicReference" id="514" confidence="possible" page="48" column="1">ITichy79] W. Tichy, "Software development based on module interconnection," Proceedings of 4th International Conf. on Software Engineering. Munich, Germany: IEEE, 1979, 29-41.</ref>
          <ref class="deo:BibliographicReference" id="515" confidence="possible" page="48" column="1">~ichy80] W. Tichy, "Software development control based on system structure description," PhD thesis, Carnegie-Mellon University, Department of Computer Science, 1980.</ref>
          <ref rid="R29" class="deo:BibliographicReference" id="516" confidence="possible" page="48" column="1">[Teich77] D. Teicherow and E. Hershey, "PSLjPSA: a computer aided technique for structured documentation and analysis of information processing systems,"IEEE Trans. on Software Engineering, Jan. 1977, 34-40.</ref>
          <ref rid="R30" class="deo:BibliographicReference" id="517" confidence="possible" page="48" column="1">[Thib83] S. Thebaut, "The $aturation effect in large-scale software development: Its impact and control,"Ph.D. Thesis, Dept. of Computer Science, Purdue University, May, 1983.</ref>
          <ref rid="R31" class="deo:BibliographicReference" id="518" confidence="possible" page="48" column="1">[Thompson83a] C. Thompson, "SPADOC Ada design language,"CSO Technology Development Division, Technical Note TDTN-2, Ford Aerospace and Communications, November, 1983. IThompson83bj C. Thompson, "Ada design language (ADL) user's manual," CSO Technology Development Division, Technical Note SPADOC 4A, Ford Aerospace and Communications, October, 1983.</ref>
          <ref rid="R32" class="deo:BibliographicReference" id="519" confidence="possible" page="48" column="1">[Vick84] C. Vick, "A software engineering environment," C. R. Vick and C. V. Ramamoorthy (eds.), Handbook of Software Engineering, Van Nostrand Reinhold, New York, 1984. IWang84j A. Wang, "The estimation of software size and effort: an approach based on the evolution of software metrics,"Ph.D. Thel:iis, Dept. of Computer Science, Purdue University, August, 1984.</ref>
          <ref rid="R33" class="deo:BibliographicReference" id="520" confidence="possible" page="48" column="1">[Williams84] R. Williams, "Management of software development," C. R. Vick and C. V. Ramarnoorthy (eds.), Handbook of Software Engineering, Van Nostrand Reinhold, New York, 1984. IZoln082] J. Zolnowski and P. Ting, "An insider's survey on $oftware development,"Proceedings of the 6th International Conf. on Software Engineering. Tokyo, Japan:IEEE, 1982, 178-189.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="footer" id="492" page="46" column="1">44</outsider>
        <region class="DoCO:FigureBox" id="Fx493">
          <image class="DoCO:Figure" src="62q8.page_046.image_45.png" thmb="62q8.page_046.image_45-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="509" page="47" column="1">45</outsider>
        <region class="DoCO:FigureBox" id="Fx510">
          <image class="DoCO:Figure" src="62q8.page_047.image_46.png" thmb="62q8.page_047.image_46-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="521" page="48" column="1">46</outsider>
        <region class="DoCO:FigureBox" id="Fx522">
          <image class="DoCO:Figure" src="62q8.page_048.image_47.png" thmb="62q8.page_048.image_47-thumb.png"/>
        </region>
      </section>
    </body>
  </article>
</pdfx>
