<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>096aa94bd3327d6cf6b533bd4af1fb67e7347f6b910d87235c078fc0d408446a</job>
    <base_name>62f8</base_name>
    <doi>http://dx.doi.org/10.1109/ms.2004.1293067</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">design</outsider>
      <region class="unknown" id="2">Editor: Martin Fowler I T h o u g h t Wo r k s</region>
      <title-group>
        <article-title class="DoCO:Title" id="3">MDA: Revenge of the Modelers or UML Utopia?</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="4">Dave Thomas</name>
        </contrib>
      </contrib-group>
      <region class="DoCO:FigureBox" id="Fx5">
        <image class="DoCO:Figure" src="62f8.page_001.image_01.png" thmb="62f8.page_001.image_01-thumb.png"/>
      </region>
      <abstract class="DoCO:Abstract" id="6" confidence="possible">he OMG’s Model Driven Architecture partial abstractions of the product, used to T that (www.omg.org/mda) ing fort model to model-driven build transformations. programs agile is from an development ambitious 1 models I believe us- ef- is ecutable should specification highlight know specification important were about truly the aspects is product. an executable, oxymoron—if that The the it term engineer would ex- the an effective software development prac- actually be “the thing.” Otherwise, it would tice, but I have concerns about the proposed merely model “the thing,” which is by defini- MDA. I agree with others—such as Martin tion partial and incomplete. Fowler, Steve Cook, Scott Ambler, and Jean Bézivin (see the “Related Work” sidebar)— UML: The good, the bad, that we should neither naively ac- and the ugly cept nor cavalierly reject MDA Software engineering welcomed the OMG’s without the broader software com- intervention to stop the silliness in notation, munity first appropriately examin- just as other, more mature disciplines have wel- ing and evaluating it. comed similar interventions. The good in UML is that it provides a common and useful visual On modeling notation for describing many of the software Modeling is at the core of many artifacts used in modern OO analysis, design, disciplines, but it is especially im- and development. 2 Tools also help generate portant in engineering because it fa- code templates and reverse-generate diagrams cilitates communication and con- from code. Recent additions such as Way- structs complex things from smaller pointer (www.jaczone.com/product/overview) parts. Since at least Simula 67 (one of the first and CodaGen (www.codagen.com) provide object-oriented languages), many have viewed rule-based support for software processes and software development as the development and code generation. The industry uses UML per- refinement of models. Models facilitate the un- vasively to document and discuss software de- derstanding, simulation, and emulation of the signs. Additionally, tools that will one day artifacts under development. Depending on have the usability and productivity of real model paradigms and cognitive styles, engineers drawing tools support UML. express models using diagrams, structured text, The software community naturally as- and storyboards of one form or another. sumed tool interchange and interoperability Software modelers depend on and use engi- would be the OMG’s next contribution. But neering analogies but often fail to understand here’s where we move from the good to the them. Engineers realize that the models aren’t bad. The OMG dropped the ball and ex- the product: they’re abstractions of the prod- pended no serious efforts on tool interoper- uct. In fact, in most cases, the models are only ability. Nor was there any follow-through on</abstract>
      <region class="unknown" id="8">I <email id="7">fowler@acm.org</email></region>
      <outsider class="DoCO:TextBox" type="footer" id="9">0740-7459/04/$20.00 © 2004 IEEE</outsider>
      <outsider class="DoCO:TextBox" type="footer" id="10">Published by the IEEE Computer Society IEEE SOFTWARE</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="11">15</outsider>
      <outsider class="DoCO:TextBox" type="header" id="12">DEPT DESIGN TITLE</outsider>
      <region class="unknown" id="14">Related Work For more information on Model Driven Architecture, see I D.S. Frankel, Model Driven Architecture: Applying MDA to Enterprise Com- puting, John Wiley &amp; Sons, 2003 I S.J. Mellor and M.J. Balcer, Executable UML: A Foundation for Model Driven Architecture, Addison-Wesley, 2002 To learn what Martin Fowler, Steve Cook, Steve Ambler, and Jean Bézivin say about MDA, see I M. Fowler, “Model Driven Architecture,” 2004, <ext-link ext-link-type="uri" href="http://martinfowler.com/" id="13">http://martinfowler.com/</ext-link> bliki/ModelDrivenArchitecture.html I S. Cook, “Domain Specific Modeling and Model Driven Architecture,” 2004, www.bptrends.com/publicationfiles/01-04%20COL%20Dom%20Spec% 20Modeling%20Frankel-Cook.pdf I S. Ambler, “Model Driven Architecture Is Ready for Prime Time,” IEEE Software, Sept./Oct. 2003, pp. 71–73 I J. Bézivin, “MDA: From Hype to Hope, and Reality,” invited talk, UML 2003, www.sciences.univ-nantes.fr/info/perso/permanents/bezivin/UML.2003/ UML.SF.JB.GT.ppt</region>
      <region class="DoCO:TextChunk" id="16">developing reasonable structured syn- tax for UML artifacts. This says a lot about tool vendors’ power at the OMG and underlies some of the real prob- lems with UML evolution and MDA it- self. XMI Metadata Interchange ap- pears to be a backdoor project from the Meta Object Facility efforts, with a scramble to embrace XML. MOF efforts continue on a “human-readable notation.” The name says it all! And now we move to the ugly. It’s well known that language design by committee, especially with the techno- politics of “coopetition” between vendors and personal brands, is unlikely to produce a well-designed language. For example, the Activity concept is one of those political compromises in UML 1.0, and it’s been elevated to a metaclass for capturing all behavior in UML 2.0. 3 UML 2.0 lacks both a reference implementation and a human-readable semantic account to provide an operational semantics, so it’s difficult to interpret and correctly implement UML model transformation tools. For example, key concepts such as use cases lack sufficient semantics to support model refinement. Why not provide a simple accessible operational semantic ac- <marker type="column" number="2"/><marker type="block"/> count, perhaps through a metacircular interpreter? The revised Scheme report and the annotated reference specifications of Pascal and XML facilitate a serious external review in the language and modeling community. Such a semantic account would no doubt point out semantic holes and ambiguities, leading to an improved specification and reducing the time required to build robust MDA tools. In principle, the process is open to including missing items, such as script- ing, decision tables, higher-order func- tions, relations, a proper type system, and initialization and finalization. However, the reality is that vendor iner- tia, usually in implementing standards, typically makes version 2.0 the last real version for many years. Many in the ex- ecutable-UML crowd apparently work in domains that only require state machines, so they might have a vested commercial interest in UML remaining less than a complete language (see www. jot.fm/issues/issue_2003_01/column1).</region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="17" confidence="possible" page="2" column="2">Model engineering</h1>
        <region class="DoCO:TextChunk" id="26" page="2" column="2">Using metamodels is powerful and is very useful for self-description. Metamodels form the foundation of model <marker type="column" number="3"/><marker type="block"/> engineering, 1 of which MDA is a specific exemplar. Model engineering, or model-driven development, treats software development as a set of transformations between successive models from requirements to analysis, to design, to implementation, to deployment. Model-driven development, as pop- ularly practiced in Simula, Smalltalk, Lisp, Haskell, APL, and so forth, views models as useful partial descriptions that people transform, with tools, into programs. Agile development’s essence is that it emphasizes people’s impor- tance in not only the modeling process but also the transformation process. Model-engineering (www.metamodel. com/wisme-2002) advocates usually argue that we can almost completely au- tomate the model transformation process using a catalog of model transformations that convert one model to another. Research is promising in this area, which, like compilation and code generation before it, will no doubt yield some interesting techniques for program refinement. MDA further specializes the model- engineering approach to using the MOF and associated UML models. The OMG MOF plays a key role in MDA because it’s the Holy Grail that unifies UML, UML profiles, and hence MDA platform- specific models.<marker type="block"/> Metamodels Modern metamodeling has its foundation in computational-reflection work, although for many years, databases, op- erating systems, languages, and tools contained self-descriptions that today we often call schemas, metadata, or meta- classes. Metamodeling is, in many ways, the computational equivalent of the phi- losophy of self—defining concepts and expressing them at the right level in the reflective tower is difficult and requires a lot of mental precision. Does a particular concept belong in the model, metamodel, or meta metamodel? IBM’s AD/Cycle used entity-relationship models (the UML of that era born again as the Object Modeling Tech- nique) to define a grand unified metamodel, called the Information Model.<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> AD/Cycle let all methodologists of the day map their concepts, proven or not, into the IM. For example, we could suc- cessfully map OO concepts such as objects, methods, and packages into the IM with little difficulty simply by interpret- ing the IM in our own way and over- loading an existing metaconcept. This let us store OO models in an IM that actually had no idea what an object was. The key point is that metamodels let you easily add new concepts. However, they don’t ensure that these concepts make semantic sense, nor do they ensure that different metamodels (such as UML profiles) are consistent or orthogonal.<marker type="block"/> Platform-specific models A critical component of successful MDA tooling is the existence of sound platform-independent models and plat- form-specific models 1 for various target platforms such as J2EE, J2ME, MS.NET Windows and Compact Frameworks, and Linux Apache. PSMs must model the target platforms with sufficient precision to allow model transformations from UML PIMs to code. For restricted behaviors, such as state machine models, creating PIMs and PSMs are relatively easy. PIMs describe a limited form of behavior that is useful for an application’s specific domains. However, a state machine or OMT models alone can describe few complete applications. Furthermore, we hardly need MDA to generate code from a state machine or entity-relationship models because these have existed for years! However, it is distinctly nontrivial— many would argue impossible—to support and evolve semantically correct PSMs for platforms such as J2EE or .NET. These platforms contain thou- sands of APIs, many of which are poorly documented or don’t conform to the textual specifications that partially describe them. Add to this the layers of middleware and enterprise applications such as SAP, Oracle, and Peoplesoft, and we have a mountain of software that lacks any comprehensive model. Furthermore, even if through some Herculean effort we could produce such a PSM, it would no sooner be<marker type="column" number="2"/><marker type="block"/> available than the vendor’s next release would render it outdated. We have decades of experience building auto- mated code generators for compilers and yet still find it challenging to build a code generator for the Itanium processor, let alone for an Itanium run- ning a particular vendor’s OS, JVM, J2EE, and middleware. The accidental complexity of the stack makes a comprehensive PSM virtually impossible. Some MDA proponents respond that they generate the code from the model and then let the developers deal with the remaining specifics of platforms, libraries, and legacy interfaces. This is a nightmare because now the poor developer, misled by the “all you need is UML” hype, is stuck having to debug and develop code that a tool generated. They are forced to dive deep into the most difficult part of the development cycle—using a specific- platform API.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="21" page="2" column="3">16</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="22" page="2" column="3">IEEE SOFTWARE w w w . c o m p u t e r. o r g / s o f t w a r e</outsider>
        <outsider class="DoCO:TextBox" type="header" id="23" page="3" column="1">DEPT DESIGN TITLE</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="27" confidence="possible" page="3" column="2">Domain-oriented programming and domain- specific languages</h1>
        <region class="DoCO:TextChunk" id="31" page="3" column="2">We must pay more attention to methods, tools, and models that directly support domain-oriented programming. 4 UML is useful for many IT applications or telecom style systems that we can substantially describe using OMT or Object Chart style specifications. It provides little leverage for a <marker type="column" number="3"/><marker type="block"/> biologist, process control engineer, hedge fund analyst, or other domain specialist whose primary interest is in modeling directly in the application domain rather than in learning IT spe- cialists’ lingua franca, be it UML or Java. Domain-specific languages lift the platform’s level, reduce the underlying APIs’ surface area, and let knowledge- able end users live in their data without complex software-centric models and the API field of dreams.<marker type="block"/> any have tried to build rich, com- M languages prehensive, including unified models PL/I, Algol and 68, i-Case (such as AD/Cycle), and ADA. 5 In each case, they were well mo- tivated, basing their models on leading- edge ideas. However, these models were unsuccessful due to their latent complexity, lack of interoperable implementations, the accidental complexity of real platforms, and the rapid rate of change in the industry. MDA, as cur- rently defined and espoused, will likely meet the same fate. However, used in moderation and where appropriate, UML and MDA code generators are useful tools, although not the panaceas that some would have us believe.</region>
        <region class="unknown" id="29" page="3" column="2">Used in moderation and where appropriate, UML and MDA code generators are useful tools, although not the panaceas that some would have us believe.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="32" confidence="possible" page="3" column="3">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="33" page="3" column="3">1. A. Kleppe, J. Warmer, and W. Bast, MDA Ex- plained: The Model Driven Architecture-Prac- tice and Promise, Addison-Wesley, 2003.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="34" page="3" column="3">2. M. Fowler and K. Scott, UML Distilled: A Brief Guide to the Standard Object Modeling Language, Addison-Wesley, 1999.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="35" page="3" column="3">3. M. Bjorkander and C. Kobryn, “Architecting Systems with UML 2.0,” IEEE Software, July/Aug. 2003, pp. 57–61.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="36" page="3" column="3">4. D. Thomas and B.M. Barry, “Model Driven Development: The Case for Domain Oriented Programming,” Companion of the 18th Ann. ACM SIGPLAN Conf. Object-Oriented Pro- gramming, Systems, Languages, and Applica- tions, ACM Press, 2003, pp. 2–7.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="37" page="3" column="3">5. T. Hoare, “The Emperor’s Old Clothes: The ACM Turing Award Lecture,” Comm. ACM, vol. 24, no. 2, 1981, pp. 75–83.</ref>
        </ref-list>
        <region class="DoCO:TextChunk" id="38" confidence="possible" page="3" column="3">Dave Thomas is cofounder of Bedarra Research Labs (www.bedarra.com) and OpenAugment Consortium (www. openaugment.org), and an adjunct professor at Carleton University, Canada and the University of Queensland, Australia. He is also a founding director of AgileAlliance.com and founder of ObjectTech- nology International (www.oti.com). Contact him at dave@ bedarra.com; www.davethomas.net.</region>
        <outsider class="DoCO:TextBox" type="footer" id="39" page="3" column="3">May/June 2004 IEEE SOFTWARE</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="40" page="3" column="3">17</outsider>
      </section>
    </body>
  </article>
</pdfx>
