<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>06b3b9c86442db14679bbd1eb7c24499e81d073048a58af66b41a46f8497637e</job>
    <base_name>62m2</base_name>
    <doi confidence="possible" alt_doi="http://dx.doi.org/10.1007/978-3-642-82453-1_5">http://dx.doi.org/10.1145/800235.807071</doi>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <region class="unknown" id="1">THE TEMPORAL LOGIC</region>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="2">Amir Pnueli University of Pennsy lvania</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="3">Pa. 191D</name>
          <aff id="4">4</aff>
        </contrib>
        <contrib contrib-type="author">
          <name id="5">Tel-Aviv University</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="6">Tel Aviv</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="7">Israel</name>
        </contrib>
      </contrib-group>
      <title-group>
        <article-title class="DoCO:Title" id="15" confidence="possible">Summary: grams, always considered functional programs only. Those are programs with distinct beginning and end, and A unified approach to program verification is sane canputational instructions in between, whose suggested, which applies to both sequential and statement of correctness consists of the description parallel programs. The main proof method suggested is of the func tion of the input variab les c anputed on that of temporal reasoning in which the time depend- successful cOOlpletion. This approach canpletely ence of events is the basic concept. Two forma 1 ignored an important class of operating system or systems are presented for providing a basis for tem- real time type programs, for which halting is rather poral reasoning. One forms a formalization of the an abnormal situation. Only recently 10,11,19 have method of intermittent assertions, while the other is people begun investigating the concept of correctness an adaptation of the tense logic system Kb , and is for non-terminating cyclic programs. It seems that the notion of temporal implication is the correct one. particularly suitable for reasoning about concurrent Thus, a specification of correctness for an operating programs. system may be that it responds correctly to any incoming request, expressible as: {Request arrival O. Introduction situation }~ System grants request }. Due to increasing maturity in the research on Similar to the unification of correctness basic program verification, and the increasing interest and concepts, there seems to be a unification in the basic understanding of the behavior of concurrent programs, proof methods. Thus for proving invariance the widely it is possible to distinguish two important trends in acc laimed method is the induc tive assertion method. the research concerning both these fields. The first For proving eventuality one uses either the well is towards unification of the basic notions and founded set method or a relatively recent method which approaches to program verification, be they sequential we prefer to call temporal reasoning. This methcxi, or concurrent programs. The sec and is the continuous introduced by Burstal15 and further developed in [19] search f or proof methods which will approximate more and [24] (called there the method of intermittent and more the intuitive reasoning that a programmer assertions), represents the second mentioned trend in employs in designing and implementing his programs. trying to approach the intuitive natural line of reasoning one may adopt when informally justifying his As a result of the first trend, one can indeed program. claim today that there exist very few simple proof principles which apply equally well to both sequentia 1 This paper attempts to contribute to these two and concurrent progr~ms. Thus, the prevalent notions trends. Two formal systems are presented which give a of what constitutes a correctness of a program can all sound basis to the yet unformalized methodology of be reduced to two main concepts: temporal reasoning about programs. This will on one hand enhance the particular method it formalizes, and a. The concept of invariance, i.e. a property on the other hand stress and give more insight to the holding continuous ly thr oughout the execution of a important concept of eventuality. program. By appropriately extending the concept of an assertion to describe a relation between the values of The first of the two systems is a direct formal the variables and the location at which the program is paraphraze of the ideas and arguments repeatedly used executing, it can be shown that the general notion of in [5] and [19]. Since this system seems adequate for invariance covers the concepts of partial correctness sequential programs but too weak to accomodate the and clean behavior for sequential programs, and in multi branching alternate reasoning needed for con- addition these of mutual exclusion, safety and dead- current programs, a second system was adopted, which is lock freedan in concurrent programs. richer in structure and is actually but a modification b. The second and even more important concept is of the tense logic system Kb studied by Rescher and that of eventuality (or temporal implication). In its Urquhart in [23]. This system seems much more satis- full generality this denotes a dependence in time in fying and able to model the more intricate reasoning the behavior of the program. We write ~~~, read as: involved in proving temporal correctness of concurrent 1I'4J eventually follows c.p II or II &lt;.p temporally implies programs. "p ", if whenever the situation described by cP arises in the program, it is guaranteed that eventu- The significance of temporal reasoning to con- ally the situation described by ~will be attained. current programs was pointed out in [lO,llJ. However the tool suggested there, introduction of real time The notion of eventua lity c overs as a specia 1 clock seems too gross and powerful for the purpose case the property of total correctness. In addition needed. We correct this situation here by formulating it pr ovides the righ t genera liza ti on of c orrec t the system K+ b which is tailored to have exactly the behavior in time for cyc lic or non-func ti rna 1 pr ograms. adequate power and mechanism for proving temporal dependencies of concurrent programs. The classical approoch to correctness of programs, such as re~resented in Manna 17, Hoare 6 ,8 and also Another formalization of the intermittent Owicki 2l,2 who addressed herself to concurrent pro- assertion method using a richer tense logic has just recent ly appeared in l3] J [.4J . *This research was supported in part by ONR under contract N00014-76-C-04l6 and by NSF grant MCS 1. Systems and Programs 76-19466. A unified approach to both sequential and c oncur-</article-title>
      </title-group>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="14" page="1" column="1">A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two forma 1 systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb , and is particularly suitable for reasoning about concurrent programs. <marker type="block"/> Due to increasing maturity in the research on program verification, and the increasing interest and understanding of the behavior of concurrent programs, it is possible to distinguish two important trends in the research concerning both these fields. The first is towards unification of the basic notions and approaches to program verification, be they sequential or concurrent programs. The sec and is the continuous search f or proof methods which will approximate more and more the intuitive reasoning that a programmer employs in designing and implementing his programs.<marker type="block"/> As a result of the first trend, one can indeed claim today that there exist very few simple proof principles which apply equally well to both sequentia 1 and concurrent progr~ms. Thus, the prevalent notions of what constitutes a correctness of a program can all be reduced to two main concepts:<marker type="block"/> a. The concept of invariance, i.e. a property holding continuous ly thr oughout the execution of a program. By appropriately extending the concept of an assertion to describe a relation between the values of the variables and the location at which the program is executing, it can be shown that the general notion of invariance covers the concepts of partial correctness and clean behavior for sequential programs, and in addition these of mutual exclusion, safety and deadlock freedan in concurrent programs.<marker type="block"/> b. The second and even more important concept is that of eventuality (or temporal implication). In its full generality this denotes a dependence in time in the behavior of the program. We write ~~~, read as: 1I'4J eventually follows c.p II or II &lt;.p temporally implies "p ", if whenever the situation described by cP arises in the program, it is guaranteed that eventually the situation described by be attained.<marker type="block"/> The notion of eventua lity c overs as a specia 1 case the property of total correctness. In addition it pr ovides the righ t genera liza ti on of c orrec t behavior in time for cyc lic or non-func ti rna 1 pr ograms.<marker type="block"/> The classical approoch to correctness of programs, such as re~resented in Manna 17, Hoare 6 ,8 and also Owicki 2l,2 who addressed herself to concurrent pro-</region>
      <region class="unknown" id="16" page="1" column="2">OF PROGRAMS*</region>
      <region class="DoCO:TextChunk" id="20" page="1" column="2">grams, always considered functional programs only. Those are programs with distinct beginning and end, and sane canputational instructions in between, whose statement of correctness consists of the description of the func tion of the input variab les c anputed on successful cOOlpletion. This approach canpletely ignored an important class of operating system or real time type programs, for which halting is rather an abnormal situation. Only recently 10,11,19 have people begun investigating the concept of correctness for non-terminating cyclic programs. It seems that the notion of temporal implication is the correct one. Thus, a specification of correctness for an operating system may be that it responds correctly to any incoming request, expressible as: {Request arrival situation System grants request }. <marker type="block"/> Similar to the unification of correctness basic concepts, there seems to be a unification in the basic proof methods. Thus for proving invariance the widely acc laimed method is the induc tive assertion method. For proving eventuality one uses either the well founded set method or a relatively recent method which we prefer to call temporal reasoning. This methcxi, introduced by Burstal15 and further developed in [19] and [24] (called there the method of intermittent assertions), represents the second mentioned trend in trying to approach the intuitive natural line of reasoning one may adopt when informally justifying his program.<marker type="block"/> The first of the two systems is a direct formal paraphraze of the ideas and arguments repeatedly used in [5] and [19]. Since this system seems adequate for sequential programs but too weak to accomodate the multi branching alternate reasoning needed for concurrent programs, a second system was adopted, which is richer in structure and is actually but a modification of the tense logic system Kb studied by Rescher and Urquhart in [23]. This system seems much more satisfying and able to model the more intricate reasoning involved in proving temporal correctness of concurrent programs.<marker type="block"/> The significance of temporal reasoning to concurrent programs was pointed out in [lO,llJ. However the tool suggested there, introduction of real time clock seems too gross and powerful for the purpose needed. We correct this situation here by formulating the system K+ b which is tailored to have exactly the adequate power and mechanism for proving temporal dependencies of concurrent programs.</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="21" page="1" column="2">46</outsider>
      <region class="DoCO:TextChunk" id="22" confidence="possible" page="2" column="1">rent programs is provided bv the general framework of a system (see also Keller 13 ).</region>
      <region class="DoCO:TextChunk" id="23" confidence="possible" page="2" column="1">A dynamic discrete system consists of</region>
      <region class="DoCO:TextChunk" id="24" confidence="possible" page="2" column="1">&lt; S, R, So &gt;</region>
      <region class="DoCO:TextChunk" id="25" confidence="possible" page="2" column="1">where:</region>
      <region class="DoCO:TextChunk" id="26" confidence="possible" page="2" column="1">S - is the set of states the system may assume (possibly infinite)</region>
      <region class="unknown" id="27" page="2" column="1">R -</region>
      <region class="DoCO:TextChunk" id="28" confidence="possible" page="2" column="1">is the transition relation holding between a state and its possible successors, R ~ S x S So - is the initia 1 state .</region>
      <region class="DoCO:TextChunk" id="29" confidence="possible" page="2" column="1">An execution of the system is a sequence:</region>
      <region class="DoCO:TextChunk" id="30" confidence="possible" page="2" column="1">()I -= so' s 1, · . ·</region>
      <region class="DoCO:TextChunk" id="31" confidence="possible" page="2" column="1">Since R is nondeterministic in general, many different execution sequences are possible.</region>
      <region class="DoCO:TextChunk" id="32" page="2" column="1">Obviously the concept of a discrete system is very general. It applies to programs manipulating digital data (cenventional programs) to programs manipulating physical objects (Rooot driving programs), to general engineering and even biological systems, restricted only by the requirement that their evo- lution in time be discrete. Consequently any proof principle that can be developed for general systems shoold apply to the verification of behavior of any of these systems. McCarthy and Hayes advocated in</region>
      <region class="DoCO:TextChunk" id="33" confidence="possible" page="2" column="1">[20] such a general apprCBch and to a certain extent this paper is a technica I pursuance of some of the general ideas expressed there.</region>
      <region class="DoCO:TextChunk" id="34" confidence="possible" page="2" column="1">However, being chiefly motivated by prOblems in the programming area, all the examples and following discussions will be addressed to verification of programs. The generality provided by the system's concept is only utilized for presenting a uniform approach to both sequential and concurrent programs and their verification.</region>
      <region class="DoCO:TextChunk" id="35" confidence="possible" page="2" column="1">In order to Particularize systems into programs further structuring of the state notion is needed.</region>
      <region class="DoCO:TextChunk" id="36" confidence="possible" page="2" column="1">Sequential Programs</region>
      <region class="DoCO:TextChunk" id="37" confidence="possible" page="2" column="1">The specific model of deterministic sequential programs can be obtained by structuring the general state into</region>
      <region class="DoCO:TextChunk" id="38" confidence="possible" page="2" column="1">s -= &lt;1T , U &gt;</region>
      <region class="DoCO:TextChunk" id="39" confidence="possible" page="2" column="1">1T is the centrol canponent and assumes a finite number of values, taken to be labels or locations in the program. L -= {R- o , R- I ,· •• t n } u is the data c anp onent and wi 11 usua lly range ooer an infinite danain. In actual applications it can be further structured into individual variables and data structures.</region>
      <region class="DoCO:TextChunk" id="40" page="2" column="1">The transition relation R can also be partiticned into a next-location function N (1T,U) and a data- transformation functicn T (1T,U). N (t,u) will ac tua lly depend on u only if the sta tement at t is a c onditiona 1.</region>
      <region class="DoCO:TextChunk" id="41" confidence="possible" page="2" column="1">We can thus express R in terms of Nand T:</region>
      <region class="DoCO:FigureBox" id="Fx42">
        <image class="DoCO:Figure" src="62m2.page_002.image_02.png" thmb="62m2.page_002.image_02-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="43" confidence="possible" page="2" column="2">R«1T,1..1 &gt;7 &lt;11",1..1' » &lt;I: &gt; 7T' -= N(7T,u) &amp; u' = T(1T,u)</region>
      <region class="DoCO:TextChunk" id="44" page="2" column="2">The restriction to deterministic programs is noc essentia 1 and is made only to simplify notation.</region>
      <region class="DoCO:TextChunk" id="45" confidence="possible" page="2" column="2">Concurrent Programs</region>
      <region class="DoCO:TextChunk" id="48" page="2" column="2">By allowing more than one control cOOlpcnent we get the case of parallel programs. The state is to be partitioned as: <marker type="block"/> s -= &lt; 1T l' .. 1T n ; u &gt; The range of each 1Ti may be considered as the (finite) program for the i-th processor, while u is the shared data canpanent . We assume that the next state function N(1T,U), and the data transformation T(1T,U) are still deterministic and depend on a single control canponent at a time . However the scheduling choice of the next processor to be stepped is nondeterministic .<marker type="block"/> Intuitively, the model admits n programs being concurrent ly run by n processors. At each step of the whole system, one processor, i is selected, and the statement at the location pointed to by 1T is i executed to cornp letion (we do not a llow procedures). This might seem at first glance to be restrictive, being unable to model possible interference between different phases of concurrent statements' execution. However it is up to the user to express his program in units which for his modelling purposes can be considered atanic. Thus for one user the statement</region>
      <region class="DoCO:TextChunk" id="49" confidence="possible" page="2" column="2">y f(y)</region>
      <region class="DoCO:TextChunk" id="50" confidence="possible" page="2" column="2">mt',y be considered atanic, while another who may be worried ab rot p ossib Ie interference fran other concurrent programs between the fetch and store phases of this instruction may write instead:</region>
      <region class="DoCO:TextChunk" id="51" confidence="possible" page="2" column="2">yoE- f(t)</region>
      <region class="DoCO:TextChunk" id="52" confidence="possible" page="2" column="2">where t is a new variable local to the particular process. Interference may now occur between those two statements. Since we will be interested in proving termination, we will require the scheduling to be fair i.e. no processor may be indefinitely de layed while enab led. This wi 11 be made more pre- cise later.</region>
      <region class="DoCO:TextChunk" id="53" confidence="possible" page="2" column="2">Formally we can express the overall transition rule by the individual transition functions of each of the processors as:</region>
      <region class="DoCO:TextChunk" id="54" confidence="possible" page="2" column="2">for s orne i, 1 i n:</region>
      <region class="DoCO:TextChunk" id="55" confidence="possible" page="2" column="2">u' -= Ti (1Ti' u) 2. Specifications and Their Classification</region>
      <region class="DoCO:TextChunk" id="56" confidence="possible" page="2" column="2">A Time Hierarchy of Specifications</region>
      <region class="DoCO:TextChunk" id="57" confidence="possible" page="2" column="2">To express properties of systems and their development in time we use relations on states q(s) (predicates) expressed in a suitable language. Applied to programs this will be a relation q(1T , •. 1T ; u) between the data values and the l n location of all the processor pointers. The general ver~fication problem is that of establishing facts</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="58" page="2" column="2">47</outsider>
      <region class="DoCO:TextChunk" id="59" confidence="possible" page="3" column="1">about development of the properties q(s)</region>
      <region class="DoCO:TextChunk" id="64" page="3" column="1">Introducing explicit time variables t l , tz, .. which in oor model range over the natural numbers and may be connected by the relations -=, &lt;, and the time functional <marker type="block"/> it is obvious that any arbitrary complex time dependency can be expressed. This approach was taken in 11 where some intricate time specifications are illus- trated.<marker type="block"/> Here, however, we find it both instructive and useful to limit the expressive power of the language with respect to dependency in time, and observe the actual complexity required to express different useful properties. Thus it is possible to classify specifications according to the number of distinct time variables needed to express it in a time explicit formula •<marker type="block"/> 1. Single Time Instance Specification Invariance. Having only one time variable it may be either existentially or universally quanti- fied. If we choose the latter we obtain the notion of Invariance - a property holding throughout all states of all possible execution sequences.<marker type="block"/> Extending the binary relation R to its transitive closure R* we define the set of accessible states</region>
      <region class="DoCO:TextChunk" id="65" confidence="possible" page="3" column="1">A predicate p(s) is invariant in the system if for every accessible state seX p(s) holds. (V seX)p(s) i.e. Many important properties fa 11 under of invariance relations:</region>
      <region class="DoCO:TextChunk" id="68" page="3" column="1">Partial Correctness: Consider a sequential program with entry label R- o and exit label R- m. To state its partial correctness with respect to ({J('X), \V (i,z)17 we can claim the invariance of the statement: <marker type="block"/> i.e. that it is invariantly true that whenever we reach the exit, if the input satisfies its specification then so does the output. Clean Execution Z5 ,18 In all realistic situations it is not sufficient to prove that on terminaticn the result is satisfactory. One should also see to it that 00 the way, no step is taken which will cause the program to behave illegally. Thus, attention should be paid to the host of potential mishaps such as: zero division, numerical overflow, exceeding subscript range, etc. Taking as an illustration the zero division case, let R- l , R- Z' .. R- k be all the locations at which division is executed, and Yl'YZ' Yk the ~espective divisors. The statement of zero division fault freedom is the invariance of the claim (1T -= R- 1 ::&gt; y 1 -I 0) 1\ ••• 1\ (1T -= R,k <email id="67">=:;</email>) Yk -I 0) A variant of this (counter boondedness) can be used also to establish termination. Mutual Exc lusicn Turning now to c cncurrent programs, let us c cnsider establishing mutua 1 exc lusion of critical sections in two concurrent programs. Let Sl be the critical section in the first program, i.e. a subset of the labels of the program, and Sz</region>
      <region class="DoCO:FigureBox" id="Fx69">
        <image class="DoCO:Figure" src="62m2.page_003.image_03.png" thmb="62m2.page_003.image_03-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="70" confidence="possible" page="3" column="2">in time.</region>
      <region class="DoCO:TextChunk" id="71" confidence="possible" page="3" column="2">the second critical section. Then the statement of mutual exclusion amoonts to the claim of invariance:</region>
      <region class="DoCO:TextChunk" id="72" page="3" column="2">&amp;'&gt;(1T l £S:I. 1\ 1T Z£S2) Deadlock Freedom2l , 22 . Consider a set of concurrent programs which communicate via semaphores. A deadlock will be a situation in which each of the processors is waiting on a 'p' operaticn and none of the semaphore variables which are waited f or is positive. Since each of the programs is of finite length, and ooly in a finite subset of their instructions are there 'p' operations)it is possible to coostruct a finite list of label vectors iI, R;Z, .• "i r such that each R-f labels a 'p' instructioo in the jth program. Correspondingly we can ccnstruct a list of vectors of -1 -Z -r -i variables u , u , .. u such that u contains all the semaphore variables waited on in the instructions labeled by ii. Deadlock freedom is guaranteed by the invariance of the claim:</region>
      <region class="DoCO:TextChunk" id="73" confidence="possible" page="3" column="2">Z. Two Time Instances - Eventua lity (Temporal Imp lica t i on)</region>
      <region class="DoCO:TextChunk" id="74" confidence="possible" page="3" column="2">The most useful two time variables statement (by no means the only ooe) is that of eventuality (Temp ora 1 Imp lica t ion) We write ~ 4J for</region>
      <region class="unknown" id="75" page="3" column="2">&lt;.f V ,"¥)</region>
      <region class="DoCO:TextChunk" id="76" confidence="possible" page="3" column="2">tl 3t z (t z ~ t l ) H(tl,{f):::&gt; H(t 2 i.e. for every execution G'- so' sl' .. whenever there exists an si such that ~(si) there must exist a later s j ' j ~ i such tha t \,JJ (s j ).</region>
      <region class="DoCO:TextChunk" id="77" confidence="possible" page="3" column="2">V t H(t, p)</region>
      <region class="DoCO:TextChunk" id="78" confidence="possible" page="3" column="2">the class</region>
      <region class="DoCO:TextChunk" id="79" confidence="possible" page="3" column="2">An imp ortant instance of an eventua Ii ty is that of total correctness. For a sequential program with entry label R,o and exit label ~ , the statement of total correctness with respect to predicates 'f , 4J can be expressed by the eventua li ty:</region>
      <region class="DoCO:TextChunk" id="80" confidence="possible" page="3" column="2">i.e. if we enter the program with input values satisfying CP, we will eventually reach the exit point with variables' values satisfying QJ •</region>
      <region class="DoCO:TextChunk" id="81" confidence="possible" page="3" column="2">In applying eventuality specifications to nondeterministic and concurrent programs we must distinguish between terminating and cyclic programs 11. Programs of the first kind are expected to terminate and present a result of their canputation. Total correctness for them involves guarantee of termination and of satisfaction of the output predicate on termination. Generalizatioo of these to concurrent terminating programs is straightforward (in the formula above replace 7f, R- o• ~ by their vector counterparts) .</region>
      <region class="DoCO:TextChunk" id="82" page="3" column="2">Cyc lic programs en the other hand are not supposed to halt and are run for providing ccntinuous response to external stimulii. A typical example wi 11 be an operating sys tem which runs c ontinuoos ly (hopefully) and is expected to respond to both external events, and requests from user programs which for modelling purposes can also be cansidered external stimulii. For this type of programs the notion of total correctness has to be extended. We claim that most of the reasonable extensions fall into the category of eventuality. To mention few, there is the property of accesibility. Usually in a mutual exc lusion envirooment there is the dua 1 property</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="83" page="3" column="2">48</outsider>
      <region class="DoCO:TextChunk" id="84" confidence="possible" page="4" column="1">(termed 1iveness in [16]) of any of the pr ocess ors eventually being able to access its critical section once it set its mind to it. If we denote by £ the location in the program where a processor decides it wishes to enter and by S the set of locations canpri- sing the critical section, then the following eventuality expresses accessibility:</region>
      <region class="DoCO:TextChunk" id="85" page="4" column="1">A more general property is that of responsiveness which is appropriate for the operating system model. If an externa 1 stimulus such as a user program making a request far a resource is signified by setting a request variab Ie to 1, or more genera lly by making cP become true, and the system response of granting this request is signa lIed by causing &lt;+&gt; to bec ane true, then the genera 1 c arrec t resp onsiveness pr operty is expressed by e.p ~ 'IJ which guarantees that far every request, there wi 11 eventua lly cane a c orrec t res- pense.</region>
      <region class="DoCO:TextChunk" id="86" confidence="possible" page="4" column="1">The Rest of the Hierarchy</region>
      <region class="DoCO:TextChunk" id="88" page="4" column="1">These two, admittedely important, constructs by no means exhaust the range of interesting and even useful properties of programs. For example, continu- ing in the vein of stating properties of operating systems, there is the question of fairness in granting requests. This for example could state that if at tl user A requested a resource and then at a later tz user B requested the same resource then there will be a t3 when user A will be granted his resource such that at no intermediate t4 t l ~ t4 ~ t 3 was B granted it)sidestepping Asprior request. This seems like a four variable statement and not too farfetched one. <marker type="block"/> Beyond the complete range of qualitative statements about one event preceding the other, lies another danain of questions re lating to the quanti- tative relatiens between timely events. If the system is going to respond, will it respond within 10 )048, 10 ms or 10 seconds?, etc. In this paper we address ourselves enly to the two "simple" cases of invariance and eventuality.</region>
      <region class="DoCO:TextChunk" id="89" confidence="possible" page="4" column="1">3. General Proof Principles</region>
      <region class="DoCO:TextChunk" id="90" page="4" column="1">Following the description of the statements we would like to prove we present a survey of three proof principles. These will be described first in the genera 1 system framework and then app lied in turn to sequential and then ccncurrent programs: When parti- cularized to programs of either type they wi 11 be shown to reduce to knGln methods f or some of the cases.</region>
      <region class="DoCO:TextChunk" id="91" confidence="possible" page="4" column="1">A. Invariance: The universally accepted method for establishing invariance is that of induction:</region>
      <region class="DoCO:TextChunk" id="92" confidence="possible" page="4" column="1">(PI)</region>
      <region class="DoCO:TextChunk" id="93" page="4" column="1">This is obviously the principle of computational inducticn. Clearly, a property which holds initially and is transferred aleng any legal transition (is inductive 13 ) is invariant. Naturally when wishing to estab lish the invariance of a given property (such as correctness on exit) it will usually have to be gen- eralized. This will carrespcnd to the known method of 9 inductive assertiens •</region>
      <region class="DoCO:TextChunk" id="94" confidence="possible" page="4" column="1">B. Well Founded Sets. This method is cne of the two</region>
      <region class="DoCO:FigureBox" id="Fx95">
        <image class="DoCO:Figure" src="62m2.page_004.image_04.png" thmb="62m2.page_004.image_04-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="96" page="4" column="2">that we present for establishing eventualities. We bring here only its natural number version, but its extension to other well founded sets is readily avail- ab Ie and described 17</region>
      <region class="DoCO:TextChunk" id="97" confidence="possible" page="4" column="2">Let A(s,n) be a predicate depending on the state s and a natural number n ~ o. Then</region>
      <region class="DoCO:TextChunk" id="98" confidence="possible" page="4" column="2">Cf(s) ~ 3n A(s, n) A(s,n) A R(s, sl) :::&gt;A(sl,n-l) v &lt;I1(s) (PZ)</region>
      <region class="DoCO:TextChunk" id="99" page="4" column="2">The ab0\7e principle incorporates both the notioo of invariance realized by the family of invariants A (s,n) and the notion of well founded set. The basic 9 idea is also due to Floyd, and many presentations similar to the above appear in the literature 1B , 16,13.</region>
      <region class="DoCO:TextChunk" id="100" confidence="possible" page="4" column="2">C. Reasoning About Eventualities</region>
      <region class="DoCO:TextChunk" id="101" page="4" column="2">In this approach one derives simple eventuality relations directly from the system transition rules (R) and then use canbination rules, and general logic reas cning to derive more c anp lex eventua lities. The method was first introduced by Burstall5 and developed further, in an informal form 19,24, under the name of the Intermittent Assertions method. Two formalizations of the method are suggested below and some alternate formalizations are given in [3] and [15]</region>
      <region class="DoCO:TextChunk" id="102" confidence="possible" page="4" column="2">Fran its inception this method had several advantages over method B above:</region>
      <region class="DoCO:TextChunk" id="104" page="4" column="2">a. It is more powerful than method B.As indicated in (19] any proof using method B can a lways be c 00- verted to a proof in the intermittent assertions method, and there exist some classes of programs (notably those which are obtained by translating recursive programs into iterative programs) for which a natural proof exists in method C, and any possible proof in B, will necessarily be overly cumbersome. <marker type="block"/> b. Proofs in C are inherently more intuitively appealing ("natural"). While B is essentially a proof by negation approach, showing that infinite or wrong computations are impossible, C adopts the more positive approach of establishing a chain of inevitable events, which following one another, will lead to a correct terminaticn (or attainment of objective). Thus, similarly to any gocxl assertions methcxl, it not ooly formally proves the program's correctness, but gives the prover (and the reader) a better insight into the structure and execution of the program.</region>
      <region class="DoCO:TextChunk" id="105" confidence="possible" page="4" column="2">The following axianatic system (ER) is a sug- ges ted forma liza ti on f or temp ora 1 reas ooing ab out events in a system.</region>
      <region class="DoCO:TextChunk" id="106" confidence="possible" page="4" column="2">Axioms</region>
      <region class="DoCO:TextChunk" id="107" confidence="possible" page="4" column="2">(AI)</region>
      <region class="DoCO:TextChunk" id="109" confidence="possible" page="4" column="2">p <email id="108">:;</email>) q -= &gt; p</region>
      <region class="unknown" id="110" page="4" column="2">(A2 )</region>
      <region class="DoCO:TextChunk" id="111" confidence="possible" page="4" column="2">Inference Rules</region>
      <region class="DoCO:TextChunk" id="112" confidence="possible" page="4" column="2">Vs,sl -=&gt; (pA.r)</region>
      <region class="unknown" id="113" page="4" column="2">(RZ)</region>
      <region class="DoCO:TextChunk" id="114" confidence="possible" page="4" column="2">q, P2 -=&gt; (PI VPZ) q (R3)</region>
      <region class="DoCO:TextChunk" id="115" confidence="possible" page="4" column="2">P q -=&gt;</region>
      <region class="unknown" id="116" page="4" column="2">(3up) -z. q</region>
      <region class="DoCO:TextChunk" id="117" confidence="possible" page="4" column="2">(R4)</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="118" page="4" column="2">49</outsider>
      <region class="DoCO:TextChunk" id="119" confidence="possible" page="5" column="1">In addition we take all theorems of the first order predicate calculus as axians.</region>
      <region class="DoCO:TextChunk" id="121" page="5" column="1">The axioms enable us to derive elementary eventua lities. (AI) says tha t if f or a 11 one step transitions, p before the transition implies q after the transition, then p~q is established. (Al) states that logica 1 implication is a special case of temporal implication. The inference rules enable us to deduce complex temporal implications fran simpler ones. Thus (R1) may be considered as either a Frame axiom or an invariance rule which adds an arbitrary invariant to any eventuality. <marker type="block"/> Note that once the connective ~ is introduced, it may participate in any arbitrary logical expression using the other logica 1 c onnec tives, and the usual rules of logic applied to derive proofs. Thus, for example, the general integer induction scheme will yield the following induction principle as a special case:</region>
      <region class="DoCO:TextChunk" id="122" confidence="possible" page="5" column="1">pen)</region>
      <region class="DoCO:TextChunk" id="123" confidence="possible" page="5" column="1">(I)</region>
      <region class="unknown" id="124" page="5" column="1">:z. r</region>
      <region class="DoCO:TextChunk" id="125" confidence="possible" page="5" column="1">p(o) ~q q p(ft,+l) pen) ~q</region>
      <region class="DoCO:TextChunk" id="126" confidence="possible" page="5" column="1">Fran which we may conclude 3n pen) (by</region>
      <region class="DoCO:TextChunk" id="127" confidence="possible" page="5" column="1">Theorem 1 The system (ER) is sound and complete for prcwing any property of the form Cf ~ "JJ •</region>
      <region class="DoCO:TextChunk" id="128" confidence="possible" page="5" column="1">Proof's Sketch: (Canpleteness)</region>
      <region class="DoCO:TextChunk" id="129" confidence="possible" page="5" column="1">Let ~~. Assuming the assertion language to be expressive, we can formulate in it the predicate p(s,n):</region>
      <region class="DoCO:TextChunk" id="130" confidence="possible" page="5" column="1">"Every execution starting with s will reach in no</region>
      <region class="DoCO:TextChunk" id="131" confidence="possible" page="5" column="1">mOre than n steps a state Sl such that \p(sl) holds."</region>
      <region class="DoCO:TextChunk" id="132" page="5" column="1">If we assume that our non determinism is bounded (i.e., for each s there is at most a finite number of different s1 such that R(s, sl) holds) then c.p~ 'P must imply by KOnigs infinity Lemma that: 1. &lt;.(&gt;(s)::&gt;3n p(s,n) is valid and hence prO\Tab1e in the logic. Similarly from the definition of p(s,n) the following claim is valid and hence provable: 2. p (s, n+1) :::" ~(s) V [V sIR (s, s 1) '::) p (s 1 , n) ] fran which 3. p (s, n+1) ~ [p (s, n) v\f' (s)] is provable by (AI) 4. p (s, 0):&gt;\fJ (s) By the definition of p from 3., (R2) and (R3): S. p(s,n)~'P(s) -=&gt; p(s,n+l) ~'+' (s) By the induction principle (I) 4. and S. 6. p(s,n) -z., ,+,(s) 7. 3n p (s, n) ~\P(s) by rule (R4) 8.'l'~'fJby 1.,7., (R2) and (A2).</region>
      <region class="DoCO:TextChunk" id="133" confidence="possible" page="5" column="1">4. Application to Sequential Programs</region>
      <region class="unknown" id="134" page="5" column="1">9</region>
      <region class="DoCO:TextChunk" id="139" page="5" column="1">We will now consider the applicatioo. of the general principles to sequential programs showing that A.) B. reduce to the known Floyd's methods while C. f erms a formalization of the Intermittent Assertions methodS <marker type="block"/> Invariance Consider a genera 1 asserti 00. on a deterministic sequentia 1 program q (1T, u). By considering that 1T may assume only a finite number of values 1T£ u,o' · .1m} we can always rewrite q (1T , u) E. (1T = £ 0) ::::&gt; q (1 0' u)<marker type="column" number="2"/><marker type="block"/> Consequent ly, we can express any globa 1 assertion q(1T,U) as a set of local assertions qi(u) -= q(£i'u) attached at each program locatioo. £i , ilCo, .. m (full annotation). We call this rewriting attachment. Con- versely any network of local assertioos {qi I ia:o, .. m} can be grouped to form a global assertion. q(1T,U)=.!\[(1T II: 1i) :::::&gt;qi(u)]</region>
      <region class="unknown" id="136" page="5" column="1">19</region>
      <region class="DoCO:FigureBox" id="Fx138">
        <image class="DoCO:Figure" src="62m2.page_005.image_05.png" thmb="62m2.page_005.image_05-thumb.png"/>
      </region>
      <region class="unknown" id="140" page="5" column="2">c-</region>
      <region class="DoCO:TextChunk" id="141" confidence="possible" page="5" column="2">If we examine the proof principle (PI) substi- tuting the attachment form of q(1T,U) we get the following conditions: qo(u o) For each i: qi(u)~qN (u) (T£(u»</region>
      <region class="unknown" id="142" page="5" column="2">£</region>
      <region class="DoCO:TextChunk" id="143" confidence="possible" page="5" column="2">i.e the initial values U should satisfy qo' and then o considering any locaticn i in the program, let N1 (u) denote its success or location (if i labels a c 00- ditiooa1 N 1 will depend on u) and T1 (u) the transformation u~T1 (u) affecting u 00 going fran £ to N£. We require that if q1(u) is true at £ then qN should</region>
      <region class="unknown" id="144" page="5" column="2">i</region>
      <region class="DoCO:TextChunk" id="145" confidence="possible" page="5" column="2">be true at N£ for the transformed values. These are</region>
      <region class="DoCO:TextChunk" id="146" page="5" column="2">exactly the verificaticn conditions for Floyd's methcxl in the full annotation case. As a result the principle ensures that q(1T,U) is invariant throughout the execution, in particular if execution reaches the exit point £m then ~ (u) holds. Thus partial correctness with respect to qo' qm has been established.</region>
      <region class="DoCO:TextChunk" id="147" confidence="possible" page="5" column="2">Eventuality (Total Correctness) In an identical way, method B for the sequential case can be shown to be equivalent to Floyd's well founded sets methcxl.</region>
      <region class="DoCO:TextChunk" id="148" page="5" column="2">Ccnsider now the methcxl of temp ora 1 reasoning (C). When we study the informal intermittent assertions method, as exemplified in [19], we find that the basic statement is: "if sometime p(u) at 11 then sanetime (later) q(u) at 1 2 " 1 , 1 being program locations (labels). 1 2 This can obvi ous ly be f ormu la ted as the temp ora 1 imp lica t ion: [1T = 1 1 " p(u)] ~[1T -= 1 2 1\ q(u)]</region>
      <region class="DoCO:TextChunk" id="149" confidence="possible" page="5" column="2">In order to complete the formalization we should clarify the form that axiom (AI) and rule (Rl) will assume in the sequential program case. In its most useful form we will ccnsider an arbitrary finite path in the pr ogram:</region>
      <region class="unknown" id="150" page="5" column="2">i</region>
      <region class="unknown" id="151" page="5" column="2">p (u)</region>
      <region class="DoCO:TextChunk" id="152" confidence="possible" page="5" column="2">Let denote the condition on u at i such that the path~ will be tra versed. Let Td(u) describe the transformaticn applied to u along 0&lt;.. Then (AI) f or the pa th 0( wi 11 be:</region>
      <region class="DoCO:TextChunk" id="153" confidence="possible" page="5" column="2">Vu p(u)::&gt;ro(u) I\q (To«u» IC&gt;</region>
      <region class="unknown" id="154" page="5" column="2">[ IT-= i " P (u) ] 7+</region>
      <region class="DoCO:TextChunk" id="155" confidence="possible" page="5" column="2">[1T -= j 1\ q (u) ]</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="156" page="5" column="2">50</outsider>
      <region class="DoCO:TextChunk" id="157" confidence="possible" page="6" column="1">For the more formally minded we should restrict the path to a single statement and consider the system (ER) augmented by a finite number of axioms which are instances of (AI), considering any of the possible types of statements.</region>
      <region class="DoCO:TextChunk" id="159" page="6" column="1">It is naY an exercise in formalization to take any of the proofs in [19], justify the basic lemmas by instances of (AI) and transitivity (R2) and work out the higher level lemmas and theorems using the induction principle (I). <marker type="block"/> Censequent ly (ER) is not en ly f onna lly c cmp lete as proved in theorem 1, but as just shown is a natural formalization(describing the formal machinery required for a system implementing the intermittent assertion method) of a method distinguished for its intuitive appeal.</region>
      <region class="DoCO:TextChunk" id="160" confidence="possible" page="6" column="1">5. Concurrent Programs</region>
      <region class="DoCO:TextChunk" id="162" page="6" column="1">Besides offering some additional insight into known metho:ls for sequential programs, the main justi- fication for the uniform approach suggested here is the strong guidelines it provides for verification methods for concurrent programs. <marker type="block"/> Invariance Using the next location function N and the next transformation function T it is straightforward to rewrite the general invariance principle for concurrent programs: q (n 0; u )</region>
      <region class="unknown" id="163" page="6" column="1">o</region>
      <region class="unknown" id="164" page="6" column="1">,N( 1</region>
      <region class="DoCO:TextChunk" id="165" confidence="possible" page="6" column="1">For each ia: 1, .. n q(1f l ,· ·1f n , u)::::&gt;q(1f l ,· ·1f i _ 1f i'u),. ·1fn ; T(1f. u»</region>
      <region class="unknown" id="166" page="6" column="1">1,</region>
      <region class="DoCO:TextChunk" id="167" confidence="possible" page="6" column="1">q(TI;u) is invariant.</region>
      <region class="DoCO:TextChunk" id="168" confidence="possible" page="6" column="1">The main prob lem and rationa Ie f or the different variations of this general principle is the canplexity of q(1f;u) and of the set of verification conditions.</region>
      <region class="DoCO:TextChunk" id="169" confidence="possible" page="6" column="1">The most straightforward and inefficient approach is that of full attachment l . Similar to the sequential case we rewrite for the two program case:</region>
      <region class="unknown" id="170" page="6" column="1">q('lT 1 , 'lT2; u) =A</region>
      <region class="unknown" id="171" page="6" column="1">" ĺT 2 c j):::&gt;qij (u)]</region>
      <region class="DoCO:TextChunk" id="172" confidence="possible" page="6" column="1">i,j</region>
      <region class="DoCO:TextChunk" id="173" confidence="possible" page="6" column="1">This gives rise to a number of local assertions which is proporticnal to the product of the sizes of the participating programs, and a corresponding number of verification conditions.</region>
      <region class="DoCO:TextChunk" id="174" confidence="possible" page="6" column="1">An improvement on the above is the idea of using only partial attachment:</region>
      <region class="unknown" id="175" page="6" column="1">q ( ÍT l' ÍT 2; u) =f\r ('IT 1 = i) .:J Pi ('IT 2' u il A !\[( ÍT 2 c j )::oq j ('IT l' u) ] i j</region>
      <region class="DoCO:TextChunk" id="176" confidence="possible" page="6" column="1">i.e. at each point in each of the programs we attach a local assertion which might still depend en the location of the other process. This dependence is sometimes implicit and is expressed by use of additional central or shadCM variables. Formally the number of assertions is now proportiona 1 to the sum of the sizes of the individual programs. However, if the interacticn between the programs is high we may have to consider in the verification conditions all possible values of the opposite processor, thus regaining the exponential canplexity.</region>
      <region class="DoCO:FigureBox" id="Fx177">
        <image class="DoCO:Figure" src="62m2.page_006.image_06.png" thmb="62m2.page_006.image_06-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="178" confidence="possible" page="6" column="2">On the other hand if the interaction is loose (as is very often the case) we do get an appreciable improvement and approach linear canplexity (sum of sizes). All the advanced methods suggested in [2], [21], [22] and [16] may be roughly classified as partial attachment metho:ls.</region>
      <region class="DoCO:TextChunk" id="179" page="6" column="2">Another pranising approach does no attachment at all 13,10, 12, but works directly in terms of global invariants, and the verification conditions presented at the beginning of this section. The dependence on locatim is usually expressed in more uniform way, sometimes arithmetic, than that of case enumeration. When successfu 1, this wi 11 a Is 0 yie ld linea r c anp lexi ty Since this method is less familiar we enclose a correctness proof of the producer-consumer problem taken rot of [10].</region>
      <region class="DoCO:TextChunk" id="180" confidence="possible" page="6" column="2">Example 1 (Producer-Consumer)</region>
      <region class="DoCO:TextChunk" id="181" page="6" column="2">Consider the producer - consumer concurrent program in Fig. 2. The producer places an item in the buffer after its producticn while the consumer removes it fran there. These operations are represented by respective incrementation and decrementatian of n the buffer's current load.</region>
      <region class="DoCO:TextChunk" id="182" confidence="possible" page="6" column="2">We wish to prove:</region>
      <region class="DoCO:TextChunk" id="183" confidence="possible" page="6" column="2">a. The producer and consumer are never simula- taneously at their respective critical sections (mutual exc lusion)</region>
      <region class="unknown" id="184" page="6" column="2">b. a</region>
      <region class="DoCO:TextChunk" id="185" confidence="possible" page="6" column="2">n N i.e. the buffer capacity is never</region>
      <region class="DoCO:TextChunk" id="186" confidence="possible" page="6" column="2">exceeded.</region>
      <region class="DoCO:TextChunk" id="187" confidence="possible" page="6" column="2">c. There is no deadlock.</region>
      <region class="DoCO:TextChunk" id="188" page="6" column="2">To prove these three prq&gt;erties we prove first the invariance of the f allowing three globa 1 assertions. Note that the dependence on the processor's pointer value is expressed in terms of the three character- istic functions m i , ri' si' i = 1,2 which assume the va lue 1 on sane locati ens and on the rest.</region>
      <region class="unknown" id="189" page="6" column="2">a</region>
      <region class="DoCO:TextChunk" id="190" confidence="possible" page="6" column="2">Invariants:</region>
      <region class="DoCO:TextChunk" id="191" confidence="possible" page="6" column="2">( 1) m 1 + m + MUTEX</region>
      <region class="unknown" id="192" page="6" column="2">2</region>
      <region class="unknown" id="193" page="6" column="2">Ie:: 1</region>
      <region class="DoCO:TextChunk" id="194" confidence="possible" page="6" column="2">(2) rl + r2 + IS EMPTY + IS_FULL = N</region>
      <region class="DoCO:TextChunk" id="195" confidence="possible" page="6" column="2">(3) s 1 + s 2 + I S EMPTY Ie:: n</region>
      <region class="DoCO:TextChunk" id="197" page="6" column="2">To establish each of these, check that they hold in initial state and then consider each possible single transition of each of the processors. We will use (1) - (3) now in order to prove a-c. <marker type="block"/> a. Assume that both processors are in their critical sections. We have then ml Ie:: m2 == 1 which by (1) implies MUTEX Ie:: -1 in contradiction to MUTEX being a semaphore.</region>
      <region class="DoCO:TextChunk" id="198" confidence="possible" page="6" column="2">b. From 3, since IS EMPTY is semaphore and sl' s2 ? 0 we get n O. By observing that si ~ r i i=1,2</region>
      <region class="DoCO:TextChunk" id="203" page="6" column="2">substitute (3) and bound it by (2) to get n = sl +8 2 +IS_EMPTY ~ rl + r 2 + IS_EMPTY = N - IS_FULL ~ N c. A deadlock can occur only if the two processors are waiting an a p operation. None can wait on a p(MUTEX) since then, assuming, say, that TIl is waiting we get ill == 0, MUTEX = a which by (1) implies l <marker type="page" number="7"/><marker type="column" number="1"/><marker type="block"/> m2 £ I which means that n2 is in its critical section and cannot be waiting on a p. The remaining possi- bility is that the producer is waiting on p(IS_EMPTY) and the consumer on p(IS_FULL) but that means that rl = r = IS_EMPTY II: IS_FULL II: 0 which by (2) leads to 2 N=O in contradiction to the buffer having positive capacity.<marker type="block"/> Many other cases of program synchronized by semaphores can be handled in a similarly efficjent way employing global assertions and arithmetized locaticn dependence 12 •<marker type="block"/> To summarize the issue of the complexity of concurrent program verification, it seems always possible to ccntrive an example which will defeat any proposed method by causing it to becane exponentially canplex. On the other hand we may bring once more the meta- physical argument advanced in [2], namely, that after all it was a human progrannner who wrote the program and believes it to be correct. He could not have possibly considered an exponential number of cases and must have had sane very few guiding reasons for writing it the way he did. It is the role of the proof method designer to c cme up with a method and language which will let him make these reasons more rigorous (and more conscious) and generate Qt1 efficient natura 1 proof.</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="200" page="6" column="2">51</outsider>
      <region class="DoCO:TextChunk" id="204" confidence="possible" page="7" column="1">Eventuality and Tense Logic</region>
      <region class="DoCO:TextChunk" id="205" confidence="possible" page="7" column="1">The method of well founded sets for termination or other eventualities can also be similarly considered with either full, partial or no attachment 13,16 However the dissatisfaction at its indirect- ness is even more intense then in the sequential case.</region>
      <region class="DoCO:TextChunk" id="206" page="7" column="1">Ccnsider next application of temporal reasoning to ccncurrent programs. A first attempt at formalization was done in [10] and reported in [11] by the explicit introduction of a real (or integer) valued time parameter for each event. Thus, we write H(t,p) for the statement that the assertion p is realized (holds) at the time instance t. Obviously any kind of dependency on time can be expressed by this powerful device. On the other hand it might be too powerful and obscure the question of which properties of time are really essential in order to establish simple properties such as temporal implication.</region>
      <region class="DoCO:TextChunk" id="207" confidence="possible" page="7" column="1">The system (ER), on the other hand, seems too weak. This is sanewhat surprising in view of its completeness. But this proves to be the case in the sense that we find it difficult to express natural intuitive arguments for the behavior of concurrent pr og rams in (ER).</region>
      <region class="DoCO:TextChunk" id="208" page="7" column="1">Obviously, we are not the first ones to face the problem of finding a minimal basis for temporal reasoning without taking the brute force approach of installing an explicit real time cIcek variable. 23 Rescher and Urquhart in their book "Temporal Logic" give a survey of different logical systems which increasingly capture more and more of the properties of time. Out of this selection we adopted a fragment of the tense logic ~, which we would like to offer here as a verification tool for temporal reasooing aboot c cncurrent programs.</region>
      <region class="DoCO:TextChunk" id="209" confidence="possible" page="7" column="1">We introduce two basic tense operators, F and G. Denoting the present by n we can describe semantically</region>
      <region class="DoCO:FigureBox" id="Fx210">
        <image class="DoCO:Figure" src="62m2.page_007.image_07.png" thmb="62m2.page_007.image_07-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="211" confidence="possible" page="7" column="2">F(p) - It will be that p·jt [t n H(t, p)] G(p) - Henceforth always p - [t n ,::,H(t, p)]</region>
      <region class="unknown" id="212" page="7" column="2">Vt ?</region>
      <region class="DoCO:TextChunk" id="213" page="7" column="2">F and G are unary operators which may be used in constructing arbitrary tense well formed formulas (tWFF' s), using also the conventional logical connectives and quantifiers. The temporal interpretation of a formula W involving no tense operators is that it holds in the present.</region>
      <region class="DoCO:TextChunk" id="214" confidence="possible" page="7" column="2">In our study of systems the absolute present is identified with So the initial state. For clarifi- cation let us c ons1der some tense formulas and their system interpretaticn:</region>
      <region class="DoCO:TextChunk" id="215" confidence="possible" page="7" column="2">p - p h olds at So</region>
      <region class="DoCO:TextChunk" id="216" confidence="possible" page="7" column="2">- if P holds at so then at a future instance q will hold.</region>
      <region class="unknown" id="217" page="7" column="2">P</region>
      <region class="DoCO:TextChunk" id="218" confidence="possible" page="7" column="2">- if P holds at So then q is invariab ly true for all states.</region>
      <region class="DoCO:TextChunk" id="219" confidence="possible" page="7" column="2">G(p ::::&gt;Fq) - Whenever p is true, it will eventually be followed by a state in which q will be true (note that this matches our noticn of eventuality)</region>
      <region class="DoCO:TextChunk" id="220" confidence="possible" page="7" column="2">G(p;:,Gq) - Whenever p is true, q will be true thereafter.</region>
      <region class="DoCO:TextChunk" id="221" confidence="possible" page="7" column="2">Our formal system contains the following axioms:</region>
      <region class="DoCO:TextChunk" id="222" confidence="possible" page="7" column="2">(GI)</region>
      <region class="DoCO:TextChunk" id="223" confidence="possible" page="7" column="2">GA 7::JA (The future inc ludes the present) (G2)</region>
      <region class="DoCO:TextChunk" id="224" confidence="possible" page="7" column="2">GA</region>
      <region class="DoCO:TextChunk" id="225" confidence="possible" page="7" column="2">(G3)</region>
      <region class="DoCO:TextChunk" id="227" confidence="possible" page="7" column="2">Where A and B are arbitrary tWFF's. By defining FA: ., G('A) we can derive the following counterparts to G2, G3: A <email id="226">:;</email>:)FA (F2) FFA :::&gt;FA (F3)</region>
      <region class="DoCO:TextChunk" id="228" confidence="possible" page="7" column="2">The following are the inference rules:</region>
      <region class="unknown" id="229" page="7" column="2">r</region>
      <region class="DoCO:TextChunk" id="230" confidence="possible" page="7" column="2">If A is a classical taUtology then A to- A Ie&gt; ~ GA (Genera lization) )-A, ~A'::)B z:&gt; t-B</region>
      <region class="DoCO:TextChunk" id="231" confidence="possible" page="7" column="2">(RT) (RG) (MP)</region>
      <region class="DoCO:TextChunk" id="232" page="7" column="2">Rule (RG) deserves special attention. It is based 00 the assumpticn of hcmogeneous development and that every statement which is provable for the present must be equa lly true in all p ossib Ie futures. As long as the only way to prove basic facts about the present is through rule (RT) this assumption is justified. However if other means of deriving facts about the present are introduced, the use of rule (RG) has to be restricted.</region>
      <region class="DoCO:TextChunk" id="233" confidence="possible" page="7" column="2">The Kb fragment introduced here differs from the one presented in [23] by several aspects:</region>
      <region class="DoCO:TextChunk" id="234" confidence="possible" page="7" column="2">1. In our presentation we consider the present as part of the future.</region>
      <region class="DoCO:TextChunk" id="236" page="7" column="2">2. While the original Kb contains primitives for events both in the future and in the past, we find it convenient and adequate to work only in terms of the future operators. Theref ore, only these operators are introduced and discussed. <marker type="block"/> 3. To the pure tense logic we have to add "domain dependent" axians, restricting the future to only</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="237" page="7" column="2">52</outsider>
      <region class="DoCO:TextChunk" id="238" confidence="possible" page="8" column="1">these developments which are consistent with the transition mechanism of the system. These will be discussed later.</region>
      <region class="DoCO:TextChunk" id="240" page="8" column="1">The keen observer woo 1d have rea lized by now tha t the system presented is completely isomorphic to the 27 23 . moda 1 logic system 54 ' • Indeed ene way of arr1V- ing at it is to give a temporal interpretation to the basic notien of modality, regarding "possible worlds" as "worlds developable in the future starting from the presen t wor ld" . In this is omorphism G stands for 0 and F f or ~. We resist full identification of the two not cnly because of typographic reasons but because we believe that the full ~ and even more powerful tense systems will have to be used for proving properties stranger than eventualities. Once one introduces possible worlds both in the past and in the future the correspondence between G and tJ fails. On the other hand in oor discussion we will fully utilize this isomorphism as exemplified in the follCMing: <marker type="block"/> Theorem 2 The system given above (pure, propositional future restricted ~ fragment) is complete (in the absolute sense) and decidable.</region>
      <region class="DoCO:TextChunk" id="241" confidence="possible" page="8" column="1">For completeness we may modify the proof in [23] showing the completeness of the full Kb. For decidability (which subsumes completeness) we may turn to known decidability results of ,3°. We even have some results an the complexity of the decidability procedure 29 .</region>
      <region class="DoCO:TextChunk" id="242" confidence="possible" page="8" column="1">Quantifiers: From the universal character of G and the existential character of F the following axioms make sense:</region>
      <region class="unknown" id="243" page="8" column="1">V (Q1)</region>
      <region class="DoCO:TextChunk" id="244" confidence="possible" page="8" column="1">(Q2) (Q3)</region>
      <region class="unknown" id="245" page="8" column="1">3</region>
      <region class="DoCO:TextChunk" id="246" confidence="possible" page="8" column="1">G( xp ) =VxG(p) F(3xp) ~ 3xF(p) F(V xp) VxF(p) x G( G('3 xp)</region>
      <region class="unknown" id="247" page="8" column="1">:::&gt; p):::&gt;</region>
      <region class="unknown" id="248" page="8" column="1">(Q4)</region>
      <region class="DoCO:TextChunk" id="249" confidence="possible" page="8" column="1">N on Pure Axi ana</region>
      <region class="DoCO:TextChunk" id="250" confidence="possible" page="8" column="1">These are additional axioms which restrict the future to be consistent with the system, and tie the reascning to the particular system or program we wish to study.</region>
      <region class="DoCO:TextChunk" id="251" confidence="possible" page="8" column="1">Invariance Axiom:</region>
      <region class="DoCO:TextChunk" id="252" confidence="possible" page="8" column="1">The first invariance axiom is identical to the invariance principle (PI):</region>
      <region class="DoCO:TextChunk" id="253" confidence="possible" page="8" column="1">p (so)</region>
      <region class="DoCO:TextChunk" id="254" confidence="possible" page="8" column="1">p(s)1\ R</region>
      <region class="DoCO:TextChunk" id="255" confidence="possible" page="8" column="1">(II)</region>
      <region class="DoCO:TextChunk" id="256" confidence="possible" page="8" column="1">)- Gp</region>
      <region class="DoCO:TextChunk" id="257" confidence="possible" page="8" column="1">The second invaraince axiom is more general and it allows us to prove invariance of q not necessarily starting from the beginning but from the first time that p becomes true, i.e. from a certain moment on.</region>
      <region class="unknown" id="258" page="8" column="1">1\ (12)</region>
      <region class="DoCO:TextChunk" id="260" confidence="possible" page="8" column="1">p.::&gt;q 9 (s) R(s, sl) :<email id="259">:;</email>:) 9 (sl) t- p :JGq</region>
      <region class="unknown" id="261" page="8" column="1">(12)</region>
      <region class="DoCO:TextChunk" id="262" confidence="possible" page="8" column="1">In fact, the more appropriate form for the con- sequence of is l- G(p "::)Gq), however in view of (RG) and (G2) the two forms are equivalent.</region>
      <region class="DoCO:TextChunk" id="263" confidence="possible" page="8" column="1">Eventuality Axiom:</region>
      <region class="DoCO:FigureBox" id="Fx264">
        <image class="DoCO:Figure" src="62m2.page_008.image_08.png" thmb="62m2.page_008.image_08-thumb.png"/>
      </region>
      <region class="unknown" id="265" page="8" column="2">1\</region>
      <region class="unknown" id="266" page="8" column="2">(E)</region>
      <region class="DoCO:TextChunk" id="267" confidence="possible" page="8" column="2">p (s) R(s, sl)::&gt;9 (sl) p:::&gt;Fq</region>
      <region class="DoCO:TextChunk" id="268" confidence="possible" page="8" column="2">This enables us to derive the most elementary eventualities, those holding across a single transition of the system.</region>
      <region class="DoCO:TextChunk" id="269" confidence="possible" page="8" column="2">Inevitability Axiom:</region>
      <region class="DoCO:TextChunk" id="270" page="8" column="2">If we intend to prove termination or accesibility we must give expression to our assumption of fair scheduling, which assures in a concurrent process that every processor will ultimately be scheduled to take a step. In order to capture this notion within the system framework we partition R II: V Ai into a I finite number of actions: [Ail. To the usual</region>
      <region class="unknown" id="271" page="8" column="2">ll=</region>
      <region class="DoCO:TextChunk" id="272" confidence="possible" page="8" column="2">definition of execution sequence we add the restriction:</region>
      <region class="unknown" id="273" page="8" column="2">FO[Jno A£ a is there an i such that</region>
      <region class="DoCO:TextChunk" id="274" confidence="possible" page="8" column="2">that</region>
      <disp-formula class="DoCO:FormulaBox" id="FR">
        <label class="DoCO:Label" id="275">R</label>
        <content class="DoCO:Formula" id="276" page="8" column="2">V j (j 3- i):::&gt; 'A(sj' Sj+l)</content>
      </disp-formula>
      <region class="DoCO:TextChunk" id="277" page="8" column="2">i.e. no acticn can be indefinitely delayed. In our model of concurrent programs, each of the actions is one of the processors taking a step. With this notation we have the following axiom reflecting the weak inevitability property:</region>
      <region class="DoCO:TextChunk" id="278" confidence="possible" page="8" column="2">(N)</region>
      <region class="DoCO:TextChunk" id="281" confidence="possible" page="8" column="2">p(s)I'R(s,sl)/\ 'A(s,sl) :<email id="279">:;</email>,p(sl) A(s, sl):<email id="280">:;</email>)9 (sl) Fq</region>
      <region class="unknown" id="282" page="8" column="2">P 1\ p::&gt;</region>
      <region class="DoCO:TextChunk" id="285" page="8" column="2">i.e. if p is invariant as long as A is not executed, and if execution of A when p is true causes q to become true, then once p is true q is inevitable (since A must eventually be executed). <marker type="block"/> A scheme of a proof in our system will consist of two separate phases. In the first phase we reason about states, immediate successors and their properties, proving all the required premises for the use of the axioms (Il),(I2),(E),(N). This phase culmin- ates in deriving a set of basic tense formulas using the domain dependent axioms. Its role is to translate all the relevant properties of the program into basic tense-logic statements. The next phase is purely tense logical (domain independent), uses only the pure rules and manipulate the basic tense logical statements into the final result.<marker type="block"/> Consider examples of utilizaticn of the axioms (I),(E),(N) under the concurrent programs context. Axiom (II) may be used to derive global invariants. Example 1 is a case in point. To verify the antecedents of (11) one has to assume that p currently hold and consider all possible one step effects of each of the processors, showing that p is preserved. A similar verification is performed in order to establish the antecedents of (E). In fact (E) is only infrequently used. This is because in analyzing a concurrent program we are either able to show invariance independently of which processor moves, or to indicate development because of the action of one specific processor. It is only rarely that we can trace development (going from p to q) independently of who moves next.</region>
      <region class="DoCO:TextChunk" id="286" confidence="possible" page="8" column="2">An example of the use of (N) is given by the following situation:</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="287" page="8" column="2">53</outsider>
      <region class="unknown" id="288" page="9" column="1">£,</region>
      <region class="DoCO:TextChunk" id="290" confidence="possible" page="9" column="1">i.e. one of the processors is currently at locaticn and is about to execute B which will cause q to becane true. We can then use (N) to establish (rr=£) <email id="289">:;</email>:) F(rr-=£ 11\ q)</region>
      <region class="DoCO:TextChunk" id="291" confidence="possible" page="9" column="1">A more intriguing case is when B is a statement depending on sane right hand side variables which in general can be altered by the other processors thus preventing q from becoming true. In same cases the only one who may alter these variables is rr itself and then we use the fact that as long as rr remain at ~ it cannot perform any alteration and hence once it moves q will be true.</region>
      <region class="unknown" id="292" page="9" column="1">(N)</region>
      <region class="DoCO:TextChunk" id="293" confidence="possible" page="9" column="1">It might be the case that p.:::&gt;t, and as long as rr does not move p remains invariant. We use then to derive that rrc~l is inevitable.</region>
      <region class="DoCO:TextChunk" id="294" confidence="possible" page="9" column="1">Theorem 3 K fragment is at least as strong as (ER) b Proof Express p ~q as p ::&gt;Fq. It is then possible to shCM that all the axians of (ER) are theorems of K fragment. b Corollary ~ fragment is relatively canplete for proving temporal implicaticns of the form p~Fq.</region>
      <region class="DoCO:TextChunk" id="295" confidence="possible" page="9" column="1">While this theoretica 1 result does not shCM any advantage of Kb over (ER), the following example may serve to show how a relatively inf erma 1 proof of eventua 1 c errectness of a c cncurrent program is naturally formalized in K • b Example 2: Consider the example of the Mutual Exc lusion prob}em presented in Fig. 1. For simpli- fication in notation we use the following abbrevia- ticns:</region>
      <region class="DoCO:TextChunk" id="296" confidence="possible" page="9" column="1">i=l, .. S</region>
      <region class="DoCO:TextChunk" id="297" confidence="possible" page="9" column="1">j= 1, .. S</region>
      <region class="unknown" id="298" page="9" column="1">i i 0 Z</region>
      <region class="DoCO:TextChunk" id="299" confidence="possible" page="9" column="1">c. -= 1, c f or c -= i=l, 1 t f or tIC 1, t for tc:2 p for 'p where p is any of the abave.</region>
      <region class="unknown" id="300" page="9" column="1">0. 1 " 1 "</region>
      <region class="unknown" id="301" page="9" column="1">c z " t</region>
      <region class="DoCO:TextChunk" id="302" confidence="possible" page="9" column="1">Po c: 8 cll\. The theorem we wc:u ld like to derive (accessibility) is: 0. ~ Fa 2 S We start by deriving the following invariants:</region>
      <region class="DoCO:TextChunk" id="303" confidence="possible" page="9" column="1">I 1: c1 "a " as</region>
      <region class="unknown" id="304" page="9" column="1">-= ct 1 Z = a "a,7"B A 8</region>
      <region class="DoCO:TextChunk" id="305" confidence="possible" page="9" column="1">8lv8ZV8S 13 : s S 7 (Their actua 1 form should be GIl' etc) All these are</region>
      <region class="DoCO:TextChunk" id="306" confidence="possible" page="9" column="1">direct consequences of (II). In particular GI 3 prOV'es mutual exc lusion.</region>
      <region class="DoCO:TextChunk" id="307" confidence="possible" page="9" column="1">In the sequel we will use stronger versions of (IZ) and (N) which can be derived from them</region>
      <region class="DoCO:FigureBox" id="Fx308">
        <image class="DoCO:Figure" src="62m2.page_009.image_09.png" thmb="62m2.page_009.image_09-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="309" confidence="possible" page="9" column="2">Pl,::)q q (s) Pz 1 ) R(s, sl):::&gt; q (sl)</region>
      <region class="unknown" id="310" page="9" column="2">1\ (8 1\</region>
      <region class="DoCO:TextChunk" id="311" confidence="possible" page="9" column="2">(DI)</region>
      <region class="DoCO:TextChunk" id="313" confidence="possible" page="9" column="2">P 1'" GPZ :<email id="312">:;</email>:) Gq</region>
      <region class="unknown" id="314" page="9" column="2">Pl(s)1\ R(s,sl) '" 'A(s,sl)" PZ(sl),:;)Pl(sl)</region>
      <disp-formula class="DoCO:FormulaBox" id="FDN">
        <label class="DoCO:Label" id="315">DN</label>
        <content class="DoCO:Formula" id="316" page="9" column="2">P1(s) 1\ A(s,sl)1\ PZ(sl)~q(sl)</content>
      </disp-formula>
      <region class="DoCO:TextChunk" id="317" confidence="possible" page="9" column="2">PlI\GpZ':)Fq</region>
      <region class="DoCO:TextChunk" id="318" confidence="possible" page="9" column="2">Lemma</region>
      <region class="unknown" id="320" page="9" column="2">A 0. 1\ t :<email id="319">:;</email>:) S 4</region>
      <region class="DoCO:TextChunk" id="321" confidence="possible" page="9" column="2">Fa</region>
      <region class="DoCO:TextChunk" id="322" confidence="possible" page="9" column="2">We use (DI) to establish (a A t) A GaS -;:)G( (a v a 4)" t) 4 3 Consider now all possible locaticns of rrZ. Consider first rrZ = 8S · By I Z 8 S ~ Cz Using (DI) again we get:</region>
      <region class="unknown" id="323" page="9" column="2">t)</region>
      <region class="DoCO:TextChunk" id="324" confidence="possible" page="9" column="2">8S "G( 3 4) " ::&gt;G8 S</region>
      <region class="DoCO:TextChunk" id="325" confidence="possible" page="9" column="2">Also</region>
      <region class="unknown" id="326" page="9" column="2">(&lt;1 v 0. GS B ::::&gt; Gc2</region>
      <region class="DoCO:TextChunk" id="327" confidence="possible" page="9" column="2">Summarizing the above we get</region>
      <region class="DoCO:TextChunk" id="328" confidence="possible" page="9" column="2">(a. 4 A t) 1\ GaS" G«0,3 v ( 1\ t" c</region>
      <region class="DoCO:TextChunk" id="329" confidence="possible" page="9" column="2">By (DN):</region>
      <region class="DoCO:TextChunk" id="330" confidence="possible" page="9" column="2">Similarly</region>
      <region class="DoCO:TextChunk" id="331" confidence="possible" page="9" column="2">Hence we can join these two together to get:</region>
      <region class="DoCO:TextChunk" id="332" confidence="possible" page="9" column="2">8 Fa</region>
      <region class="unknown" id="333" page="9" column="2">S "</region>
      <region class="unknown" id="334" page="9" column="2">S</region>
      <region class="unknown" id="335" page="9" column="2">= V 0.</region>
      <region class="DoCO:TextChunk" id="336" confidence="possible" page="9" column="2">where we denote Gl G«a3 4) " t) Similar ly we can get</region>
      <region class="DoCO:TextChunk" id="337" confidence="possible" page="9" column="2">8</region>
      <region class="unknown" id="338" page="9" column="2">S )</region>
      <region class="DoCO:TextChunk" id="339" confidence="possible" page="9" column="2">GIl' 84::&gt;F(G l " 86) And can further produce under G the chains of l temp ora 1 imp Iica t ions</region>
      <region class="DoCO:TextChunk" id="340" confidence="possible" page="9" column="2">Thus regardless of where TIZ is we derived</region>
      <region class="unknown" id="341" page="9" column="2">1\</region>
      <region class="DoCO:TextChunk" id="342" confidence="possible" page="9" column="2">(a 4 1\ t) Ga S :::&gt; Fa.S By the Lemma in the Appendix this implies:</region>
      <region class="DoCO:TextChunk" id="343" confidence="possible" page="9" column="2">4 Lemma B G[ 4</region>
      <region class="DoCO:TextChunk" id="344" confidence="possible" page="9" column="2">6 1 ]</region>
      <region class="unknown" id="346" page="9" column="2">a " t <email id="345">:;</email>:,Fa S (ct V ct V as) 1\ t =&gt; S 'IT 0.4) C z == 0 r:/ by</region>
      <region class="DoCO:TextChunk" id="347" confidence="possible" page="9" column="2">lnf orma lly: When 1 first enters and hence TIZ 8 1 . The only exit to S 1 is making tel. Lemma C</region>
      <region class="unknown" id="348" page="9" column="2">by as</region>
      <region class="DoCO:TextChunk" id="349" confidence="possible" page="9" column="2">lnf orma lly: Consider the next test of t 1T I a t (inevitable). If tel we can follow events to Ctz,a3. We then either enter as or get to a4 with</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="350" page="9" column="2">54</outsider>
      <region class="DoCO:TextChunk" id="351" confidence="possible" page="10" column="1">Henceforth by Lemma A, Fu . S If t=Z at as then ÍTZ -I 61' cl :::: 1. If ÍTZ -= B7 then later ÍTZ II: B l , t-l and remains so. Otherwise we can follow</region>
      <region class="unknown" id="352" page="10" column="1">8 6</region>
      <region class="unknown" id="353" page="10" column="1">4 B Z</region>
      <region class="unknown" id="354" page="10" column="1">2; 8 S 4 B7 as</region>
      <region class="unknown" id="355" page="10" column="1">84</region>
      <region class="DoCO:TextChunk" id="356" confidence="possible" page="10" column="1">Theorem</region>
      <region class="unknown" id="357" page="10" column="1">as</region>
      <region class="DoCO:TextChunk" id="358" confidence="possible" page="10" column="1">Follow ÍT 1 to a • If we do not arrive at we 3 get to u4 and eventually test t. If tel then by Lemma A we get to as. If tll:2 we get to as and lemma C ensures the same. 6. Finite State Systems</region>
      <region class="DoCO:TextChunk" id="359" page="10" column="1">In conclusion we will ccnsider the special case of finite state systems. For finite state systems the va lidity of eventualities (and other tense f ormu,.... las) is decidable. Furthermore many difficult syn- chronization and other concurrent programs happen to be finite state, ar are usually presented in a simpli- fied finite state form (including example 2 above).</region>
      <region class="DoCO:TextChunk" id="360" confidence="possible" page="10" column="1">Consider the case of a system whose state set is fini te. F or such a system we can c cnsider alI pr 0- perties of the states as temporal propositions p (s) (a proposition possibly varying with time or state). The values of these propositions can be evaluated for each of the states and presented in a finite table. Thus the tense formula to be proved will be a ~ positional tense formula.</region>
      <region class="DoCO:TextChunk" id="361" confidence="possible" page="10" column="1">Let E Ie &lt; S, R, so&gt; be a finite state system, where R II: Y Ai' I S I &lt; 00. We can represent E as a finite directed edge labeled graph G-= &lt; S, E&gt; whose nodes are the states of E, and there is an edge</region>
      <region class="unknown" id="362" page="10" column="1">A. 1</region>
      <region class="unknown" id="363" page="10" column="1">At</region>
      <region class="DoCO:TextChunk" id="364" confidence="possible" page="10" column="1">SI --+s2 iff (sl' s2) holds. A proper execution of E will be a path in G, starting at so' and such that if it is infinite it passes infinitely often throogh edges labeled Ai for each of the Ai. For simplicity let us aSStmle that there are no ha lting states ar deadlocks in the system so that only infinite execution paths have to be considered.</region>
      <region class="DoCO:TextChunk" id="366" confidence="possible" page="10" column="1">Theorem 4 The va lidity of an arbitrary eventuality: G(<email id="365">A:;</email>:)FB) is decidable for any finite state system E.</region>
      <region class="DoCO:TextChunk" id="367" confidence="possible" page="10" column="1">A and B here stand for arbitrary propositiooa 1 expressions, but since they will always be evaluated an states we may as well consider each to be just a single proposition, hence checking G(p~Fq) for validity.</region>
      <region class="DoCO:TextChunk" id="368" page="10" column="1">We sketch below a semantic decision procedure: Obviously, it is sufficient to verify that p ::&gt;Fq holds at each state in the graph G representing E. Also it is sufficient to cmsider cnly states s at which p(s) II: true. If also q(s) is true, the checking at s is c mc luded. Otherwise denote by Gq II: &lt; Sq' Eq &gt; the subgraph, defined by deleting all states which satisfy q. By wr assumptim s E: Sq. p::&gt;Fq will be va lid at s iff Gq c antains no infinite proper executi on sequence starting at s, because then every s execution sequence in G must run into one of the missing states, i.e. a state satisfying q.</region>
      <region class="DoCO:TextChunk" id="369" confidence="possible" page="10" column="1">To c hec k f or the exis tenc e of a pr oper pa th, de- c anp ose Sq int 0 str cngly C oonec ted c anp ooents Cl, .. Ck</region>
      <region class="DoCO:FigureBox" id="Fx370">
        <image class="DoCO:Figure" src="62m2.page_010.image_10.png" thmb="62m2.page_010.image_10-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="371" confidence="possible" page="10" column="2">where we assume that SE: Cl . We can construct a derived graph whose nodes are the Ci such that Ci + C j iff there are si E: Ci , Sj E: Cj and si + Sj in Gq . Label each of the nodes Ci by all the actions labeling edges of nodes c anprising Ci .</region>
      <region class="DoCO:TextChunk" id="374" page="10" column="2">It is not difficult to see that Gq contains an infinite proper path starting at s if and only if in the derived graph there is a path from Cl to one of the components Cm which is labeled by all the actions. <marker type="block"/> Once it has been semantically established that the temporal implication is indeed valid in the system it is not difficult to ccnstruct a formal proof in Kb fragment proving the same.<marker type="block"/> The natural extension to Theorem 4 is whether the validity of any arbitrary tense formula is also decidable on finite state systems. The answer is indeed positive. However two extensicns are needed to the logical system to be able to express the proof for a genera 1 tense formula.</region>
      <region class="DoCO:TextChunk" id="375" confidence="possible" page="10" column="2">a. The Initial State Axian: p (s 0)</region>
      <region class="unknown" id="376" page="10" column="2">(P)</region>
      <region class="unknown" id="377" page="10" column="2">t=P</region>
      <region class="DoCO:TextChunk" id="378" confidence="possible" page="10" column="2">This enables us to derive properties which are initially true.</region>
      <region class="DoCO:TextChunk" id="379" page="10" column="2">b. In view of (P) the generalization rule (RG) fails to be universally valid. Obviously any p which holds ooly initially does not necessarily hold thereafter. We thus have to modify (RG) int 0: "if ~ A then I- GA provided the pro~f of f-- A did not involve any use of axiom (P). (MRG)</region>
      <region class="DoCO:TextChunk" id="380" confidence="possible" page="10" column="2">Thus the extension of theorem 4 is:</region>
      <region class="DoCO:TextChunk" id="381" page="10" column="2">Theorem S The validity of an arbitrary tense formula on a finite state system is decidable, and the extended system Kb is adequate for proving all valid (propositicna 1) tense formulas.</region>
      <region class="DoCO:TextChunk" id="382" confidence="possible" page="10" column="2">Discussicn of possible proofs appears in Appendix B. 7. Discussion and Criticism</region>
      <region class="DoCO:TextChunk" id="387" page="10" column="2">Justifying the special system introduced here by the minimality principle (use the simplest system that will work - but no simpler), we should be the first to ask: Is the noticn of external time or temporality really needed in order to discuss intelligently and usefully the behavior of pr ograms? We hope tha t the exposition made it clear that it is not needed in order to reas en ab oot invariance properties of program. How about properties of the eventuality type? It seems clear that for deterministic, sequential structured programs, temporality is not essential. This is so because for these programs we have an internal clock, namely the execution itself. By knowing the location in the program and the values of several loop counters we can pinpoint exactly where we are in the execution. <marker type="block"/> Therefore for these programs the simple temporal notions of "bef ore" and "after" the executicn of a program segment, implicit in all the deductive systems 26 such as Hoare's and more recent ones ,2S are c anp lete ly adequa te. It is not surprising theref ore that for such programs, also the intermittent assertions method has no advantage. On the other hand<marker type="page" number="11"/><marker type="column" number="1"/><marker type="block"/> when we attack programs which are cyclic, and hence being in a location we cannot identify whether this is the first or sec end time we are there, or nondeter.... ministic, or concurrent, in which execution consist of intermixing operations for different processors, or even unstructured in which there exists a relation between the "where" and "when" but may be very c anp lex, in all of these cases we must distinguish between the "where" and "when" and maintain an external time sca Ie independent of the execution. Thus, our answer to the query above, is that as soon as we get to discuss eventuality for these more intricate type of programs, sane temporal device is necessary.<marker type="block"/> Another point that is worth mentioning is that the approach taken here can be classified together with Floyd' s9 Bursta 11' s5 (also [4] which is very c lose in spirit t~ our work). Manna and Waldinger's and McCarthy' s20 as being Endogenous approaches. By that we mean that we immerse ourselves in a single program which we regard as the universe, and concentrate on possible developments within that universe. Charact- eristic of this approach is the first phase which translates the programming features into general rules of behavior which we later logica lly ana lyze. This is in contrast with Exogenoos approaches such as Hoare's, Pratt's, Constables' and other deductive systems. These suggest a uniform formalism which deals in formulas whose constituents are both logical assertions and program segments, and can express very rich relations between programs and assertions. We will be the first to admit the many advantages of Exogenous systems over Endogencus systems. These inc lude among others:</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="385" page="10" column="2">55</outsider>
      <region class="DoCO:TextChunk" id="388" confidence="possible" page="11" column="1">a. The uniform formalism is more elegant and universa 1, richer in expressibility, no need for the two phase process of Endogencus systems. b. Endogenous systems live within a single program. There is no way to canpare two programs such as proving equivalence or inclu- sion. c. Endogenous systems assume the program to be rigidly given, Exogenous systems provide tools and guidance for constructing a correct system rather than just analyse an existent ene.</region>
      <region class="DoCO:TextChunk" id="389" page="11" column="1">Against these advantages endogenous system can offer the following single line of defense: When the going is tough, and we are interested in proving a single intricate and difficult program, we do not care about generality)uniformity or equivalence. It is then advantageous to work with a fixed context rather than carry a varying context with each statement. Under these conditions, endogenoos systems attempt to equip the prover with the strongest possible tools to formalize his intuitive thinking and ease his way to a rigorous proof.</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="390" confidence="possible" page="11" column="1">References:</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref class="deo:BibliographicReference" id="391" confidence="possible" page="11" column="1">1.</ref>
          <ref rid="R1" class="deo:BibliographicReference" id="392" confidence="possible" page="11" column="1">Aschroft E.A. and Manna Z (1970): "Formali- zation of Properties of Parallel Programs,"</ref>
          <ref class="deo:BibliographicReference" id="393" confidence="possible" page="11" column="1">2.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="394" confidence="possible" page="11" column="1">Machine Intelligence 6, Edinburgh University Press. Aschroft E.A. (1975): "Proving Assertions</ref>
          <ref class="deo:BibliographicReference" id="395" confidence="possible" page="11" column="1">About Parallel Programs," JCSS 10(1) 11</ref>
          <ref class="deo:BibliographicReference" id="396" confidence="possible" page="11" column="1">3.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="397" confidence="possible" page="11" column="1">Aschroft E.A. and Wadge, W.W: "Intermittent Assertion Proofs in Lucid," IFIP, Toronto 1977.</ref>
          <ref class="deo:BibliographicReference" id="399" confidence="possible" page="11" column="1">Burstall, R.M.: "Formal Description of Program Structure and Semantics of First Order</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="401" confidence="possible" page="11" column="2">Logie" in B. Meltzer &amp; D. Michie (eds.) Machine Intelligence 5 (1970) 79-98, Edinburgh.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="402" confidence="possible" page="11" column="2">5. Burstall, R.M. (1974): "Program Proving as Hand Simulation With A Little Induction," Information Processing, 1974, North Holland Publishing Company, Amsterdam, 308-312.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="403" confidence="possible" page="11" column="2">6. Hoare, C.A.R. (1969): "An Axianatic Basis Of Ccmputer Programming", CACM 12 (10) .</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="404" confidence="possible" page="11" column="2">7. Hoare, C.A. R. (1970): "Procedures and Para- meters: An Axianatic Approach", in Engeler (Ed.) Lecture Notes in Mathematics 188, Springer Verlag.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="405" confidence="possible" page="11" column="2">8. Hoare, C. A. R. (1972): "Towards a The ory of Parallel Programming", in Hoare, C.A.R, Perrot, R.H. (Eds.): Operating Systems Techniques, New York Academic Press.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="406" confidence="possible" page="11" column="2">9. Floyd, R.W.: "Assigning Meanings to Programs," Proc. Symp. Appl. Math. 19, in J.T. Schwartz (ed.) Mathematical Aspects of Computer Science, pp. 19-32, 1967.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="407" confidence="possible" page="11" column="2">10. - Francez, N.: "The Analysis of Cyclic Programs," Ph.D. thesis, Weizmann Institute of Science, Rehovot, Israel 1976.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="408" confidence="possible" page="11" column="2">11. - Francez, N. and Pnueli, A: "A Proof Method For Cyclic Programs," Proceedings of the 1976 Conference en Parallel Processing, 235-245.</ref>
          <ref class="deo:BibliographicReference" id="409" confidence="possible" page="11" column="2">12. - Francez, N. and Pnueli, A.: "Proving Properties of Parallel Programs by Gleba 1 Invariants," to appear.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="410" confidence="possible" page="11" column="2">13. - Keller, R.M.: "Formal Verification of Pr ograms," CACM 19 (7) 1976.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="411" confidence="possible" page="11" column="2">14. - Kroger, F.: "Logical Rules of Natural Reasm- ing Aboot Programs," Third Intern. Symposium on Autanata, Languages and Progrannning, Edinburgh, Edinburgh University Press, 1976, 87-98.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="412" confidence="possible" page="11" column="2">15. - KrOger, F: "A Uniform Logical Basis For The Description, Specification and Correctness Proof Techniques of Programs". Institute fur Informatik der Technischen Universitat Munchen. 16. - Lamport, L (1976): "Proving the Correctness of Multiprocess Program," Massachusetts Canputer Associates, Inc. Mass. 01880.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="413" confidence="possible" page="11" column="2">17. - Manna Z: "Mathematical Theory of Canputation," MCGraw-Hill (1974).</ref>
          <ref class="deo:BibliographicReference" id="414" confidence="possible" page="11" column="2">18. - Manna Z. and Pnueli, A: "Axianatic Approach to Total Correctness," Acta Informatica 3, 243- 263.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="415" confidence="possible" page="11" column="2">19. - Manna Z. and Waldinger, R: "Is "scmetime" sanetimes better than "always"? Intermittent assertions in proving Program Correctness. Proc. 2nd International Ccnference on Software Engineering, San Francisco (Calif.) 1976, 32- 39.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="416" confidence="possible" page="11" column="2">20. - McCarthy, J., Hayes, P.J: "Sane Philosophic Problems from the Standpoint of Artificial Intelligence" in B. Meltzer and D. Michie (eds.) Machine Intelligence 4 (1969) 463-502, Edinburgh.</ref>
          <ref class="deo:BibliographicReference" id="418" confidence="possible" page="12" column="1">21.</ref>
          <ref class="deo:BibliographicReference" id="419" confidence="possible" page="12" column="1">Owicki, S. and Gries, D.: "An Axianatic Pr oof Technique for Paralle 1 Pr ograms I ", Acta Informatica 6,319-339.</ref>
          <ref class="deo:BibliographicReference" id="420" confidence="possible" page="12" column="1">22.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="421" confidence="possible" page="12" column="1">Owicki, S. and Gries, D: "Verifying Properties of Parallel Programs: An Axianatic Approach", CACM 19(5) 1976, 279-284.</ref>
          <ref class="deo:BibliographicReference" id="422" confidence="possible" page="12" column="1">23.</ref>
          <ref class="deo:BibliographicReference" id="423" confidence="possible" page="12" column="1">Rescher, N. and Urquhart, A: "Temporal</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="424" confidence="possible" page="12" column="1">Logic," Springer Ver lag 1971.</ref>
          <ref class="deo:BibliographicReference" id="425" confidence="possible" page="12" column="1">24.</ref>
          <ref class="deo:BibliographicReference" id="426" confidence="possible" page="12" column="1">25.</ref>
          <ref class="deo:BibliographicReference" id="427" confidence="possible" page="12" column="1">26.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="428" confidence="possible" page="12" column="1">Schwarz, J: "Event Based Reasoning - A System for Proving Correct Termination of Programs". Research Report No. 12, Dept. of Artificial Intelligence, University of Edinburgh, Edinburgh, Sc ot land. Sites, R. L.: "Proving that Computer Programs Terminate Cleanly," Stanford University, Technical Report, May 1974. Constable, R. L: "On the Theory of Program-</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="429" confidence="possible" page="12" column="1">ming Logic," Pr oc. of the 9th Anr.. ua 1 Symposium on Theory of Canputing, Boulder, Colorado, May 1977.</ref>
          <ref class="deo:BibliographicReference" id="430" confidence="possible" page="12" column="1">27.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="431" confidence="possible" page="12" column="1">Hughes, G.E. and Creswell, M.J: "An Introduction to Modal Logic," London: Methuen and Co. Ltd, 1972.</ref>
          <ref class="deo:BibliographicReference" id="432" confidence="possible" page="12" column="1">28.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="433" confidence="possible" page="12" column="1">Hare1, D., Meyer, A.R. and Pratt, V.R: "Canputability and Canpleteness in Logics of Programs," Proc. of the 9th Annual Symp. on Theory of Canputing, BroIder, Colorado, May 1977.</ref>
          <ref class="deo:BibliographicReference" id="434" confidence="possible" page="12" column="1">29.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="435" confidence="possible" page="12" column="1">Fischer M. J. and Ladner, R. E.: "Prope- sitionai Modal Logic of Programs," Proc. of the 9th Annua 1 Symp. en The ory of Canputing, Boulder, Colorado, May 1977.</ref>
          <ref class="deo:BibliographicReference" id="436" confidence="possible" page="12" column="1">30.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="437" confidence="possible" page="12" column="1">Kripke, S. A. : "Semantica 1 Ana lysis of Modal Logic I: Normal Modal Propositional Calculi," Zeitschr. f. Math. Logik und Grundlagen d. Math. 9 (1963) pp. 67-96.</ref>
          <ref class="deo:BibliographicReference" id="439" confidence="possible" page="12" column="1">Appendix A Derived Rules and Theorems of Kb : The following are theorems proved in [23]: T2 Gp " Fq ::&gt;F (p 1\ q) Corollary Gp 1\ Fq ::::&gt; F(Gp " q) T3 F(p vq) ::&gt;Fp V Fq Cor 0 lla ry G p 1\ G q <email id="438">:;</email>) G(p ,\ q) Lennna: pI\G(,q)::&gt;Fq=&gt; p,:::)Fq</ref>
          <ref class="deo:BibliographicReference" id="440" confidence="possible" page="12" column="1">Pr oof: 1. f- p " G(' q) --:::&gt; Fq Ass. 2. Fq v, Fq Tau. 3. Fq v G(' q) by F's definition. 4. p" Fq :&gt;Fq Tau.</ref>
          <ref class="deo:BibliographicReference" id="442" confidence="possible" page="12" column="2">6. p Fq</ref>
          <ref class="deo:BibliographicReference" id="443" confidence="possible" page="12" column="2">3,5</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="444" confidence="possible" page="12" column="2">Appendix B Discussien of the proof of Theorem 5 Theorem 5 may be proved by reduction of the problem of validity of propositicnal tense formula en a finite state system to that of the validity of a formula in the Monaaic Secend Order Theory of Successor . This is dane by reintroducing explicit time variables. Referring to the definitions and results of [31] , there is a decision algorithm f or the va lidity of f ormu la s in th is the ory • Alternately, it is possible to recenstruct the pr oof f or our spec ia 1 ca se : We first Observe that for a given finite state system l: it is possible to censtruct a finite state autanaton Al: which will accept exactly those infinite sequences sO,sl' •.• which form a proper execution sequences of l:. Denote the language of infinite words def ined by Al: by L (Al:) S; SW • We then sh ow tha t f or each propositiona 1 tense formula W , we can ccnstruct an w-regular 32 language L(W) which describes all th ose SW sequences m which W is true . This c cnstructicn is defined inductive ly by the rules: L(p)-=(s 1 + •. +s ) SW where sl' ••• sm are thWse states out of S m which p is true • L(,W)= SW-L(W) L (WI" W 2) = L (W1) Il L (W2 ) L(W I V W 2 )II::L(W 1) u L(W 2 ) L(FW)ICS*L(W) L(GW)-=L(" F I W) Since the family of w-regular languages is closed under all the operaticns used abooe , this gives an effective way toe mstruct L(W) . Our decision prob lem reduces then to the question: is L(Al:) ~ L(W) i.e. do all proper execution sequences of l: satisfy W ? • This problem is known to be decidable for w- regular languages 33 31. - Biichi,J.R. :"On a Decisicn Method in Restricted Seccnd Order Arithmetic" , International Congress on Logic Methodology and Philosophy of Science, Stanf ord , Ca lif ornia (1960) .</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="445" confidence="possible" page="12" column="2">32. - McNaughton,R •.: "Testing and Generating Infinite Sequences by a finite Autanatm" , Information and Control 9 (1966) 521-530 •</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="446" confidence="possible" page="12" column="2">33. - Landweber , t .. H. : "Decisicn Prob lems for w- Aut ana ta " , Ma thema tica 1 Systems The ory 3 (1969) 376-384 •</ref>
        </ref-list>
        <region class="unknown" id="398" page="11" column="1">4.</region>
        <region class="DoCO:FigureBox" id="Fx400">
          <image class="DoCO:Figure" src="62m2.page_011.image_11.png" thmb="62m2.page_011.image_11-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="417" page="11" column="2">S6</outsider>
        <region class="DoCO:FigureBox" id="Fx441">
          <image class="DoCO:Figure" src="62m2.page_012.image_12.png" thmb="62m2.page_012.image_12-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="447" page="12" column="2">5. t- p f\ (Fq v G( ., q»:::&gt; Fq 1,4</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="448" page="12" column="2">57</outsider>
      </section>
    </body>
  </article>
</pdfx>
