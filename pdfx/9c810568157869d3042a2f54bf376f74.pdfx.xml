<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>ffc46c21c66d599a6165f10604fa6ba85bd4dbc30ec04bd89669f62341857c25</job>
    <base_name>62bi</base_name>
    <doi>http://dx.doi.org/10.1007/978-1-4302-0179-3</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">EXTREME PROGRAMMING Extreme programming without fear</article-title>
      </title-group>
      <region class="unknown" id="2">By Dan Pierce Principal Engineer Electronic Systems Products</region>
      <abstract class="DoCO:Abstract" id="3" confidence="possible">Have you ever had a heated debate with a colleague about whether eX- treme Programming (XP)—the most popular of agile methodologies—is a good fit for embedded programming? XP, agile, and indeed the whole topic of software process can be controversial because participants often have deep feelings, beliefs, and prejudices, which proves the topic is consequential to our craft. Open-minded objectivity, however, can be hard to come by and discussions about this topic can get very intense very fast—all of which is quite fulfilling and even fun as long as everyone is respectful and mind- ful of their manners.</abstract>
      <region class="unknown" id="4">Embedded reality</region>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="13" page="1" column="1">There are no degrees in embedded programming. We became embedded systems programmers because of interest or need. Further, only recently embedded systems programs have become large enough to routinely require more than one developer. Historically, the majority of embedded systems were developed by one developer who learned programming second hand. We were islands who had each read exactly one book about C. This culture was problematic when projects became large and complex and required a team of programmers to produce the code in a timely manner. Simple things that PC-applications developers had been using for years, such as version control, object- So here’s my methodical at- oriented techniques, partitioning, tempt to guide you through and so on, were now essential if the controversial question: Is XP the embedded world was going suitable for embedded systems to evolve. Embedded firmware programming? I find XP a useful has always lagged behind appli- method if it’s adapted properly cation software development in to fit the realities of embedded this way. Note that it’s still fairly systems programming. Let’s easy to find an embedded devel- look at those realities and then oper who prefers assembly! examine if the main XP ac- It’s no surprise then that as tivities—planning, designing, application developers immerse coding, and testing—are com- themselves in implementing patible with embedded systems and debating the new agile programming. or lightweight methodologies, some embedded systems programmers are still debating the Embedded systems program- merits of C versus C++. Thus the ming has specific characteristics discussion on how agile might you should keep in mind when fit into the embedded world has applying the practices of XP. For really not begun in earnest. various reasons, XP is only now We started discussing this at becoming the buzz around water my company almost two years coolers frequented by embed- ago, and we now have enough ded systems developers. First of battle scars and experience to all, when the software effort on provide a few insights. embedded systems went from In the interest of full disclosure an afterthought to the critical let it be said that we’re now pro- path practically overnight, the ponents of agile methodologies methodologies in place (in other and believe it has great potential words, no methodology) and the in this field. We decided that an management de-emphasis on article describing how XP might its importance was a situation fit into an embedded environ- ripe for disaster. Most embedded ment, specifically our embedded developers, including myself, systems environment, might be were trained in some other field, helpful to others trying to find usually electrical engineering. their way through the debate. <marker type="column" number="2"/><marker type="block"/> So, let’s examine the four main The iterative principle is sim- XP activities (planning, design, ple. The project is broken up into coding, and testing) and see if small, meaningful subprojects they’re compatible with embed- where all the activities are per- ded systems programming. formed: planning, design, code, and test. This gets working, bug- Planning free software into the hands of “Do only the planning you need the customer as early as possible for the next horizon—At any so that the clarity of vision that given level of detail, only plan to can only come from watching the the next horizon —that is, the code run is available soon. The next release, the end of the next operative word here is feedback. iteration,” Kent Beck, Extreme Feedback with actual working Programming Explained, p. 85. 1 code that represents a subset of XPers and agile proponents the system is obtained early and believe that project require- regularly on an XP project. ments are the most fluid part of The customer should be en- any project. Gathering require- couraged to use this feedback ments is considered a regular to refine and verify his vision and and periodic activity that’s done thus the requirements. The devel- throughout the project. opers also become an important Traditional process models, on source of insight as they begin the other hand, gather and freeze to see the system take shape. requirements at the beginning of This technique exploits the fact a project. Afterwards, engineers that software is soft. That is, soft- treat changes to requirements ware is relatively easy to change as unhealthy disruptions and (when written properly). indications of incomplete work However, in the embedded in previous phases. In contrast, world it’s common to develop the XPer assumes it’s impractical the hardware along with the soft- to discern a complete and ac- ware. Remember, XP evolved in curate set of requirements in an the context of personal computer isolated first phase of a project. applications where the hardware (Many studies of software proj- and associated device drivers are ects strongly back up this claim; a given. So with great caution two are mentioned at the end we must discern the difference of this article.) 2,3 What is needed, between a hardware requirement then, is a process that allows the and a software requirement. complete and accurate set of Hardware requirements are requirements to emerge as the very difficult to change at a later project proceeds. date. For example, if the platform This brings up an important requires sound, and you place feature of XP and all other agile a buzzer on the board, the cus- methodologies—their iterative tomer can’t change his mind to nature. Iteration is one of the something more sophisticated most powerful features of agile such as modulating tones be- and should be implemented cause the equipment for this is immediately by everyone who not on the board. So the cus- writes software even if you tomer must think this require- adopt nothing else. Software ment through ahead of time. process models that are found- Once the customer has chosen ed on an iterative or evolution- the hardware capabilities, XP ary approach are now literally dictates that the particular everywhere, including all of the requirements for the sounds agile methodologies (www. themselves should be put off agilealliance.com), the Rational until we can hear something and Unified Process, and the Microsoft the customer can sit with us to Solutions Framework. get the sounds just right.<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> Another edict of XP maintains and opted not to use interrupts. that you should prioritise itera- I noted clearly in the code where I tions in the order of criticality, that disabled interrupts for this device is, develop the most critical items and stubbed out an interrupt ser- first. Quite often in embedded vice routine function with a note systems development, this results that if interrupts are needed, this in a lot of “bottom up” coding. For function needed to be written. various good reasons, you almost Well-designed embedded always have to develop some of firmware has a clear demarcation the device drivers first. Here are between application-layer code some of those good reasons: and hardware-specific code. For • The real-time requirements example, the application should of the system depend almost call an abstracted function to completely on the perfor- turn on an LED; it need not nor mance of these drivers, and should not know how this is the team is most worried actually accomplished. However, about meeting these require- this technique is ripe for abuse ments. by those who tend towards over • Never-used-before hardware design. Great diligence is needed that's present in the system by managers and developers to (such as EEPROMs or LCD dis- keep this type of layering simple plays) needs to be verified so and easy to understand. that the hardware design can The first mistake that’s made is be blessed for production. to put in several layers where only • The rigorous testing required one is needed. For example, an by XP will require some input over-designer might put in a dis- and output to the system play manager that manages the (more on this later). LCD (using a driver) and the LEDs (using another driver). Now the Designing application is two steps removed “We will continually refine the de- from control of the LEDs. This sign of the system, starting from additional complexity provides a very simple beginning. We will almost no clarity and burdens the remove any flexibility that doesn’t system with extra code. Layering, prove useful,” Kent Beck, Extreme partitioning, encapsulating, and Programming Explained, p. 103. 1 abstracting are all vital to high- In the design phases, XP strives quality code, but it’s easy to get for a just-in-time approach that too much of a good thing. stresses simplicity and clarity. Besides, requirements aren’t Further, XP maintains that we the only aspect of the system should design and code for today that’s expected to evolve as the and not tomorrow. Kent Beck cor- XP project progresses. The code rectly observes that this is one of design will evolve as well. Evolv- the hardest principles for pro- ing from a simple design to some- grammers to learn. When faced thing more complex is much with writing a device driver, a easier and natural than evolving lot of programmers try to write from an overly complex system a driver that can be used by any- to something simpler. Further, in one who ever uses this device. the former case it is much more This lofty goal is expensive in likely that the final design will be terms of up-front development closer to optimal. The phrase that cost, code size, and probably XP says should drive the designer code performance. This invest- is “What’s the simplest thing that ment only pays off if the driver could possibly work?” is used on another project in a Finally, I’m amazed at how different way at a later time. often an operating system is The embedded systems de- thrown into an embedded sys- veloper should instead opt for tem without engineers first per- clear code with obvious hooks forming an accurate cost-versus- on how to generalise later. For benefit analysis. XP maintains example, I recently wrote a serial that any additional code in the peripheral interface port driver system has a cost and burden<marker type="column" number="2"/><marker type="block"/> associated with it that’s prob- best feedback there is. Why wait? ably greater than you think. An Remember, untested code is operating system is generally a practically worthless. lot of additional code. Also, many Even after the real hardware operating systems are feature rich is available, a smart strategy is and flexible. Complexity, size, and to maintain a dual platform ap- cost are always greater with this proach where the code can type of product. Make sure your always be run on a known, good system needs such an operating platform (simulator or evalu- system. Engineers opt for the ation board) and also the real powerful operating system think- hardware. This can be invaluable ing that they’re covered for any in isolating hardware problems eventuality. The reality often is from software problems. they’re burdened with a monster One of XP’s more controversial whose documentation rivals the requirements is pair program- New York City white pages. ming. I find the main critics of In sum, include the simplest pair programming usually haven’t operating system you can. If a tried it with an open mind. The simple foreground/background world of embedded systems design will do, by all means use programming, however, pres- that instead. ents interesting challenges. A lot of embedded projects only Coding need one or two programmers. “We will carefully craft a solution In these cases, it’s hard to re- for today’s problem today, and quire pair programming for all trust that we will be able to solve code development. Still, you can tomorrow’s problem tomorrow,” make good compromises that Kent Beck, Extreme Programming let you take advantage of pair Explained, p. 97. 1 programming. For example, in XP dictates that code de- the case of a single developer, velopment begin as soon as pair programming with another possible. The embedded de- developer on another project veloper, however, must often can be a regularly scheduled wait for hardware. Most teams activity. This same developer in this situation opt just to write can then help other develop- code and compile it. I think this ers by pair programming with is a grave mistake. Compilers them. Strict XPers might balk at routinely come with simulators this compromise, but, as stated for the processors they support, earlier, this is a controversial and these can provide a great topic. All in all, we’ve found avenue for an early, productive that productivity gains from pair start to coding. Even if the simu- programming are significant and lator is US$1,000 extra, get it. I’ve can’t be ignored. never known this investment to Another XP cornerstone for fail to pay off. Simulators usu- coding is to integrate often. This ally provide a way to get data works as well in embedded sys- into and out of the simulated tems development as anywhere environment so you can test else. Most programmers under- with real data. They also provide estimate how long integration ways to measure execution time takes—often by a lot. By inte- so you can check performance grating often the programmers constraints. understand sooner and get If a simulator isn’t available, constant reminders of how time get an evaluation board. Virtu- consuming this activity can be. ally all embedded processors Then they can use this lesson have evaluation boards avail- to more accurately schedule the able for sale. Even if the hard- next subproject. ware folks are telling you that Finally, XP proscribes that test you’ll only have to wait two code be written first—before the weeks for working hardware code it will test. Though this is a (HA!), buy it. The feedback that noble and worthwhile goal, non- comes from testing code is the compliance with this principle<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> is high. Like pair programming, Some of the test scripts can meeting this goal requires a lot and should coexist with the of discipline in an engineering code. However, another draw- organisation. back of embedded systems is the limited memory for code Testing space. It’s simply not possible “We will write tests before we in many cases to have elaborate code, minute by minute. We will test scenarios stored with the preserve these tests forever, and code image. What to do? run them all together frequently. We’ve come up with what we We will also derive tests from the believe is a simple and elegant customer’s perspective,” Kent solution to this problem. Almost Beck, Extreme Programming every embedded system has (or Explained, p. 115. 1 can have) an RS-232 serial port. The XP mantra here is strict. This is by far the most common All code is verified through auto- interface to embedded targets. A mated unit testing that’s kept up serial port is also stable, simple, to date all the time. Further, all and cheap. Further, every PC the unit tests must run at a 100% comes with at least one serial pass rate all the time. port. Many PC-based programs The embedded systems arena for serial ports provide a way to presents special challenges write scripts where canned mes- when trying to abide by this sages are sent out the serial port standard. XP was developed and responses are gathered. You in a field where display de- can compare these responses to vices and hard disks are a the expected responses and dis- given; such components are cern and display pass/fail results. extremely useful, if not essen- You can also transfer binary files. tial, to automated unit testing. With this test platform, a lot of The hard disc is used to store the sophistication and size of scripts and test results. The the test code can be offloaded display is useful as a unit test to the PC in the form of easy to interface to report problems read test scripts. and results. The fact is, most We prefer human readable embedded applications don’t (ASCII) messages be passed back have a hard disc and many don’t and forth over the serial port. For have any display device at all. example “START MEMORY TEST”<marker type="column" number="2"/><marker type="block"/> could be sent to the target and (such as serial EEPROMs) that will a reply such as “MEMORY TEST: be present on the final system. FAILED AT ADDRESS 12345” could be sent back. For com- plicated algorithmic-based We have found that both the XP systems (for example, image techniques and the principles processing), you could send underlying those techniques a raw binary file to the device are sound. To fit properly into for processing and have the the embedded systems domain, results sent back for storage, however, XP requires some d i s p l a y , a n d a u t o m a t i c so tweaking. You’ll find that it’s a you can compare them with a tenet of XP to expect to tailor the known correct answer. process for the peculiarities of When we implemented this each environment. Such tweak- technique, we found it very ing is relatively straightforward, powerful and believe it satisfies so developers can use XP on em- both the XP requirements and bedded systems and still achieve the spirit of those requirements. XP’s overall goals. On all future designs, we’re rec- ommending a dedicated serial Footnotes port just for this purpose. Note 1. Beck, Kent. Extreme Program- that a simple 3-pin header plus ming Explained: Embrace some inexpensive silicon is all Change, Boston, MA: Addison that’s required. Wesley/Pearson Education, Another good way to unit test 2000. is to use a simulator. I mentioned 2. Jones, Capers. Applied Soft- this previously as a way to get a ware Measurement, Assuring quick start writing and testing Productivity and Quality, New code. Simulators are made to run York, NY: McGraw Hill, 1997. on platforms such as Windows 3. Larman, Craig. Agile and and almost always provide simu- Iterative Development: A lated I/O. Rigorous unit testing is Manager’s Guide, Boston, greatly facilitated since the host MA: Addison Wesley/Pearson machine has the necessary pe- Education, 2003, pp 72-74. ripherals (hard disc, display) built in. However, you’ll not be able to test with the peripheral hardware Email Send inquiry</region>
      <outsider class="DoCO:TextBox" type="footer" id="7" page="1" column="2">EE Times-India | March 2004 | eetindia.com</outsider>
      <outsider class="DoCO:TextBox" type="footer" id="10" page="2" column="2">eetindia.com | March 2004 | EE Times-India</outsider>
      <region class="unknown" id="12" page="3" column="2">XP is A-OK</region>
      <region class="DoCO:FigureBox" id="Fx14">
        <image class="DoCO:Figure" src="62bi.page_003.image_01.png" thmb="62bi.page_003.image_01-thumb.png"/>
        <image class="DoCO:Figure" src="62bi.page_003.image_02.png" thmb="62bi.page_003.image_02-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="footer" id="15" page="3" column="2">EE Times-India | March 2004 | eetindia.com</outsider>
      <outsider class="DoCO:TextBox" type="footer" id="16" page="4" column="2">eetindia.com | March 2004 | EE Times-India</outsider>
      <outsider class="DoCO:TextBox" type="footer" id="17" page="5" column="2">EE Times-India | March 2004 | eetindia.com</outsider>
    </body>
  </article>
</pdfx>
