<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>4220ac861662878b09b2ea80e9ecff127f19d2a4d4d369bda20c3a25ef4ebe22</job>
    <base_name>62gt</base_name>
    <doi confidence="possible" alt_doi="http://dx.doi.org/10.1007/978-3-642-79898-6_12">http://dx.doi.org/10.1016/0026-2714(83)90381-5</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">The Costs and Benefits of Pair Programming</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="2">Alistair Cockburn</name>
        </contrib>
      </contrib-group>
      <region class="DoCO:TextChunk" id="5" confidence="possible">Humans and Technology 7691 Dell Rd Salt Lake City, UT 84121, USA <email id="3">arc@acm.org</email> 801.947.9277 “Only if the various principles - names, definitions, intimations and perceptions - are laboriously tested and rubbed one against the other in a reconciliatory tone, without ill will during the discussion, only then will insight and reason radiate forth in each case, and achieve what is for man the highest possible force...” -Plato “Knowledge is commonly socially constructed, through collaborative efforts toward shared objectives or by dialogues and challenges brought about by differences in persons' perspectives." -Salomon [<xref ref-type="bibr" rid="R1" id="4" class="deo:Reference">1</xref>] ABSTRACT</region>
      <abstract class="DoCO:Abstract" id="6" confidence="possible">Pair or collaborative programming is where two programmers develop software side by side at one computer. Using interviews and controlled experiments, the authors investigated the costs and benefits of pair programming. They found that for a development-time cost of about 15%, pair programming improves design quality, reduces defects, reduces staffing risk, enhances technical skills, improves team communications and is considered more enjoyable at statistically significant levels.</abstract>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="12">Laurie Williams</name>
        </contrib>
      </contrib-group>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="7" page="1" column="1">Keywords pair programming, collaborative programming, extreme programming, code reviews, people factors, collaborative programming</region>
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="8" page="1" column="1">1 INTRODUCTION</h1>
      </section>
      <region class="DoCO:TextChunk" id="11" page="1" column="1">When pair programming, two programmers work collaboratively on the same algorithm, design or programming task, sitting side by side at one computer. This practice has been nominated several times in the last decades as an improved way of developing software [<xref ref-type="bibr" rid="R2" id="9" class="deo:Reference">2</xref>] [<xref ref-type="bibr" rid="R3" id="10" class="deo:Reference">3</xref>].</region>
      <region class="DoCO:TextChunk" id="14" confidence="possible" page="1" column="2">University of Utah Computer Science 50 S. Central Campus #3190 Salt Lake City, UT 84112, USA <email id="13">lwilliam@cs.utah.edu</email> 435.649.7931</region>
      <region class="DoCO:TextChunk" id="18" page="1" column="2">However, convention speaks against having two people work together to develop code -- having “two do the work of one”, as some people see it. • Managers view programmers as a scarce resource, and are reluctant to "waste" such by doubling the number of people needed to develop a piece of code. • Programming has traditionally been taught and practiced as a solitary activity. • Many experienced programmers are very reluctant to program with another person. Some say their code is "personal," or that another person would only slow them down. Others say working with a partner will cause trouble coordinating work times or code versions. At the same time: • Several well-respected programmers prefer working in pairs, making it their preferred programming style [<xref ref-type="bibr" rid="R2" id="15" class="deo:Reference">2</xref>] [<xref ref-type="bibr" rid="R3" id="16" class="deo:Reference">3</xref>]. • Seasoned pair programmers describe working in pairs as "more than twice as fast" [<xref ref-type="bibr" rid="R3" id="17" class="deo:Reference">3</xref>]. • Qualitative evidence suggests the resulting design is better, resulting in simpler code, easier to extend. • Even relative novices contribute to an expert's programming, according to interviews. This raises some provocative questions. Is pair programming really more effective than solo programming? What are the economics? What about the people factor - enjoyment on the job? Based on recent interest in pair programming, the authors examined interview and experimental data to understand the costs and benefits of practice. This paper presents the results of that</region>
      <region class="DoCO:TextChunk" id="19" confidence="possible" page="1" column="2">Page 1</region>
      <region class="DoCO:TextChunk" id="23" page="2" column="1">investigation. Previous publications [<xref ref-type="bibr" rid="R4" id="20" class="deo:Reference">4</xref>] [<xref ref-type="bibr" rid="R5" id="21" class="deo:Reference">5</xref>] [<xref ref-type="bibr" rid="R6" id="22" class="deo:Reference">6</xref>] have demonstrated that pair programming is beneficial. The purpose of this paper is to re- examine these results and to further explain why pair programming is beneficial.</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="24" page="2" column="1">2 A PROJECT EXPERIENCE</h1>
        <region class="DoCO:TextChunk" id="25" page="2" column="1">The following excerpt comes from an experienced programmer describing his organization’s first venture into pair programming. It reveals many features of the pair programming experience, as will be discussed in this paper. In early December my team began a high-risk activity: it involved touching just about every file, merging the code together, and trying to keep everything working. Furthermore, one tree involved fairly deep rearchitecture. So the merge would be composed of both utter tedium and massive thought effort. The staff agreed with my points that pair programming: - Should significantly reduce the risk of subtle errors that would make debugging excruciating; - Would give us a much broader code review than we'd ever had; and - Would provide an opportunity to communicate knowledge between coders. For the first few weeks, things didn't work out as envisioned. Instead of doing side-by-side pair programming, the first few people did what I called "partner programming": they coded individually for awhile, and then reviewed the changes with their partner before checking-in the modifications. They reported that they were catching errors early. This was encouraging, but I was disappointed that they weren't working together consistently. But about four months into the merge, I began to notice that things were changing. One pair in particular spent their whole day together, doing honest-to-goodness pair programming, and the other two pairs were getting much closer to that ideal. In discussions it was clear that they knew why the change was happening. It simply worked better! They discovered that it took longer to work independently and then review the changes, since the review process involved teaching your partner everything you had learned in making the changes. And that took almost as long as making the changes to begin with. By working together they could avoid "doing it twice", the coding went faster due to the two-brain effect, and they were much</region>
        <region class="unknown" id="26" page="2" column="2">more confident in the correctness of the results. When we finally made it to the first checkpoint application, we zoomed through QA with hardly a hitch. Everyone, myself included, was amazed that it didn't take weeks to debug, especially given that one of the trees had recently spent SIX WEEKS in QA hell. It was obvious that the pairs had dramatically reduced the defect rate. As the merge progressed the pairs worked together even more closely. ... As each subsystem was complete the pairs would get rearranged based on knowledge of the next task. This slowed things down because the new pairs would have to spend time getting in phase with one another before working effectively. But by August the pairs were fairly well cemented, to the point where they would routinely speak for each other in our twice-weekly team meetings. Subsequent releases, both internal and external, went smoothly and we rarely hit massive show- stopper bugs. The continual review caught many serious issues midstream, including some major design problems that hadn't been noticed before. I wasn't involved in a pair until fairly late in the game. Once my partner and I synchronized our brains, it was a great experience. He was relatively junior, but he asked the right questions and, by struggling for answers, we usually forced ourselves to discover the best solution to each problem. ... The team members decided to do it for themselves. None of my pontification had as much effect as experience.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="27" page="2" column="2">3 INVESTIGATIVE PATHS</h1>
        <region class="DoCO:TextChunk" id="30" page="2" column="2">We explore eight paths of software engineering and organizational effectiveness. Surprisingly, all paths point to pair programming. These investigative paths are briefly described: Economics. A recent controlled experiment [<xref ref-type="bibr" rid="R4" id="28" class="deo:Reference">4</xref>] found only a small development cost for adding the second person. However, the resulting code also had fewer defects. The defect removal savings should more than offsets the development cost increase. Satisfaction. People working in pairs found the experience more enjoyable than working alone. Design quality. The study [<xref ref-type="bibr" rid="R4" id="29" class="deo:Reference">4</xref>] also found that the pairs produced shorter programs than their solo peers, indicating superior designs. Interviewees</region>
        <region class="DoCO:TextChunk" id="31" confidence="possible" page="2" column="2">Page 2</region>
        <region class="DoCO:TextChunk" id="32" page="3" column="1">made the same comments. Continuous Reviews. Pair programming’s shoulder-to-shoulder technique serves as a continual design and code review, leading to most efficient defect removal rates. Problem solving. Interview participants constantly refer to the team's ability to solve "impossible" problems faster. Learning. Pair programmers repeatedly cite how much they learn from each other. Team Building and Communication. Interview participants describe that people learn to discuss and work together. This improves team communication and effectiveness. Staff and Project Management. Since multiple people have familiarity with each piece of code, pair programming reduces staff-loss risk. In this paper, each of these investigative paths will be further discussed -- reviewing the supporting statistical and interview data and highlighting the costs and the benefits.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="33" page="3" column="1">4 ECONOMICS</h1>
        <region class="DoCO:TextChunk" id="49" page="3" column="1">The affordability of pair programming is a key issue. If it is much more expensive, managers simply will not permit it. Skeptics assume that incorporating pair programming will double code development expenses and critical manpower needs. Along with code development costs, however, other expenses, such as quality assurance and field support costs must also be considered. IBM reported spending about $250 million repairing and reinstalling fixes to 30,000 customer-reported problems [ <xref ref-type="bibr" rid="R7" id="34" class="deo:Reference">7</xref>]. That is over $8,000 for each defect! In 1999, a controlled experiment run by the second author at the University of Utah investigated the economics of pair programming. Advanced undergraduates in a Software Engineering course participated in the experiment. One third of the class coded class projects as they had for years – by themselves. The rest of the class completed their projects with a collaborative partner. The results of how much time the students spent on the assignments are shown below in <xref ref-type="fig" rid="F1" id="35" class="deo:Reference">Figure 1</xref>. After the initial adjustment period in the first program (the<marker type="column" number="2"/><marker type="block"/> “jelling” assignment), together the pairs only spent about 15% more time on the program than the individuals [<xref ref-type="bibr" rid="R4" id="37" class="deo:Reference">4</xref>]. Development costs certainly do not double with pair programming!<marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> 70% of these defects. Therefore, the individuals would be expected to have 1,500 defects remaining in their program; collaborators would have 15% less or 1,275 – 225 less defects. In some organizations, developers’ code is passed to a test or quality assurance department, which finds and fixes many of the remaining defects. Typically, in systems test it takes between four [<xref ref-type="bibr" rid="R7" id="46" class="deo:Reference">7</xref>] and 16 [<xref ref-type="bibr" rid="R8" id="47" class="deo:Reference">8</xref>] hours per defect. Using a fairly conservative factor of 10 hours/defect, if testing finds these “extra” 225 defects they will spend 2,250 hours – fifteen times more than the collaborators “extra” 150 hours! If the program is sent directly to a customer instead of a test department, pair programming is even more favorable. Industry data reports that between 33 and 88 hours are spent on each defect found in the field [<xref ref-type="bibr" rid="R7" id="48" class="deo:Reference">7</xref>]. Using a fairly conservative factor of 40 hours/defect, if the customer is plagued by these “extra” 225 defects, field support will spend 9,000 hours – sixty times more than the collaborators “extra” time! Doubtlessly, pair programming can be justified on purely economic grounds. But there are more aspects to consider.</region>
        <region class="unknown" id="39" page="3" column="2">Relative Time: One Individual vs Two Collaborators 200.0% 150.0% 100.0% 50.0% 0.0% Program 1 Program 2 Program 3 One Individual Two Collaborators</region>
        <region class="DoCO:FigureBox" id="F1">
          <caption class="deo:Caption" id="42" page="3" column="2">Figure 1: Programmer Time Significantly, the resulting code has about 15% fewer defects [<xref ref-type="bibr" rid="R4" id="40" class="deo:Reference">4</xref>]. (These results are statistically significant.) <xref ref-type="fig" rid="F2" id="41" class="deo:Reference">Figure 2</xref> shows the post- development test cases the students passed for each program – essentially the percentage of the instructor’s test cases passed.</caption>
        </region>
        <region class="unknown" id="43" page="3" column="2">Post Development Test Cases Passed 100.0% 80.0% 60.0% 40.0% 20.0% 0.0% Program 1 Program 2 Program 3 Individuals Collaborators</region>
        <region class="DoCO:FigureBox" id="F2">
          <caption class="deo:Caption" id="45" page="3" column="2">Figure 2: Code Defects The initial 15% increase in code development expense is recovered in the reduction in defects, as the following example illustrates. Let a program of 50,000 lines of code (LOC) be developed by a group of individual programmers and by a group of collaborative programmers. At a typical rate of 50 LOC/hour, the individuals will develop this code in 1000 hours. It will take the pairs 15% longer or 1150 hours -- a cost of 150 hours. Based on representative statistics reported in [<xref ref-type="bibr" rid="R7" id="44" class="deo:Reference">7</xref>], programmers inject 100 defects per thousand lines of code. A thorough development process removes approximately Page 3</caption>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="50" page="4" column="1">5 SATISFACTION</h1>
        <region class="DoCO:TextChunk" id="52" page="4" column="1">If pair programming is not satisfying, programmers won't practice it. Many programmers are initially skeptical, even resistant, to programming with a partner. It takes the conditioned solitary programmer out of their “comfort zone.” One programmer wrote, “The adjustment period from solo programming to collaborative programming was like eating a hot pepper. The first time you try it, you might not like it because you are not used to it. However, the more you eat it, the more you like it.” In statistically significant results, pair programming teams who had earlier programmed alone reported that they enjoyed pair programming more and that they were more confident in their programs than when they programmed alone (as the defect rates show they are entitled to be). The graph (<xref ref-type="fig" rid="F3" id="51" class="deo:Reference">Figure 3</xref>) shows results of anonymous surveys of professional pair programmers and of student pair programmers at the University of Utah. Most of the programmers</region>
        <region class="DoCO:TextChunk" id="53" confidence="possible" page="4" column="2">enjoyed programming collaboratively. ENJOY the work more because of Pair Programming 100% 80% 60% 40% 20% 0% F 1 2 3 1 2 3 O M M M LL LL LL PR SU SU SU FA FA FA Agree Disagree</region>
        <region class="DoCO:FigureBox" id="F3">
          <caption class="deo:Caption" id="54" page="4" column="2">Figure 3: Pair Enjoyment A programmer comments, “It is psychologically soothing to be sure that that no major mistakes had been made . . . I find it reassuring to know that [partner] is constantly reviewing my code while I drive. I can be sure I had done a good job if someone else I trust had been watching and approved.”</caption>
        </region>
        <region class="DoCO:TextChunk" id="55" page="4" column="2">Another says, “It’s nice to celebrate with somebody when something works.” Students prefer the 15% overhead In the study previously discussed, the class was divided into two groups: an “individual” group in which solo programmers did all programming, and a “collaborative” group in which all programming was done in pairs. Each programming assignment cycle, the individuals were given one program to complete while the pairs were given two programs to complete. After several programming cycles, one pair complained that this arrangement was unfair. They felt they had to work harder than the individuals during each cycle. The instructor suggested that the students split up and work as solo programmers as part of the “individual” group so the would no longer feel they were being unjustly overworked. Both students rejected this offer almost instantaneously. They did not complain about the "unjustness" of the additional workload again. We feel that this is a strong indicator of the satisfaction of pair programming.</region>
        <region class="DoCO:TextChunk" id="56" confidence="possible" page="4" column="2">Page 4</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="57" page="5" column="1">6 DESIGN QUALITY</h1>
        <region class="DoCO:TextChunk" id="73" page="5" column="1">The following comments came from a team lead who had never heard of pair programming. He described why all of his designer-programmers working together at the same terminal. As we proceeded with our work, I started to notice that one team consistently produced designs of distinctly better quality than the others. I asked them about this. They said that they had taken to working together, on both the design and the programming. They found that their designs and programs were better this way. I agreed with them and made it standard for all teams to work in pairs. The design quality is now better. [from the interview files of A. Cockburn] In 1991 Nick Flor, a masters student of Cognitive Science, reported on distributed cognition in a collaborative programming pair he studied. Distributed cognition is a field of cognitive science based on the belief that “Anyone who has closely observed the practices of cognition is struck by the fact that the “mind” rarely works alone. The intelligences revealed through these practices are distributed – across minds, persons, and the symbolic and physical environment [ <xref ref-type="bibr" rid="R1" id="58" class="deo:Reference">1</xref>].” Flor recorded via video and audiotape the exchanges of two programmers working together on a software maintenance task. In [<xref ref-type="bibr" rid="R9" id="59" class="deo:Reference">9</xref>], he correlated specific verbal and non-verbal behaviors of the two under study with known distributed cognition theories. One of these theories is “Searching Through Larger Spaces of Alternatives.” “A system with multiple actors possesses greater potential for the generation of more diverse plans for at least three reasons: (1) the actors bring different prior experiences to the task; (2) they may have different access to task relevant information; (3) they stand in different relationships to the problem by virtue of their functional roles. . . An important consequence of the attempt to share goals and plans is that when they are in conflict, the programmers must overtly negotiate a shared course of action. In doing so, they explore a larger number of alternatives than a single programmer alone might do. This reduces the chances of selecting a bad plan. [<xref ref-type="bibr" rid="R9" id="60" class="deo:Reference">9</xref>]" A pair programmer's description matches Flor’s: We often came up with different ideas about how<marker type="column" number="2"/><marker type="block"/> the design should go and the result of arguing over which one was better often led to a truly superior hybrid design. In the quantitative study at the University of Utah, the pairs not only completed their programs with superior quality, but they consistently implemented the same functionality as the individuals in fewer lines of code. Details are shown in <xref ref-type="fig" rid="F4" id="62" class="deo:Reference">Figure 4</xref>. We believe this is an indication that the pairs had better designs.<marker type="block"/> The theory on why inspections are effective is based on the prominent knowledge that the earlier a defect is found in a product, the cheaper it is to fix the defect. Many sources, including [<xref ref-type="bibr" rid="R8" id="68" class="deo:Reference">8</xref>] state that it is ten times more expensive to remove a defect for each additional process step. This exponential cost growth is easy to understand. During an inspection, a programmer might say, “The 'if' statement starting on line 450 Page 5<marker type="page" number="6"/><marker type="column" number="1"/><marker type="block"/> should also have an 'else' clause.” The programmer marks the listing and promptly makes the change at their computer. However, if the software is already in the field, a customer makes an irate call to the software shop, “It’s Christmas Eve, and all of my cash registers just crashed. I can’t sell anything!” In the first case, the programmer looks directly at the problem that was just identified to them. In the second case, the field maintenance team must work to translate the symptom (all the cash registered crashed) back to the problem (which exact line(s) of code caused the crash). It is easy to see why the translation of the symptom back to the problem costs exponentially more than direct problem identification. With pair programming, this problem identification occurs on a minute- by-minute basis. These continual reviews not only outperform formal reviews in their defect removal speed, but they also eliminate the programmer’s distaste for reviews. The following, sardonically worded description from a senior (originally skeptical) programmer shows how pairing with even a novice contributed to his programming. I was sitting with one of the least-experienced developers, working on some fairly straightforward task. Frankly, I was thinking to myself that with my great skill in Smalltalk, I would soon be teaching this young programmer how it’s really done. We hadn’t been programming more than a few minutes when the youngster asked me why I was doing what I was doing. Sure enough, I was off on a bad track. I went another way. Then the whippersnapper reminded me of the correct method name for whatever I was mistyping at the time. Pretty soon, he was suggesting what I should do next, meanwhile calling out my every formatting error and syntax mistake. [-Ron Jeffries, from [<xref ref-type="bibr" rid="R4" id="70" class="deo:Reference">4</xref>]] A final benefit of code reviews is that reviewers learn new coding idioms and language features, as well as more about the system. The continuous reviews of collaborative programming create a unique educational capability, whereby the pairs are endlessly learning from each other. “Indeed, review has a unique educational capability: The process of analyzing and critiquing software artifacts produced by others is a potent method for learning about languages,<marker type="column" number="2"/><marker type="block"/> design techniques, application domains, and so forth. [<xref ref-type="bibr" rid="R11" id="72" class="deo:Reference">11</xref>].” In keeping with the known characteristics of code reviews, we find practitioners citing: • Mistakes are found as they are entered, saving even the cost of compilation, and providing the economic benefit of early defect identification and removal. • Coding standards are followed more accurately with the peer pressure to do so. • Team members learn to talk together and work together.</region>
        <region class="unknown" id="64" page="5" column="2">Lines of Code 120.0% 100.0% 80.0% 60.0% 40.0% 20.0% 0.0% Program 1 Program 2 Program 3 Individuals Collaborators</region>
        <region class="DoCO:FigureBox" id="F4">
          <caption class="deo:Caption" id="67" page="5" column="2">Figure 4 7 CONTINUOUS REVIEWS Inspections were introduced more than twenty years ago as a cost-effective means of detecting and removing defects from software. Results [<xref ref-type="bibr" rid="R10" id="65" class="deo:Reference">10</xref>] from empirical studies consistently profess the effectiveness of reviews. Even still, most programmers do not find inspections enjoyable or satisfying. As a result, inspections are often not done if not mandated, and many inspections are held with unprepared inspectors. “Despite a consistent stream of positive findings over 20 years, industry adoption of inspection appears to remain quite low, although no definite data exists. For example, an informal USENET survey we conducted found that 80% of 90 respondents practiced inspection irregularly or not at all. [<xref ref-type="bibr" rid="R11" id="66" class="deo:Reference">11</xref>]”</caption>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="74" page="6" column="2">8 PROBLEM SOLVING</h1>
        <region class="DoCO:TextChunk" id="75" page="6" column="2">There were times we felt that we would have given up except that we “tag teamed.” I’d be on the ropes and I’d describe the problem in such a way that he had a valuable insight. Then he’d fight on as long as he could and stop . . . then I’d have an insight . . . and so on. I suppose others would call it brainstorming, but it feels different to me. [-David Wagstaff, Salt Lake City] Pair relaying is our name for the effect Wagstaff describes. Indeed, pairs consistently report that they solve problems faster, and that it is different from improving design quality, or detecting typing errors, or brainstorming. By "problem solving", we refer to when the two are puzzled as to why something doesn't work as expected, or simply can't figure out how to go forward. In interviews and in off-hand remarks, practitioners describe contributing their knowledge to the best of their abilities, in turn. They share their knowledge and energy (and also brainstorming) in turn, chipping steadily away at the problem. Combining brainstorming and pair relaying is powerful. One seasoned programmer wrote, I have found that, after working with a partner, if I go back to working alone, it is like part of my mind is gone. I find myself getting confused about things.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="76" page="6" column="2">9 LEARNING</h1>
        <region class="DoCO:TextChunk" id="77" page="6" column="2">Knowledge is constantly being passed between partners, from tool usage tips (even the mouse), to programming language rules, design and programming idioms, and overall design skill. Learning happens in a very tight apprenticeship</region>
        <region class="DoCO:TextChunk" id="78" confidence="possible" page="6" column="2">Page 6</region>
        <region class="DoCO:TextChunk" id="81" page="7" column="1">mode. The partners take turns being the teacher and the taught, from moment to moment. Even unspoken skills and habits cross partners. Line of sight learning in apprenticeships [ <xref ref-type="bibr" rid="R12" id="79" class="deo:Reference">12</xref>] discusses apprenticeship case studies. These studies range from tailors to flag signalmen in the U.S. Navy to butchers in modern supermarkets. The book is subtitled "legitimate peripheral participation" to highlight three key aspects of apprenticeship: that the novice actively participates; that the novice have legitimate work to do; and that the novice works on the periphery, steadily moving toward some higher rank. The novice's work is initially simple and non-critical. Later work is more critical. One of the most distinctive characteristics they note of successful apprenticeship environments is that the novice work in a "line of sight" of the expert, that expertise is transmitted, in part, through the ongoing visual (and auditory) field. They describe successful apprenticeship learning in both tailors and Navy signalmen where “line of sight” is available. The beginner explicitly picks up skills from hearing and/or seeing the expert. The most interesting of the case studies, for this discussion, is that of the butchers in supermarkets. They did not have line of sight access to their local expert. The beginners were given simple cuts to perform, but did not have a way to learn how to do more difficult cuts, which were being done by the senior butcher in another room. Lave and Wenger present this as a situation in which apprenticeship learning does not happen. It should be obvious that most project programming environments match the butcher situation, not the tailor or signalmen situation. Indeed, we have found it extremely difficult to set up programming environments in which line- of-sight and line-of-hearing from expert to novice can be accommodated. The novice programmer generally sits in their workspace working on simple code; the expert sits in their own workspace creating complex code and making architectural decisions. Pair programming makes a better apprenticeship situation.<marker type="column" number="2"/><marker type="block"/> Expert In Earshot The first author obtained a project management pattern from a set of workshops with 10 senior project managers. The full pattern, listed in the Appendix, includes examples and caveats; it is summarized as: Use Expert In Earshot when novices are not learning good techniques and habits very well, but you don't want to turn the expert into a full-time teacher. Put the expert or leader in the same workspace as the more novice workers, so that the novices can learn by watching and listening, while the expert does his or her usual work. Novices will pick up expertise and (hopefully good) habits from the expert. (Your expert will be disturbed more often, so you will have to set up ways to create personal quiet time.) Note the overlap with the apprenticeship studies. It is significant that this pattern had to be accepted by all 10 senior project managers, since they were going to apply it within their company. Pair programming is an example of both Expert In Earshot and of legitimate peripheral participation, with line-of-sight/hearing access. We can expect, therefore, that the learning that occurs in pair programming is more significant than merely learning new tool usage or programming language idioms. This expectation matches off-hand reports from practitioners. Statistical confirmation Pair programming was used exclusively in a web programming class at the University of Utah, taught by the second author. The class consisted of 20 juniors and seniors, familiar with programming, but not with web programming languages and tools. The majority of the students had only used WYSIWYG web page editors prior to taking the class. During the eleven-week semester, the students learned advanced HTML, JavaScript, VBScript, Active Server Page Scripting, Microsoft Access/SQL and some ActiveX commands. In many cases, they had to intertwine statements from all these languages in one program listing. Unusual for such students, they produced their programs with minimal questions of the teaching staff. The students were queried about the reasons for their independence in an anonymous</region>
        <region class="DoCO:TextChunk" id="82" confidence="possible" page="7" column="2">Page 7</region>
        <region class="DoCO:TextChunk" id="83" page="8" column="1">survey on the last day of class. • 74% wrote “between my partner and me, we could figure everything out.” • 84% of the class agreed with the statement “I learned Active Server Pages faster and better because I was always working with a partner.” We would attribute part of that result to enhanced problem solving in pairs, as described above, and part to enhanced pair learning.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="84" page="8" column="1">10 TEAM BUILDING&amp;COMMUNICATION</h1>
        <region class="unknown" id="85" page="8" column="1">When I arrived, I saw a disheartening sight: Bill didn't have a team; he had a random collection of six bright, talented individuals who didn't work together. They didn't sit near each other. They didn't even like each other. Here is a scene from a weekly staff meeting 'Let's talk about pair programming. (benefits of pair programming enumerated) &lt;pause&gt; Therefore, pair programming is mandatory. All production code must be written with a partner present.' &lt;An awkward silence descends. Furtive eye glances are exchanged.&gt; 'I don't think that's going to work. What if I need to write code and my partner isn't available?' 'Then you find someone else. One of our goals is to spread the knowledge around.' 'What if there's no-one else around?' 'If I'm available, I'd be glad to work with you. If there really is nobody around, push your keyboard away and wait.' &lt;Stunned silence &gt; Some of the first paired sessions went smoothly. Other sessions were awkward. Communication was serial and parsimonious. I handheld these guys by becoming a third wheel. I encouraged the developers to think out loud (what Ward Cunningham calls reflective articulation). This did the trick. They actually began to work together, not just take turns coding. After about a week, I noticed a remarkable phenomenon. The developers were talking to each other. As people. You really would have to have been there at the beginning to appreciate this. Anyway, I noticed them having real conversations. And laughing. They actually began to enjoy and trust each other. Within several weeks, they became a real team." [from the interview files of A. Cockburn]</region>
        <region class="DoCO:TextChunk" id="92" page="8" column="2">The Psychology of Computer Programming [<xref ref-type="bibr" rid="R13" id="86" class="deo:Reference">13</xref>] and Peopleware [<xref ref-type="bibr" rid="R14" id="87" class="deo:Reference">14</xref>], written 20 and 30 years ago, respectively, still have not been replaced on the topic of teamwork. More recently, eXtreme Programming [<xref ref-type="bibr" rid="R2" id="88" class="deo:Reference">2</xref>], the Crystal Light methodologies [<xref ref-type="bibr" rid="R15" id="89" class="deo:Reference">15</xref>] and Adaptive Software Engineering [<xref ref-type="bibr" rid="R16" id="90" class="deo:Reference">16</xref>] have strengthened attention given to team building and communication. In [<xref ref-type="bibr" rid="R17" id="91" class="deo:Reference">17</xref>], Cockburn goes farther, and argues that these are first-order project drivers, not side issues. Pair programming contributes in three ways. People learn to work together, as illustrated in the above quote. In the University of Utah study, none of the 14 pairs ran into an insurmountable personality clash. In industry, off-hand comments indicate personality clashes occasionally happen, perhaps because there is not sufficient pressure or motivation for the people to learn to work together. Interviews with people who have persevered, however, reveal a pattern similar to, but not as extreme as the one above. Often, by having to work together, people learn to work together. Learning to work together means that the people on the team will share both problems and solutions more quickly, and be less likely to have hidden agendas from each other. Teamwork is enhanced. If the pair can work together, then they learn ways to communicate more easily and they communicate more often. This raises the communication bandwidth and frequency within the project, increasing overall information flow within the team. Rotating partners increases the overall information flow farther. All of these are likely to increase team effectiveness, and, indeed, this is what pair programming teams report. We know of no statistical study of these effects.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="93" page="8" column="2">11 STAFF &amp; PROJECT MANAGEMENT</h1>
        <region class="DoCO:TextChunk" id="95" page="8" column="2">Project management benefits from improved staff skills and reduced staff risk. The company and the project team both benefit from the increased learning. Over the course of the project, the skills of the team members increase, in programming and in software design. Page 8 <marker type="page" number="9"/><marker type="column" number="1"/><marker type="block"/> The risk from losing key programmers is reduced, because there are multiple people familiar with each part of the system. This is referred to as the "truck number" in some circles: "How many or few people would have to be hit by a truck (or quit) before the project is incapacitated?" The worst answer is "one." Having knowledge dispersed across the team increases the truck number, and project safety.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="96" page="9" column="1">12 SUMMARY</h1>
        <region class="DoCO:TextChunk" id="97" page="9" column="1">The significant benefits of pair programming are that • many mistakes get caught as they are being typed in rather than in QA test or in the field (continuous code reviews); • the end defect content is statistically lower (continuous code reviews); • the designs are better and code length shorter (ongoing brainstorming and pair relaying); • the team solves problems faster (pair relaying); • the people learn significantly more, about the system and about software development (line- of-sight learning); • the project ends up with multiple people understanding each piece of the system; • the people learn to work together and talk more often together, giving better information flow and team dynamics; • people enjoy their work more. The development cost for these benefits is not the 100% that might be expected, but is approximately 15%. This is repaid in shorter and less expensive testing, quality assurance, and field support.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="98" page="9" column="1">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="99" page="9" column="1">1. Salomon, G., Distributed Cognitions: Psychological and educational considerations. Learning in doing: Social, cognitive, and computational perspectives, ed. R. Pea and J.S. Brown. 1993, Cambridge: Cambridge University Press.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="100" page="9" column="1">2. Constantine, L.L., Constantine on Peopleware. Yourdon Press Computing Series, ed. E. Yourdon. 1995, Englewood Cliffs, NJ: Yourdon Press.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="102" page="9" column="1">3. Beck, K., Extreme Programming Explained: Embrace Change. 2000, Reading, Massachusetts: Addison- <marker type="column" number="2"/><marker type="block"/> Wesley.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="104" page="9" column="2">4. Williams, L., et al., Strengthening the Case for Pair- Programming, in IEEE Software. submitted to IEEE Software. Online at <ext-link ext-link-type="uri" href="http://www.cs.utah.edu/" id="103">http://www.cs.utah.edu/</ext-link>~lwilliam/Papers/ieeeSoftware. PDF</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="106" page="9" column="2">5. Williams, L.A. and R.R. Kessler. The Collaborative Software Process. in International Conference on Software Engineering 2000. submitted for consideration. Limerick, Ireland. Online at <ext-link ext-link-type="uri" href="http://www.cs.utah.edu/" id="105">http://www.cs.utah.edu/</ext-link>~lwilliam/Papers/ICSE.pdf</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="107" page="9" column="2">6. Nosek, J.T., The Case for Collaborative Programming, in Communications of the ACM. 1998. p. 105-108.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="108" page="9" column="2">7. Humphrey, W.S., A Discipline for Software Engineering. SEI Series in Software Engineering, ed. P. Freeman, Musa, John. 1995: Addison Wesley Longman, Inc.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="109" page="9" column="2">8. Humphrey, W.S., Introduction to the Personal Software Process. 1997: Addison-Wesley.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="110" page="9" column="2">9. Flor, N.V. and E.L. Hutchins. Analyzing Distributed Cognition in Software Teams: A Case Study of Team Programming During Perfective Software Maintenance. in Empirical Studies of Programmers: Fourth Workshop. 1991: Ablex Publishing Corporation.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="111" page="9" column="2">10. Fagan, M.E., Advances in software inspections to reduce errors in program development. IBM Systems Journal, 1976. 15: p. 182-211.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="112" page="9" column="2">11. Johnson, P.M., Reengineering Inspection: The Future of Formal Technical Review, in Communications of the ACM. 1998. p. 49-52.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="113" page="9" column="2">12. Lave, J. and E. Wenger, Situated Learning: Legitimate peripheral participation. 1991, New York, NY: Cambridge University Press.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="114" page="9" column="2">13. Weinberg, G.M., The Psychology of Computer Programming Silver Anniversary Edition. 1998, New York: Dorset House Publishing.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="115" page="9" column="2">14. DeMarco, T. and T. Lister, Peopleware. 1977, New York: Dorset House Publishers.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="117" page="9" column="2">15. Cockburn, A., Crystal "Clear": A human-powered software development methodology for small teams, Addison-Wesley, 2001, in preparation. Online at <ext-link ext-link-type="uri" href="http://members.aol.com/humansandt/crystal/clear." id="116">http://members.aol.com/humansandt/crystal/clear.</ext-link></ref>
          <ref rid="R16" class="deo:BibliographicReference" id="118" page="9" column="2">16. Highsmith, J., Adaptive Software Development, Dorset House, 1999.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="120" page="9" column="2">17. Cockburn, A., Characterizing People as Non-Linear, First-Order Components in Software Development, in International Conference on Software Engineering 2000. submitted for consideration. Limerick, Ireland.. Online as Humans and Technology Technical Report, TR 99.05, <ext-link ext-link-type="uri" href="http://members.aol.com/humansandt/" id="119">http://members.aol.com/humansandt/</ext-link> papers/ nonlinear/nonlinear.htm. Page 9</ref>
        </ref-list>
        <region class="unknown" id="121" page="10" column="2">Page 10</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="122" page="11" column="1">APPENDIX: THE</h1>
        <region class="unknown" id="123" page="11" column="1">"EXPERT IN EARSHOT"</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="124" page="11" column="1">PROJECT MANAGEMENT PATTERN</h1>
        <region class="DoCO:TextChunk" id="127" confidence="possible" page="11" column="1">(slightly abbreviated from <ext-link ext-link-type="uri" href="http://members.aol.com/humansandt/papers/expertinearshot.htm)" id="125">http://members.aol.com/humansandt/papers/expertinearshot.htm)</ext-link> Thumbnail Novices have a hard time developing good habits on their own, so... Keep an expert within their hearing distance. Indications (1) Novices are not learning good techniques and habits very well. (2) Working on the same project, your experts have private offices and your novices use a shared workspace. Counter (1) Regulations prevent putting expert and novices in a shared workspace. indications (2) The expert has poor communication skills or work habits you don’t want replicated! (3) The expert spends most of her or his time in activities that would disturb the work of any novices within earshot, such as talking on the phone about other matters. Forces (1) You need everyone to get work done, both expert and novices. (2) You want the novices to learn, and the expert has good habits worth learning. (3) You can afford for the expert to be disturbed a bit more if the novices will learn some good habits. But... (1) You don't want to turn the expert into a full-time teacher. (2) People hesitate to disturb the boss or expert with a phone call or knock on the door. Do This Put the expert or leader in the same workspace as the more novice workers, so that the novices can learn by watching and listening, while the expert does his or her usual work. Resulting (1) Novices will pick up expertise and (hopefully good) habits from the expert. Context (2) Your expert will be disturbed more often, so you or he or she will have to set up ways or conventions to create personal quiet time. (3) You and the expert have to watch that the novices do not simply delegate their problems to the expert. (4) You will have more people in the room. Overdose (1) Too many questions will lower the expert’s productivity too much. Effect (2) Too many people in the same room will create too many conversations, making it hard to concentrate. Related Training:Day Care says "Your experts are spending all their time mentoring novices, so ... Put one expert in Patterns charge of all the novices; let the others develop the system.") [CoSOOP]. This covers the dangers of having the expert try to teach while designing. In Expert In Earshot, the expert is not responsible for teaching the novices. The situation is only set up so that the novices can see and hear how the expert works, in accordance with the principles. [<xref ref-type="bibr" rid="R15" id="126" class="deo:Reference">15</xref>] Pair Programming is a non-conflicting possible partner pattern to Expert In Earshot. It can be used to bring an expert within earshot of one person (the other person in the pair), or of many people - all the rest of the people in the workspace. Examples (1) When Thomas J. Watson, Jr., ex-CEO of IBM, went from being an aviator and playboy to a serious businessman, his father, then CEO of IBM, assigned him to sit at the corner of the senior-VP's desk for six months. For those six months, he was to do nothing but watch and listen to how this successful executive ordered his days and handled people. This is an unusual but very clear example of Expert In Earshot. (2) A team leader given four junior designers to design a graphics workstation, was also given a private office. After a few weeks, he felt uncomfortable with the distance to his team, and moved his desk to the floor with the other designers. Although the distractions were great and his main focus was not teaching the other designers, he was able to discuss with them on a timely and casual basis. They became more capable, eventually reducing the time he had to spend with them and giving them skills for their next project. (3) The lead programmer worked in a room with six novice programmers. He had two bad habits: he scoffed at the idea of doing design in an orderly way, and instead of talking to the other programmers about how to make a good design or program, he would change their code in the middle of the night. They never knew in the morning if their program was the same as when they left it. After several months, the novices both produced bad designs and refused to design carefully. His heroic attitude had become their ideal. When he left the project, another consultant took his place, also sharing the room. He deliberately discussed designs from his desk, so the others could overhear. After a few months, three of the novices started talking and drawing designs, and soon became skilled in designing as well as programming.</region>
        <region class="unknown" id="128" page="11" column="2">Page 11</region>
      </section>
    </body>
  </article>
</pdfx>
