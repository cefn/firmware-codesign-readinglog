<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>66d22f4e5a5db49b3c49d5983c45fb4f4beeee599e97de4dcadca4db6a804cb5</job>
    <base_name>62sn</base_name>
    <doi>http://dx.doi.org/10.1007/s10270-004-0067-9</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">Softw Syst Model (2005) 4: 71–93 / Digital Object Identifier (DOI) 10.1007/s10270-004-0067-9</outsider>
      <title-group>
        <article-title class="DoCO:Title" id="2">From scenarios to code: An air traffic control case study</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="3">Jon Whittle</name>
          <aff id="4">1</aff>
        </contrib>
        <contrib contrib-type="author">
          <name id="5">Richard Kwan</name>
          <aff id="6">2</aff>
        </contrib>
        <contrib contrib-type="author">
          <name id="7">Jyoti Saboo</name>
          <aff id="8">1</aff>
        </contrib>
      </contrib-group>
      <footnote class="DoCO:Footnote" id="11">1 QSS Group Inc./NASA Ames Research Center, Moffett Field, CA 94035, USA; e-mail: <email id="9">{jonathw,jsaboo}@email.arc.nasa.gov</email> 2 Aerospace Computing Inc./ NASA Ames Research Center, Moffett Field, CA 94035, USA; e-mail: <email id="10">rkwan@mail.arc.nasa.gov</email> Received: 30 June 2003/Accepted: 12 May 2004</footnote>
      <region class="DoCO:TextChunk" id="12" confidence="possible">Published online: 10 November 2004 –  Springer-Verlag 2004</region>
      <abstract class="DoCO:Abstract" id="13">There has been much recent interest in synthesis algorithms that generate finite state machines from scenarios of intended system behavior. One of the uses of such algorithms is in the transition from requirements scenarios to design. Despite much theoretical work on the nature of these algorithms, there has been very little work on applying the algorithms to practical applications. In this paper, we apply the Whittle &amp; Schumann synthesis algorithm [32] to a component of an air traffic advisory system under development at NASA Ames Research Center. We not only apply the algorithm to generate state machine designs from scenarios but also show how to generate code from the generated state machines using existing commercial code generation tools. The results demon- strate the possibility of generating application code directly from scenarios of system behavior. Keywords: Code generation – Software modeling – Scenario – State machine – Case study Communicated by Connie Heitmeyer</abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="14" page="1" column="1">1 Introduction</h1>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="48" page="2" column="2">1.1 Scope</h2>
          <region class="DoCO:TextChunk" id="53" page="2" column="2">The case study presented in this paper offers evidence that s2s-algorithms may be effectively used to generate code from scenario-based descriptions. The case study is, however, only one example. The following points should be noted when deciding if the s2s-algorithm could be applied to other examples. Currently, s2s-algorithms can be applied to event- driven specifications in which functionality is described in terms of scenarios. If the required functionality is not given in this form, it is still possible to use the algorithms but an appropriate scenario-based description would need to be developed first. In this paper, the application is to generate code (by way of state machines) from a scenario-based specification. The scenarios in the case study are a complete and well-defined description of the functionality. Hence, it is possible to generate code directly. The authors understand that it may not be common for a scenario-based description to be complete enough to generate meaningful code. However, the case study should be taken as the first step towards showing the feasibility of s2s-algorithms, not the final word on the subject. We expect that the algorithms could also be applied in the case that a partial <marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> set of possibly inconsistent scenarios is available, but that a process for generalizing/refining those scenarios before code generation would be necessary. The definition of such a process is the subject of current research and is outside the scope of this paper. Another characteristic of this particular example which may not be true in general is that the scenarios include definitions of high-level states of the system (see <xref ref-type="fig" rid="F8" id="52" class="deo:Reference">Fig. 8</xref> in Sect. 3). This characteristic makes synthesis easier and leads to state machines more in tune with the developer’s intentions, but is not required for successful application of the algorithm. More will be said about this in the Conclusions.</region>
          <outsider class="DoCO:TextBox" type="header" id="50" page="3" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="51" page="3" column="1">73</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="54" page="3" column="1">1.2 Overview of results</h2>
          <region class="DoCO:TextChunk" id="56" page="3" column="1">The objective of this exercise was to apply an existing s2s-algorithm to a scenario-based specification of a significant, real-world case study and to test the feasibility of generating state machines and executable code from the specification. The specification was given to the authors as ten pages of textual requirements. A collection of scenarios was developed from this text and the Whittle &amp; Schumann algorithm was applied to the scenarios. The algorithm synthesized state machines from which C++ code was generated using the Rational Rose RealTime tool [<xref ref-type="bibr" rid="R19" id="55" class="deo:Reference">19</xref>]. This code was then integrated with existing code for the CTAS application and a small number of tests were run on the code to check its behavior. Although extensive testing was not carried out on the synthesized code (no coverage criteria were looked at, for instance), the code passed rudimentary testing. In addition, inspection showed the equivalence of the generated code and manually developed code. The results show the feasibility for generating state machines and code from scenario-based specifications, given the caveats outlined in the previous subsection. The remainder of this paper is organized as follows. Section 2 reviews the s2s-algorithm used in the case study. Section 3 describes the case study application. Sections 4, 5 and 6 describe the modeling process, state machine synthesis and C++ code generation respectively. In Sect. 7, the results are summarized. Section 8 presents a discussion of the results with an outlook. Related work and conclusions follow in Sects. 9 and 10 respectively.</region>
        </section>
      </section>
      <region class="DoCO:TextChunk" id="18" page="1" column="1">There has been a lot of interest recently in the design and possible role of algorithms that generate state machines automatically from scenarios of intended or actual system behavior – witness, for example, successful workshops at the ICSE02 [<xref ref-type="bibr" rid="R21" id="15" class="deo:Reference">21</xref>], ICSE03 [<xref ref-type="bibr" rid="R22" id="16" class="deo:Reference">22</xref>] and OOP- SLA00 [<xref ref-type="bibr" rid="R20" id="17" class="deo:Reference">20</xref>] conferences. A scenario is usually thought of as a trace of an individual execution of a (software) artifact [30]. Scenarios</region>
      <region class="DoCO:TextChunk" id="19" confidence="possible" page="1" column="1">A much shorter version of this paper appeared in the Proceedings of the 2003 International Conference on Software Engineering [31].</region>
      <region class="DoCO:TextChunk" id="25" page="1" column="2">are widely used because they describe concrete interactions and are therefore easier for customers and domain experts to use than an abstract model. Many popular software processes advocate the use of scenarios in, for example, early software design or in specifying test cases. When part of an initial requirements or design activity, scenarios are used as a starting point to develop more detailed designs, e.g., in the form of state machines. An obvious question to ask is whether this transition can be partially automated. In fact, David Harel raised this question in his original paper on statecharts [<xref ref-type="bibr" rid="R8" id="20" class="deo:Reference">8</xref>] and researchers are now beginning to investigate it (e.g., [<xref ref-type="bibr" rid="R1" id="21" class="deo:Reference">1</xref>, <xref ref-type="bibr" rid="R14" id="22" class="deo:Reference">14</xref>, <xref ref-type="bibr" rid="R24" id="23" class="deo:Reference">24</xref>, <xref ref-type="bibr" rid="R26" id="24" class="deo:Reference">26</xref>]):</region>
      <region class="DoCO:TextChunk" id="27" confidence="possible" page="1" column="2">“ . . . many of the people that were involved in the avionics project . . . were able to state many desir- able scenarios, such as firing a missile or updating the aircraft’s location, in precise detail, describing things that they wanted the system to do eventually. Such scenarios are easily described using TL [temporal logic], and it would seem beneficial to be able to derive a reasonable statechart description from a large set of scenarios given in TL.” [<xref ref-type="bibr" rid="R8" id="26" class="deo:Reference">8</xref>]</region>
      <region class="DoCO:TextChunk" id="47" page="1" column="2">Any algorithm that generates state machines from a set of scenarios must incorporate a transition from a global scenario-based view (in which interactions between system components are considered) to local component- based views (in which a state machine is given for each component as a precursor to implementation). Harel identified temporal logic as a potential scenario description language but nowadays more popular visual notations are common, such as message sequence charts (MSCs) [ <xref ref-type="bibr" rid="R16" id="28" class="deo:Reference">16</xref>] or UML sequence diagrams [<xref ref-type="bibr" rid="R17" id="29" class="deo:Reference">17</xref>, <xref ref-type="bibr" rid="R18" id="30" class="deo:Reference">18</xref>]. Harel also noted that the key to success of such an algorithm is that it produces a “reasonable statechart description”. Much of the work on state machine synthesis algorithms<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> has been concerned with defining “reasonable” in this context and generating “reasonable state machines”. There have now been over a dozen papers written describing variants of algorithms for generating state machines from scenarios. To the authors’ knowledge, however, there have been very few significant case studies in applying these algorithms in practice. In this paper, we do exactly that – we apply a variant of the Whittle &amp; Schumann algorithm [32] to the weather control logic subsystem of CTAS (Center TRACON Automation System) [<xref ref-type="bibr" rid="R6" id="34" class="deo:Reference">6</xref>] which is under development at NASA Ames Research Center. The objective of this study was to assess whether it is possible to use scenario-to-state machine algorithms (henceforth referred to as s2s-algorithms) to reliably develop models of a complex and practical system. In fact, we go further than this and use a commercial code gener- ator to generate deployable code from these models. Note that the results in this paper apply primarily to the Whittle &amp; Schumann algorithm, although other published state machine synthesis algorithms (e.g., [<xref ref-type="bibr" rid="R12" id="35" class="deo:Reference">12</xref>, <xref ref-type="bibr" rid="R25" id="36" class="deo:Reference">25</xref>, <xref ref-type="bibr" rid="R26" id="37" class="deo:Reference">26</xref>]) could potentially be used in a similar way. No attempt is made in this paper to empirically compare different s2s-algorithms. However, it is instructive to discuss their distinguishing features. As previously mentioned, the key to a good s2s-algorithm is in whether it can generate a reasonable state machine. One of the factors in determining reasonableness is to what extent the algorithm is able to merge states derived from different scenarios. In fact, one of the major challenges for s2s-algorithms lies in the fact that each scenario is usually written in isolation from the others. As a result, the scenarios may duplicate information. To obtain a local model of each component, the scenarios have to be weaved together in such a way that duplicate information is rec- ognized and merged. Otherwise, the result will be a very large state machine with many redundant states. Most s2s-algorithms assume scenarios are represented as some form of sequence chart – usually a variant of MSCs or UML sequence diagrams. The left-hand side of <xref ref-type="fig" rid="F1" id="38" class="deo:Reference">Fig. 1</xref> shows a UML sequence diagram describing an interaction between entities A, B and C which exchange messages p, q, r and s. The algorithms commonly have as their basis a translation to state machines in which messages received by an entity in a scenario are considered as trigger events in the<marker type="column" number="2"/><marker type="block"/> entity’s state machine. Similarly, messages sent from an entity are considered as actions for that entity – see <xref ref-type="fig" rid="F1" id="41" class="deo:Reference">Fig. 1</xref>. Following the UML standard [<xref ref-type="bibr" rid="R18" id="42" class="deo:Reference">18</xref>], a/b denotes that a is a trigger event and b is the action carried out in response to the trigger. In the state machine in <xref ref-type="fig" rid="F1" id="43" class="deo:Reference">Fig. 1</xref>, B starts off in state s1. When message p arrives, it sends out message q and transitions to its next state, s2. Clearly, given a set of sequence diagrams and translating each of them to a state machine in this way results in a number of state machines for B. What distinguishes different s2s-algorithms is in the way they compose each of B’s state machines into a single state machine for B. This revolves around identifying same states in different state machines (which, in itself, corresponds to weaving the scenarios). A common technique is to weave scenarios based only on a common prefix in the sequences (e.g., [<xref ref-type="bibr" rid="R28" id="44" class="deo:Reference">28</xref>] ) but this technique cannot merge paths that do not stem from the same prefix. The SCED tool [<xref ref-type="bibr" rid="R15" id="45" class="deo:Reference">15</xref>] applies merging based on the names of the messages but this does not allow the same message to have a different effect in different states. Uchitel &amp; Kramer [<xref ref-type="bibr" rid="R26" id="46" class="deo:Reference">26</xref>] and others use special user-defined state labels to explicitly identify points in different scenarios. Whittle &amp; Schumann [32] allow the user to give more declarative constraints (in the form of message pre/post- conditions) from which state identities can be derived. In this case study, we will use a simplified form of the Whittle &amp; Schumann s2s-algorithm (in which pre/post- conditions are not used) extended with the use of state labels.</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="32" page="2" column="1">72</outsider>
      <outsider class="DoCO:TextBox" type="header" id="33" page="2" column="1">J. Whittle et al.: From scenarios to code</outsider>
      <region class="DoCO:FigureBox" id="F1">
        <caption class="deo:Caption" id="40" page="2" column="1">Fig. 1. The basic idea underlying most s2s-algorithms</caption>
      </region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="57" page="3" column="1">2 State machine synthesis algorithm</h1>
        <region class="DoCO:TextChunk" id="58" page="3" column="1">In this section, we describe the algorithm used to generate state machines from sequence diagrams. The algorithm is a variant of the one described in [32] in that we do not consider additional message pre-/post-conditions here but we do allow state labels to be given on the sequence diagrams.</region>
        <region class="DoCO:FigureBox" id="F2">
          <image class="DoCO:Figure" src="62sn.page_003.image_01.png" thmb="62sn.page_003.image_01-thumb.png"/>
          <caption class="deo:Caption" id="60" page="3" column="2">Fig. 2. State labels describing a loop</caption>
        </region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="61" page="3" column="2">2.1 Notation</h2>
          <region class="DoCO:TextChunk" id="65" page="3" column="2">Scenarios will be represented as UML sequence diagrams. In this paper, we consider only the core features of UML2.0 sequence diagrams [<xref ref-type="bibr" rid="R18" id="62" class="deo:Reference">18</xref>]. Sequence diagrams are extended with additional notation where necessary. State machines used in the paper will be compliant to the UML 2.0 definition of state machines. A sequence diagram shows the interaction between a number of participants over time – see <xref ref-type="fig" rid="F2" id="63" class="deo:Reference">Fig. 2</xref>. A participant is represented diagrammatically by a lifeline, shown as a rectangular box identified by A : X where A is the name of the participant and X is its type. The vertical line under the box represents the participant’s lifespan, in which time progresses downwards. Messages sent between participants are represented by arrows, labeled with the name of the message. We do not make a distinction in this paper between synchronous and asynchronous messages. State labels can be attached to a particular participant with the interpretation that for a state label s jk , all occurrences of s jk (in any sequence diagram) correspond to the same state of the participant. Hence, state labels can be used to identify points within the same or different sequence diagrams. For example, <xref ref-type="fig" rid="F2" id="64" class="deo:Reference">Fig. 2</xref> shows how state labels (represented by the named rectangles, s 1 , s 2 , s 3 ) can be used to describe a loop for A. State labels are intuitively similar to MSC conditions or UML2.0 continuations but only apply to one participant. A sequence diagram defines a partial order of messages, under the following constraints: – messages must be sent before they are received 1 ; – for each lifeline, message events (i.e., the sending or receipt of a message) located higher up in the diagram happen first.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="66" page="3" column="2">2.2 Synthesis</h2>
          <region class="DoCO:TextChunk" id="75" page="3" column="2">Sequence diagrams can be interpreted differently depend- ing on their use. For example, for testing, A : X can be <marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> interpreted to mean object A belonging to class X. In requirements capture, A : X can mean actor or component A that is of type X. Synthesis makes a transition from scenario interactions to state machine descriptions. This transition may be across phases of the software lifecycle or within a particular phase. If it is across phases, for example from requirements to design, a transformation of interpretations of A : X will be necessary – e.g., transforming participant A described in the requirements to object A in the design. Of course, A may be refined into multiple objects as well. Our s2s-algorithm does not incorporate such transformations but generates one state machine for X which A must conform to. Synthesis of state machines is performed in two steps. First, each sequence diagram is converted into a set of state machines, one for each type involved in the interaction. Next, the individual state machines derived for each type are merged into a single state machine for that type. We will illustrate the procedure with an example and then describe its formalization. <xref ref-type="fig" rid="F3" id="71" class="deo:Reference">Figure 3</xref> shows how a state machine can be generated for type B based on two sequence diagrams that include interactions for a participant b of type B. We represent a sequence diagram as a sequence of messages m 1 , . . . , m r , with s 00 , . . . , s 0i 0 −→ m 1 s 10 , . . . , s 1i 1 −→ m 2 . . . −→ m r s r0 , . . . , s ri r (1) where the s jk are state labels. The sequence is meant to represent the vertical ordering of the messages and labels. For the purposes of this paper, all messages are horizontal (i.e., sending and receiving the message occur simultan- eously) so there is no overlapping of messages. m j from will be used to represent the type of the sending participant. Similarly, m j to represents the receiving type. s jk c is the<marker type="column" number="2"/><marker type="block"/> type to which the state label s jk is attached. Note that we have abstracted away the participants in the sequence diagram. This is because state machines will be generated for the types of participants not for the participants themselves – the names of the actual participants is irrel- evant for state machine synthesis. Equation (1) is merely a convenient way of represent- ing a sequence diagram that will be used in our description of the Whittle &amp; Schumann s2s-algorithm. From the equation, it can be seen that any number of state labels (attached to different lifelines) may appear between messages. An additional constraint means that there cannot be more than one adjacent state label on the same lifeline – such a situation would not make sense because the state labels would not identify distinct states. In our representation, the sequence diagram in <xref ref-type="fig" rid="F2" id="74" class="deo:Reference">Fig. 2</xref> would be given as</region>
          <region class="unknown" id="68" page="3" column="2">1 although we assume message sending and receipt is simultaneous</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="69" page="4" column="1">74</outsider>
          <outsider class="DoCO:TextBox" type="header" id="70" page="4" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <region class="DoCO:FigureBox" id="F3">
            <caption class="deo:Caption" id="73" page="4" column="1">Fig. 3. Synthesis from Multiple Sequence Diagrams</caption>
          </region>
          <disp-formula class="DoCO:FormulaBox" id="F2">
            <label class="DoCO:Label" id="76">2</label>
            <content class="DoCO:Formula" id="77" page="4" column="2">s 1 −→ p −→ q s 2 s 3 −→ r −→ s s 1</content>
          </disp-formula>
          <region class="DoCO:TextChunk" id="78" confidence="possible" page="4" column="2">where p from = A, p to = B, s c 1 = A etc.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="79" page="4" column="2">2.3 Step I: Translating individual sequence diagrams</h2>
          <region class="DoCO:TextChunk" id="81" page="4" column="2">The algorithm in <xref ref-type="fig" rid="F4" id="80" class="deo:Reference">Fig. 4</xref> shows how an individual sequence diagram is translated into a collection of finite state machines (FSMs), one for each type involved in the interaction. The finite state machine for type X is denoted by Φ X ; its set of nodes by N X ; its transitions by n 1 , kind, name , n 2 for nodes n 1 , n 2 where kind is either event or action 2 ; and μ X is a function mapping a node to its label (if it exists). C X denotes the currently</region>
          <region class="DoCO:TextChunk" id="82" confidence="possible" page="4" column="2">2 In UML state machines, a transition is labeled by e/a which means that this transition can be active only if event e occurs. Then, the state changes and action a is carried out.</region>
          <outsider class="DoCO:TextBox" type="header" id="83" page="5" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="84" page="5" column="1">75</outsider>
          <region class="DoCO:FigureBox" id="F4">
            <image class="DoCO:Figure" src="62sn.page_005.image_02.png" thmb="62sn.page_005.image_02-thumb.png"/>
            <caption class="deo:Caption" id="86" page="5" column="1">Fig. 4. Translating a sequence diagram into FSMs. Φ X is the FSM for type X. Its set of nodes is N X , its transitions are triples of the form n 1 , annotation, n 2 for nodes n 1 , n 2 . μ X maps a node to its label and C X is the currently processed node for type X</caption>
          </region>
          <region class="DoCO:TextChunk" id="89" page="5" column="1">processed node for type X during the run of the algorithm. Messages directed towards a particular type, X (i.e., m to i = X) are considered events in the FSM for type X. Messages directed away from X (i.e., m from i = X) are considered actions. Given a sequence diagram, the algorithm in <xref ref-type="fig" rid="F4" id="87" class="deo:Reference">Fig. 4</xref> constructs one FSM for each type mentioned in the sequence diagram. We start by generating a single starting node n 0 X i for each FSM (line 3). Then we successively add outgoing and incoming messages to the FSMs, creating new nodes as we proceed (lines 9–11). State labels are treated in a similar way to messages (lines 12–17). If the state label has occurred previously, an empty transition connects the current node to the node associated with that label; otherwise, a new node with that label is created. For sim- plicity’s sake, we omit here optimizations that are part of<marker type="column" number="2"/><marker type="block"/> the implementation of this algorithm (e.g., to eliminate the empty transitions).</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="90" page="5" column="2">2.4 Step II: Merging multiple sequence diagrams</h2>
          <region class="DoCO:TextChunk" id="94" page="5" column="2">The previous step concerned the translation of a single sequence diagram into a number of state machines, one for each type. We now show how the state machines (obtained from different sequence diagrams) for a particular type can be merged. Merging state machines derived from different sequence diagrams is based upon identifying similar states in the state machines. In fact, how similarity is defined is the major variation point in the state machine synthesis algorithms published in the literature. Similarity definitions have ranged from very conservative (e.g., only <marker type="page" number="6"/><marker type="column" number="1"/><marker type="block"/> merge common prefixes of paths through a state machine), to overzealous (e.g., merge states so as to avoid non-determinism). Ultimately, there is incomplete information about the relationships between sequence diagrams and so merging states must be heuristic, at least in part. However, we believe that merging states is worth- while – generated state machines with little or no merging tend to be useless to the engineer (because they result in a very large number of states) whereas an algorithm that merges most states correctly and perhaps is a little over- or under-zealous in places provides state machines that are an excellent starting point for further design. In fact, overzealous merges can point out to the user a viable path that was not considered. Our notion of similarity is defined as follows:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="92" page="6" column="1">76</outsider>
          <outsider class="DoCO:TextBox" type="header" id="93" page="6" column="1">J. Whittle et al.: From scenarios to code</outsider>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="95" page="6" column="1">Definition 1.</h1>
        <region class="DoCO:TextChunk" id="96" confidence="possible" page="6" column="1">Two nodes in a FSM, are (m,n)-similar if they have a common incoming path of transitions of length m and a common outgoing path of transitions of length n.</region>
        <region class="DoCO:TextChunk" id="98" page="6" column="1">This notion generalizes the common prefix/suffix idea to apply at any point in a path through the FSM rather than being anchored at the initial- or end-point. The parameters m and n can be set by the user. In the case study, parameters of m = 1 and n = 1 were used. <xref ref-type="fig" rid="F5" id="97" class="deo:Reference">Figure 5</xref> depicts (1,0)-similarity graphically. Merging of states is based on similarity and state labels:</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="99" page="6" column="1">Definition 2.</h1>
        <region class="DoCO:TextChunk" id="100" confidence="possible" page="6" column="1">(m,n)-mergeable</region>
        <region class="unknown" id="101" page="6" column="1">Two nodes in a FSM are if they are (m,n)-similar or have the same state label.</region>
        <region class="DoCO:TextChunk" id="105" page="6" column="1">Note that the definition of mergeability can lead to potentially conflicting situations if two nodes are similar but have different state labels. In this case, the context is provided to the user and the user makes a decision on whether the states should be merged (this provides the possibility of overriding the mergeability heuristic in some cases). The process of merging multiple state machines proceeds as follows. For each type, we create a new state machine and all pairs of nodes which are mergeable are connected by -transitions. More formally, if we start with sequence diagrams which are translated into FSMs C 1 , . . . , C k , for a type X, then we create a new FSM, C, which includes C 1 , . . . , C k and has -transitions as follows: <marker type="column" number="2"/><marker type="block"/> 1. Let C be the union of C 1 , . . . , C k , i.e., N C = ∪ i N C i , μ C = ∪ i μ C i etc. 2. For each pair of mergeable nodes, n 1 and n 2 in N C , create -transitions from n 1 to n 2 and from n 2 to n 1 . We remove -transitions by merging states connected by -transitions. This can be done using standard algorithms. The effect is that each state in the final FSM, C, is a set of mergeable states from C 1 , . . . , C k . If a set of mergeable states contains two nodes with different labels, the conflict is presented to the user for resolution. This completes the description of the s2s-algorithm as used in this case study. The original Whittle &amp; Schumann algorithm contains features that were not used in the case study. For details of these features, please see the original paper on the algorithm [32]. The next section describes the system to which we applied this s2s-algorithm.</region>
        <region class="DoCO:FigureBox" id="F5">
          <image class="DoCO:Figure" src="62sn.page_006.image_03.png" thmb="62sn.page_006.image_03-thumb.png"/>
          <caption class="deo:Caption" id="104" page="6" column="1">Fig. 5. Merging of (1,0)-similar states (before and after the merge)</caption>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="106" page="6" column="2">3 The case study</h1>
        <region class="DoCO:TextChunk" id="121" page="6" column="2">CTAS (Center TRACON Automation System) [ <xref ref-type="bibr" rid="R6" id="107" class="deo:Reference">6</xref>] is a set of tools designed to help air traffic controllers manage the increasingly complex air traffic flows at large airports. The project began in 1991 and prototypes are now de- ployed at Denver and Dallas/Fort Worth airports. Ex- tensions to the core CTAS system are constantly being integrated and incorporate the latest developments from research on air traffic control systems. <xref ref-type="fig" rid="F6" id="108" class="deo:Reference">Figure 6</xref> gives an overview of the software architecture for CTAS. CTAS consists of a set of advisory tools and a set of processes that support these tools. In <xref ref-type="fig" rid="F6" id="109" class="deo:Reference">Fig. 6</xref>, CM is the Communi- cations Manager which handles all communications between the various advisory tools and support processes. TS is the Trajectory Synthesizer which generates 4D trajectories and ETAs that all CTAS tools depend on. The RA (Route Analyzer) generates all possible future<marker type="page" number="7"/><marker type="column" number="1"/><marker type="block"/> routes for an aircraft. The PFS (Profile Selector) assigns runways for approaching aircraft. PGUI and TGUI are graphical user interfaces. WDAD is a script that is responsible for gathering weather data files from hosts and making them available on the CTAS network file system. WDPD is responsible for converting raw weather files provided via WDAD into binary weather files usable by CTAS. One of the most crucial parts of an air traffic control system is the subsystem that deals with weather data. Adverse weather conditions can grind an entire traffic control system to a halt, so it is imperative that each of the components of CTAS is notified of weather forecast updates. The subject of the case study is the subsystem of CTAS that deals with weather data updates. The top- level requirement of this system is that every client that uses weather data should be notified of a weather update and all clients should begin using the updated weather data at the same time. The logic that implements this subsystem is defined by ten pages of English textual requirements. For each weather update, a Weather Cycle is invoked to update all weather aware clients. Similarly, the Weather Cycle is invoked to provide weather data to new clients. <xref ref-type="fig" rid="F7" id="116" class="deo:Reference">Figure 7</xref> shows the architecture of the CM. Communi- cation with weather-aware clients is done through sockets with one socket per client. The Weather Cycle (Weather Logic in the figure) is polled approximately every two seconds. On each call of the Weather Cycle, the CM checks to see if a new client is trying to connect or if new weather data has been received, and invokes actions accordingly. These actions are specified in the English textual requirements. Each requirement describes the behavior of the CM according to the current stage in the cycle. For examples, see <xref ref-type="fig" rid="F8" id="117" class="deo:Reference">Fig. 8</xref>.<marker type="column" number="2"/><marker type="block"/> The complete set of requirements describes a state machine expressing the weather update logic component of CTAS (henceforth, known as WCL), where each requirement describes a partial path through the state machine (i.e., a scenario). These scenarios also overlap – the requirements designer wrote down each requirement without regard for how it interacts with other requirements. The scenarios are interesting in that they already define some of the states of the intended state machine (i.e., the Weather Cycle status). These states will be defined by state labels in the sequence diagrams. The states that are defined in the requirements are preinitializing, initializing, post-initializing, pre-updating, updating, post-updating and post-reverting. The Weather Cycle can be viewed as two subcycles – the initializing cycle (containing the first three states) and the updating cycle (containing the last four states). Both cycles consist of a similar (but different) logic that involves pinging a number of clients, waiting for the clients to respond, sending out weather forecast data and waiting for acknowledgement that the data has been received. If a connection is lost with any client during this time, all client communications in the interaction are shut down (CM_CLOSE_CONNECTION ). Informally, the initializing cycle is invoked whenever a new client attempts to connect to the CM. The CM sends out the current weather data following the logic previously described. Updating follows a similar pattern but is invoked when new weather data is received.</region>
        <region class="DoCO:FigureBox" id="F6">
          <image class="DoCO:Figure" src="62sn.page_006.image_04.png" thmb="62sn.page_006.image_04-thumb.png"/>
          <caption class="deo:Caption" id="113" page="6" column="2">Fig. 6. CTAS Architecture (taken from <ext-link ext-link-type="uri" href="http://ctas.arc.nasa.gov" id="112">http://ctas.arc.nasa.gov</ext-link>)</caption>
        </region>
        <outsider class="DoCO:TextBox" type="header" id="114" page="7" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="115" page="7" column="1">77</outsider>
        <region class="DoCO:FigureBox" id="F7">
          <image class="DoCO:Figure" src="62sn.page_007.image_05.png" thmb="62sn.page_007.image_05-thumb.png"/>
          <caption class="deo:Caption" id="120" page="7" column="1">Fig. 7. Architecture of the CM</caption>
        </region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="122" page="7" column="2">3.1 Objective and procedure</h2>
          <region class="DoCO:TextChunk" id="129" page="7" column="2">The code that implements the weather update logic had already been implemented manually in C by CTAS developers. The objective of the case study was to reproduce this code directly from the requirements scenarios and thus to show that it is possible to semi-automatically generate code comparable to manually developed code from scenarios. The personnel on the case study consisted of a software developer from the CTAS team (not the original developer of the code), one of the researchers who developed the Whittle &amp; Schumann s2s-algorithm [32] and a student intern. The case study took place at NASA Ames Research Center during the summer of 2002. The textual requirements were translated into UML sequence diagrams from which state machines were automatically generated using an implementation of the Whittle &amp; Schumann algorithm. The commercial tool Rational Rose RealTime [ <xref ref-type="bibr" rid="R19" id="123" class="deo:Reference">19</xref>] was then used to generate C++ code from the state machines. This code was integrated into the existing system and compared, both by inspection and testing, against the original, manually developed weather control logic code. In this paper, fourteen of these requirements are written as UML sequence diagrams. These can be found in<marker type="page" number="8"/><marker type="column" number="1"/><marker type="block"/> the appendix. They are shown so that readers may apply their s2s-algorithms to the case study and hence compare their results to those presented here. Readers may obtain the original textual requirements by contacting the first author of this paper. In general, the researcher and student came up with the sequence diagrams and then iterated with the CTAS engineer. The other main role of the CTAS engineer was to integrate the code generated from the state machines into the existing CTAS system and perform testing on it. To summarize the results, this exercise showed that it is possible to generate code directly from UML sequence diagrams that is comparable to manually developed code. By inspection, it was seen that the two code fragments have the same behavior. In addition, a number of test cases were run on the code which produced identical results. The following sections show how we modeled the requirements as sequence diagrams and generated state machines and code from them.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="125" page="8" column="1">78</outsider>
          <outsider class="DoCO:TextBox" type="header" id="126" page="8" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <region class="DoCO:FigureBox" id="F8">
            <image class="DoCO:Figure" src="62sn.page_008.image_06.png" thmb="62sn.page_008.image_06-thumb.png"/>
            <caption class="deo:Caption" id="128" page="8" column="1">Fig. 8. Sample requirements for weather data updates</caption>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="130" page="8" column="2">4 Modeling the requirements</h1>
        <region class="DoCO:TextChunk" id="137" page="8" column="2">To develop state machines manually for the requirements would be a difficult exercise. The CM has a number of states corresponding to the current state of the Weather Cycle: unknown, preinitializing, initializing, pos- tinitializing, preupdating, updating, postupdat- ing, postreverting and done. Each weather-aware client has these states in addition to states describing whether or not the client has received new weather data and whether or not it is able to use this new weather data (succeeded_get, failed_get, succeeded_use, failed_use). In order to capture the requirements correctly, the states of the CM and of the clients must be tightly coupled together. These couplings are distributed across the entire requirements document and so captur- ing them directly as state machines is a time consuming and error-prone task. In contrast, translating the requirements into a first version of the sequence diagrams took a couple of hours of clerical work. Further iterations were required. <marker type="page" number="9"/><marker type="column" number="1"/><marker type="block"/>  <xref ref-type="fig" rid="F9" id="134" class="deo:Reference">Figure 9</xref> shows how requirement 2.8.9 from <xref ref-type="fig" rid="F8" id="135" class="deo:Reference">Fig. 8</xref> was translated into a sequence diagram. wcl (weather control logic) is the participant that represents the main con- troller of the weather update logic cycle (it corresponds to CM in <xref ref-type="fig" rid="F8" id="136" class="deo:Reference">Fig. 8</xref> but is really only a small part of CM). wthrClientStatus represents the part of wcl that keeps track of the status of each of the connected weather-aware clients. The black rectangles are state labels usually (but not always) used to note the beginning and end of the scenario. In general, translating the requirements into sequence diagrams was straightforward, but in this section, we will highlight some of the modeling decisions that had to be made. It took a few iterations to finalize the set of sequence diagrams that were believed to correspond to the textual requirements. We detail some of these iterations which are general enough that they could be employed in other contexts.</region>
        <outsider class="DoCO:TextBox" type="header" id="132" page="9" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="133" page="9" column="1">79</outsider>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="138" page="9" column="1">4.1 Determining participants</h2>
          <region class="DoCO:TextChunk" id="144" page="9" column="1">The first task that must be undertaken is to determine the participants for the sequence diagrams. Standard techniques can be used for this. In general, there may need to be some iteration that may involve adding or removing participants. In the case study, the final version of the sequence diagrams had one participant less than the initial versions. Removing the participant was an instance of a more general refactoring in which a participant a is subsumed by a participant b. The effect of such a refactoring is that participant a is removed and all a’s messages and state labels are redirected: – each state label for a becomes a state label for b; – each message from a to any other participant c becomes a message from b to c; <marker type="column" number="2"/><marker type="block"/> – each message to a from any other participant c becomes a message from c to b; – each message from b to a or from a to b becomes a message to self for b; – checks are made to avoid message naming conflicts in the definitions of a, b and c. To see how this was applied in the case study, consider requirement 2.8.9 from <xref ref-type="fig" rid="F8" id="142" class="deo:Reference">Fig. 8</xref>. Initially, participants were created for CM (represented by wcl in <xref ref-type="fig" rid="F9" id="143" class="deo:Reference">Fig. 9</xref> because CM actually does much more than given in these requirements), Weather Cycle, Client Status, Client and Panel. However, it became clear later that an explicit participant for Weather Cycle is unnecessary and its behavior can be merged with that of wcl. The need for the refactoring arose because it was no- ticed that, in initial versions, the wcl participant was merely acting as a interface between the other participants – whenever it received a message, it would forward that message to Weather Cycle. This suggests a guideline for sequence diagram developers – to look for redundant interface objects and remove them. Of course, some interface objects are legitimate, for example, if they correspond to actual software or hardware components.</region>
          <region class="DoCO:FigureBox" id="F9">
            <image class="DoCO:Figure" src="62sn.page_009.image_07.png" thmb="62sn.page_009.image_07-thumb.png"/>
            <caption class="deo:Caption" id="141" page="9" column="1">Fig. 9. Scenario 2.8.9.: if a newly-connected client cannot use the weather data it should be disconnected</caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="145" page="9" column="2">4.2 Determining synchronizations</h2>
          <region class="DoCO:TextChunk" id="153" page="9" column="2">In general, care has to be taken in ensuring that participants synchronize with each other appropriately. The global nature of interactions can lead to sequence diagrams in which some form of explicit synchronization needs to be inserted before a state machine can be developed locally for the participants. This may arise because the requirements do not give synchronization information or because of design decisions that introduce participants that must then synchronize to adhere to the requirements. <marker type="page" number="10"/><marker type="column" number="1"/><marker type="block"/> An example of this situation from the case study is given in <xref ref-type="fig" rid="F10" id="149" class="deo:Reference">Fig. 10</xref> which is a sequence diagram for requirement 2.8.8: ...and the newly connected weather-aware client has responded yes to the CTAS_USE_NEW_WTHR message (i.e. client_status = SUCCEEDED_USE): (a) it should enable the ‘‘set’’ button Because of the separation of functionality into wcl and wthrClientStatus participants, there arises the need for an explicit synchronization between the two participants. In <xref ref-type="fig" rid="F10" id="150" class="deo:Reference">Fig. 10</xref>, wcl should only enable the set button on the panel if the state succeeded_use is active. However, in a local, participant-based view wcl has no knowledge of activity in wthrClientStatus and therefore cannot wait until wthrClientStatus is in state succeeded_use before proceeding. There are (at least) two solutions to this problem. The two participants wcl and wthrClientStatus could be merged. This is, in effect, what was done in the manually developed code. However, the decision was taken to keep both participants. In this case, a message SUCCEEDED_USE was added from wthrClientStatus to wcl to synchronize the two participants. Missing synchronizations are a common problem when transitioning from a global to a local view. Many cases are easy to spot by inspection – the developer need only look for successive messages (or state labels) that have neither a sending or receiving participant in common. More complex cases could perhaps be detected by specialized techniques such as those developed by Uchitel et al. [<xref ref-type="bibr" rid="R27" id="151" class="deo:Reference">27</xref>] and Alur et al. [<xref ref-type="bibr" rid="R1" id="152" class="deo:Reference">1</xref>].</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="147" page="10" column="1">80</outsider>
          <outsider class="DoCO:TextBox" type="header" id="148" page="10" column="1">J. Whittle et al.: From scenarios to code</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="154" page="10" column="1">4.3 Representing multiple instances</h2>
          <region class="DoCO:TextChunk" id="162" page="10" column="1">Many of the messages in the requirements are univer- sal or existential messages – that is, the scenario is dependent on receipt of a message from all (alterna- tively, any one of ) the participants of a particular type. Sequence diagrams do not offer explicit notation for this. <marker type="column" number="2"/><marker type="block"/> In a process in which sequence diagrams are used merely for documentation, it is sufficient to annotate the diagrams with notes to mark, for example, that messages should be sent to all clients. For purposes of automatic synthesis from sequence diagrams, however, this is too informal. In this case study, it would have been sufficient to encode the universality (or existentiality) directly in the messages – i.e., to send a message to all clients, a new message SEN D_T O_ALL is created. This is adequate but, in general, it seems beneficial to be able to express this kind of information explicitly, hence we created an additional notation, described below. UML 1.4 introduces the notion of multiobjects for collaboration diagrams but not for sequence diagrams – we assume the same notion available for sequence diagrams in what follows (we denote multiobjects by &lt;&lt;multiobject&gt;&gt;). A &lt;&lt;multiobject&gt;&gt; in a sequence diagram (e.g., <xref ref-type="fig" rid="F11" id="158" class="deo:Reference">Fig. 11</xref>) is a lifeline that represents multiple participants of a certain type – all clients in <xref ref-type="fig" rid="F11" id="159" class="deo:Reference">Fig. 11</xref>. Unfortunately, the UML specification is somewhat vague in how multiobjects are to be interpreted. In addition, the UML specification only considers sending a message to a multiobject but not the case when an object waits for a message from multiple objects. We introduce the notation in <xref ref-type="fig" rid="F11" id="160" class="deo:Reference">Fig. 11</xref> where m* denotes that a message m is sent to all instances of a set of multiobjects and *m denotes that m is received from all instances of a set of multiobjects. To denote that a message is sent to (or received from) at least one of the instances, a single instance of the type is shown separately from the multiobject and the message is annotated as m- (or -m). See the appendix for examples. In <xref ref-type="fig" rid="F11" id="161" class="deo:Reference">Fig. 11</xref>, the message yes_CTAS_NEW_WTHR is expected from all clients.</region>
          <region class="DoCO:FigureBox" id="F10">
            <image class="DoCO:Figure" src="62sn.page_010.image_08.png" thmb="62sn.page_010.image_08-thumb.png"/>
            <caption class="deo:Caption" id="157" page="10" column="1">Fig. 10. Insufficient synchronization</caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="163" page="10" column="2">4.4 Using state labels to define continuations</h2>
          <region class="DoCO:TextChunk" id="172" page="10" column="2">State labels were used extensively to describe continuations of sequence diagrams. Each diagram had an initial set of state labels that defined its starting states and a set of state labels defining its final states. These state labels <marker type="page" number="11"/><marker type="column" number="1"/><marker type="block"/> could be used by the s2s-algorithm to join sequences together. This was appropriate for this case study because the requirements were written using the same convention. More generally, however, the number of state labels necessary could have been reduced significantly had high-level MSCs (hMSCs) [<xref ref-type="bibr" rid="R16" id="169" class="deo:Reference">16</xref>] or UML2.0 interaction overview diagrams [<xref ref-type="bibr" rid="R18" id="170" class="deo:Reference">18</xref>] been used to connect sequence diagrams. See Sect. 7 for statistics on this. hMSCs include a notation for specifying how individual sequence charts connect using continuation, iteration and choice operators. On the other hand, hMSCs are more complex than sequence diagrams. Note, also, that state labels are still needed in hMSCs for connecting points in the middle of a sequence chart. Using hMSCs without state labels would result in many short sequence charts ([<xref ref-type="bibr" rid="R27" id="171" class="deo:Reference">27</xref>]). State labels (or conditions in hMSCs) allow longer and more natural sequence charts to be expressed which are connected together in an appropriate way.</region>
          <outsider class="DoCO:TextBox" type="header" id="165" page="11" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="166" page="11" column="1">81</outsider>
          <region class="DoCO:FigureBox" id="F11">
            <image class="DoCO:Figure" src="62sn.page_011.image_09.png" thmb="62sn.page_011.image_09-thumb.png"/>
            <caption class="deo:Caption" id="168" page="11" column="1">Fig. 11. Multiple instances</caption>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="173" page="11" column="1">5 Generating state machines from requirements</h1>
        <region class="DoCO:TextChunk" id="178" page="11" column="1">The sequence diagrams were translated into state machines using the algorithm described in Sect. 2. This section describes the key issues involved in realizing this translation. Translating from sequence diagrams to state machines corresponds to a transition from requirements to design- based activities. As a result, the types should be refined into classes. Current s2s-algorithms do not support this transformation but generate one class for each type in the sequence diagrams. This was sufficient for this case study. The requirements centered around the behavior of wcl and wthrClientStatus so state machines were generated only for these participants. There were not enough messages to make it meaningful to generate a state machine for panel. For client, no information was specified as to when it should send its messages so a highly non- deterministic state machine could have been generated and possibly used to generate test cases, but this was not done (test cases were developed manually). The appendix <marker type="column" number="2"/><marker type="block"/> shows the state machine generated for wcl (after the modifications mentioned in the following). The major barrier in the use of s2s-algorithms currently is in avoiding over-generalization of the input scenarios. The scenarios usually contain incomplete information, particularly with regard to how scenarios should be merged. Generating state machines in the obvious way from scenarios results in state machines with one branch for each scenario. These state machines contain a lot of redundant states (because identical behavior has not been merged) and are not very amenable to refinement. Merging scenarios, on the other hand, is a difficult task because of the lack of merging information. Any attempt at merging scenarios therefore may result in state machines that over-generalize the behavior described in the scenarios – the state machines will accept the sequences specified in the scenarios but may accept other sequences as well. There is a trade-off between how much merging should be attempted and how much behavior will be generalized. Limited merging leads to minor generalizations which will probably be useful for purposes of further refinement and analysis of the state machines. Over-zealous merging, however, leads to overgeneralization of the behavior in the scenarios. Over- generalization, in this sense, means that a behavior has been introduced in the state machines which should not be allowed. Many approaches to merging scenarios in the literature merge states in the generated state machines based solely on the name of an event or action. Such approaches would have produced over-generalizations for this case study. Referring to the appendix, scenarios 2.8.9, 2.8.16 and 2.8.19 all have a message enableSetButton from wcl to panel. Using a single message name to merge states results in a state machine for wcl in which any sending of enableSetButton results in a transition to the same state. This is an over-generalization, however, because it assumes that enableSetButton is always followed by the same sequence. This is not true – in 2.8.9 enableSetButton is not followed by writeToCMSIM whereas in 2.8.16 and 2.8.19 it is.<marker type="page" number="12"/><marker type="column" number="1"/><marker type="block"/> Our algorithm also uses naming as a basis for merging states but is not limited to considering a single name – states can be merged if they have an identical sequence of transitions above some given length leading into and out of them (see the definition of (m,n)-mergeability in Sect. 2.4). Our notion of mergeability (see Definition 2) worked well overall. In this case study, mergeability was based upon identifying one identical incoming and one identical outgoing message (m = 1 and n = 1 in Definition 2). For the unoptimized version 3 of the state machines generated, turning off merging of states resulted in a 25% increase in the number of states generated. With merging turned on, there was only one instance in which a merge resulted in a state machine with incorrect behavior. In this case, the merge was “undone” manually. In another case, a merge actually suggested a refinement of the initial sequence diagrams. An inspection of the merge point showed that two states had been named differently (using state labels in the corresponding sequence diagrams) but really were the same state.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="176" page="12" column="1">82</outsider>
        <outsider class="DoCO:TextBox" type="header" id="177" page="12" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="179" page="12" column="1">5.1 Incorrect merging</h2>
          <region class="DoCO:TextChunk" id="181" page="12" column="1">This subsection illustrates how overgeneralization can lead to incorrect behaviors in the generated state machines. Consider sequence diagrams 2.8.15 and 2.8.16 in the appendix. For both of these scenarios, wcl begins in the same state (POSTUPDATING). The correct state machine that should be generated for wcl when combining the two scenarios is shown in <xref ref-type="fig" rid="F12" id="180" class="deo:Reference">Fig. 12</xref>. Unfortunately, however, our s2s-algorithm merged states s1 and s2 because they have a common incoming message (removePendingWthr ) and a common outgoing message (enableSetButton). s1 and s2 should not be merged because one state corresponds to a successful weather update whilst the other state is for a failed update. Even if the outgoing threshold for merging had</region>
          <region class="DoCO:TextChunk" id="182" confidence="possible" page="12" column="1">3 Our algorithm applies behavior-preserving optimizations to avoid null events or actions or empty transitions.</region>
          <region class="DoCO:FigureBox" id="F12">
            <caption class="deo:Caption" id="183" page="12" column="1">Fig. 12. The correct state machine for 2.8.15 and 2.8.16</caption>
          </region>
          <region class="DoCO:TextChunk" id="191" page="12" column="2">been increased to 2, the two states would still have been merged incorrectly (and other correct merges would not have been made). There is, of course, no way to avoid this kind of incorrect merging if the naming of the messages is the basis for merging – there will always be a case where two independent branches have a common subsequence of length greater than a given threshold but should not be merged. More complex s2s-algorithms based on alternative merging strategies could be used to avoid incorrect merges. For example, we tried the full version of our s2s- algorithm from [32] in which the user may optionally specify additional constraints given in the Object Constraint Language (OCL) ([ <xref ref-type="bibr" rid="R29" id="184" class="deo:Reference">29</xref>]). The messages in the sequence diagrams can be annotated with OCL pre- and post- conditions over special state variables. The instantiations of these state variables are then propagated through the generated state machines automatically and give a char- acterization of each state (called a state vector ) in terms of values of these variables. States are then merged only if both the mergeability condition holds and their state vectors are the same (or more generally, are unifiable). <xref ref-type="fig" rid="F13" id="185" class="deo:Reference">Figure 13</xref> illustrates this process for our example. We defined a state variable that is set to true when the message SUCCEEDED_USE is received and is set to false when FAILED_USE is received. These values then get propagated using a frame axiom (under which state vectors remain the same unless explicitly changed in a post- condition) to the remainder of each branch as in <xref ref-type="fig" rid="F13" id="186" class="deo:Reference">Fig. 13</xref>. Note that s1 and s2 can no longer be merged because they have different state vectors, &lt;f&gt; and &lt;t&gt; respectively. While we believe that using additional OCL constraints in this way is generally useful for specifying declarative conditions on sequence diagrams and that these constraints can be used in the state machine synthesis process, for this particular example, the very low number of incorrect mergings meant that it was easier to modify the generated state machine manually. A useful tool, however, would be one that would provide assistance in detecting incorrect merges. Our s2s- algorithm currently does not provide any help nor does any other algorithm of which the authors are aware. In-<marker type="page" number="13"/><marker type="column" number="1"/><marker type="block"/> correct merges result in a path that is not explicitly given as a sequence diagram so it should be possible to detect these automatically.</region>
          <outsider class="DoCO:TextBox" type="header" id="188" page="13" column="1">J. Whittle et al.: From scenarios to code</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="189" page="13" column="1">83</outsider>
          <region class="DoCO:FigureBox" id="F13">
            <caption class="deo:Caption" id="190" page="13" column="1">Fig. 13. Avoiding incorrect merging with state variables</caption>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="192" page="13" column="1">6 Generating code</h1>
        <region class="DoCO:TextChunk" id="196" page="13" column="1">Once state machines were generated for wcl and wthrClientStatus, the Rational Rose RealTime tool (RoseRT) was used to generate C++ code. This code was then integrated into the existing CTAS code base and executed. This was generally a straightforward process. The following discusses some details of the process. Each action in the transitions was interpreted as a method in the original code base. In the original design, the weather update subsystem of CM is polled from its environment every two seconds. Once polled, the module runs to completion, finishing by sending a message to one or more clients. At this point, the weather update subsystem yields the focus of control. In order to facilitate this, the state machines generated were given additional triggers. Yielding of focus of control can occur in a given number of states. When control is regained, execution should continue from the exit state. These states were given a trigger that is called from the environment. This mechanism gives the same behavior as the two second polling in the original design. At the point of integrating the code, a small number of misunderstandings were discovered in the way the scenarios had been written 4 . This was a result of design decisions that had been made in the sequence diagrams that made integration with the existing code base difficult. Appropriate modifications were made to the state machine and code re-generated. Unfortunately, in the time crush that was now ensuing, changes were not re- flected in the scenarios. This leads us to the conclusion that a crucial part of this technology should be to automatically maintain consistency between sequence diagrams and state machines. This could be done with a “backwards direction” algorithm that keeps track of the <marker type="column" number="2"/><marker type="block"/> changes to the state machine and suggests corresponding changes in the scenarios. Although there has been some research on this topic (e.g., [<xref ref-type="bibr" rid="R23" id="195" class="deo:Reference">23</xref>]), a good solution has not yet been found. RoseRT generates code that includes its own runtime services library. The CTAS team were not ready to accept a third party library such as this because of concerns about reliability. As a result, the code was generated using RoseRT passive classes. State machines for passive classes have a synchronous model of execution – all triggers are just function calls so there are no event queues on state machines. As a result, there is no need for a runtime services library. The main problem with this is that the sequence diagrams include asynchronous messages. As a result, some minor changes to the state machines were needed to implement the asynchronous messages. The final integrated code was tested using a small number of representative test cases and all test cases passed. Extensive coverage testing was not done.</region>
        <region class="unknown" id="194" page="13" column="1">4 these misunderstandings were discovered by inspection</region>
      </section>
      <section class="deo:Results">
        <h1 class="DoCO:SectionTitle" id="197" page="13" column="2">7 Results summary</h1>
        <region class="DoCO:TextChunk" id="205" page="13" column="2">Tables 1 and 2 give some basic statistics on the problem scenarios and the generated artifacts for the portion of the weather control logic subsystem considered in this paper. If we had used hMSCs instead of sequence diagrams extended with state labels, we could have avoided inserting most of the state labels (because most labels were used to show which sequence diagram followed on from the current diagram, and hMSCs have a notation for this). The RoseRT comments referred to in the table are special comments introduced by the RoseRT code gener- ator to keep track of which code is auto-generated for the purposes of round-trip engineering. Whilst the authors believe this case study to provide evidence that transitioning mostly automatically from scenarios to code is possible, it should be noted that this case study has a number of characteristics that may or may not be shared with other examples. Firstly, the requirements were very well developed. They represent a complete and consistent view of the <marker type="page" number="14"/><marker type="column" number="1"/><marker type="block"/> system and hence, there were very few and only minor iterations in developing the scenarios. In a case where the s2s-algorithm was being used to help develop the requirements, additional results would be observed. Secondly, the length of the sequence diagrams (in terms of number of messages) turned out to be quite small on average. This is because the requirements were already well structured. This might not be the case for examples in which the requirements were vague. Thirdly, it is interesting to note that the requirements already identify most of the states (e.g., POSTINITIAL- IZE ) that appear in the state machine. Clearly, the scenarios were written from a state-based perspective which may have made the transition to state machines easier. In summary, though, we believe that this case study represents a realistic example that provides interesting results to the researchers in this field.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="199" page="14" column="1">84</outsider>
        <outsider class="DoCO:TextBox" type="header" id="200" page="14" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <region class="DoCO:TableBox" id="T1">
          <caption class="deo:Caption" id="201" page="14" column="1">Table 1. Sequence diagram statistics</caption>
        </region>
        <region class="unknown" id="202" page="14" column="1">General data # of sequence diagrams 17 # of components per diagram 3–6 Messages data total # of messages 75 # of messages per diagram 2–12 average # of messages per diagram 4.4 # of messages that don’t appear in state machines 0 State labels data # of state labels 45 # of state labels avoided by hMSCs 36</region>
        <region class="DoCO:TableBox" id="T2">
          <caption class="deo:Caption" id="203" page="14" column="1">Table 2. State machine statistics</caption>
        </region>
        <region class="unknown" id="204" page="14" column="1">wcl wthrClientStatus # states in FSM 12 11 # LOC generated by RoseRT 986 640 # LOC w/out RoseRT comments 672 404</region>
      </section>
      <section class="deo:Discussion">
        <h1 class="DoCO:SectionTitle" id="206" page="14" column="1">8 Discussion</h1>
        <region class="DoCO:TextChunk" id="207" page="14" column="1">This section summarizes the most important issues related to the case study and offers suggestions for further research. Appropriateness of s2s-algorithms State machines are a surprisingly difficult notation for engineers to understand, particularly if the full statechart notation is used. Sequence diagrams, and related notations, are often much better for specifying and communicating requirements. However, the appropriate tool should be picked for the job. If the re-</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="208" page="14" column="2">From</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="209" page="14" column="2">Refining</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="210" page="14" column="2">Sequence</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="211" page="14" column="2">State</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="212" page="14" column="2">Scenario</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="213" page="14" column="2">Over-generalization</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="214" page="14" column="2">Round-trip</h1>
        <region class="DoCO:TextChunk" id="215" confidence="possible" page="14" column="2">quirements are scenario-based, it makes sense to use sequence diagrams. However, in some cases, state machines should be developed directly from the requirements. requirements to sequence diagrams It is straightforward to come up with a literal translation of scenario-based requirements into sequence diagrams. However, these diagrams will usually need iterations before they can be used to develop state machines. The level of effort required in iterations obviously depends on the form of the requirements. What is needed is a process for iterating on the sequence diagrams. This process should ideally make a separation between diagrams that are at the requirements level and diagrams that contain design decisions. sequence diagrams There are a number of common modeling guidelines that could be used to refine sequence diagrams to a point where s2s- algorithms can be used. Some of these have been discussed in Sect. 4. The process mentioned in the previous bullet-point should include these guidelines. diagrams that enable synthesis For s2s- algorithms to be applied, more precise detail may need to be added to the sequence diagrams than if those diagrams were used merely for documentation. An example is that comments are fine for communication amongst project stakeholders but cannot be used by synthesis algorithms. labels vs. hMSCs High-level MSCs are a good way of connecting sequence diagrams together. However, they do not allow anything to be said about the internals of the diagrams that are connected together. State labels are a good way for specifying relationships about the internals. Relationships There is currently only limited support in notations for specifying relationships between scenarios. High-level MSCs can connect scenarios in some ways but do not allow anything to be said about temporal relationships between scenarios, interruption of scenarios, or complex interactions between scenarios. Research should be carried out into how to specify such relationships and generate corresponding state machines. Note that although UML2.0 sequence diagrams include a much richer set of concepts for modeling, they do not address the kinds of relationships mentioned here. in synthesis Current s2s-algorithms may overgeneralize behavior during synthesis. Research should be done in how to minimize over-generalization and/or alert the user. engineering More theoretical and tool support is required in maintaining consistency between sequence diagrams and state machines if the generated state machines are modified.</region>
        <outsider class="DoCO:TextBox" type="header" id="216" page="15" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="217" page="15" column="1">85</outsider>
      </section>
      <section class="deo:Methods">
        <h1 class="DoCO:SectionTitle" id="218" page="15" column="1">Methodology</h1>
        <region class="DoCO:TextChunk" id="219" confidence="possible" page="15" column="1">There is a distinct lack of work done on methodologies for using scenarios in system requirements and design, in particular, with respect to how the transition to state machines can be done. A methodology is needed for developing sequence diagrams from scenarios, for determining if the set of sequence diagrams is well-defined enough for synthesis, and for refining sequence diagrams to enable synthesis.</region>
      </section>
      <section class="deo:RelatedWork">
        <h1 class="DoCO:SectionTitle" id="220" page="15" column="1">9 Related work</h1>
        <region class="DoCO:TextChunk" id="234" page="15" column="1">To the authors’ knowledge, there has been no significant study thus far on evaluating s2s-algorithms on an industrial application. Many s2s-algorithms have been developed and tested on research or teaching examples, however. We review some of these algorithms here. The main deviation point in the published s2s-algorithms is in the way they decide to merge states. Khriss et al. [ <xref ref-type="bibr" rid="R10" id="221" class="deo:Reference">10</xref>] solve this by asking the user to explicitly name each state in the FSM generated from a scenario. Differ- ent states are then merged if they have been given the same name. This approach requires a good deal of effort from the user, however. The SCED tool [<xref ref-type="bibr" rid="R15" id="222" class="deo:Reference">15</xref>] generates FSMs from traces using the Biermann-Krishnaswamy algorithm [<xref ref-type="bibr" rid="R3" id="223" class="deo:Reference">3</xref>]. This algorithm uses backtracking to identify identical states, based on the names of local actions, in such a way that the final output FSM will be deterministic. As a result, there is no use of seman- tic information about the states and the algorithm ulti- mately may produce incorrect results by assuming that two states with the same local action have an identical set of outgoing transitions. In addition, designers may wish to introduce non-determinism into their designs which will only be resolved at a later implementation stage. Hence, the insistence on determinism is overly restric- tive. A successor of SCED, the MAS system [<xref ref-type="bibr" rid="R25" id="224" class="deo:Reference">25</xref>], applies a highly interactive approach to the problem of identifying same states. During synthesis, MAS queries the user whether certain proposed scenarios should be integrated into the generated FSM. MAS chooses generalizations of the set of input scenarios to present to the user in this way. In practice, however, the user is over- whelmed by a large number of interactive queries. MAS is based on a learning algorithm and it seems that successful use of the tool requires deep knowledge of the algorithm. Leue et al. [<xref ref-type="bibr" rid="R13" id="225" class="deo:Reference">13</xref>] tackles the problem of integration by requiring that the user gives an explicit diagram (a high- level message sequence chart) showing the transitions from one scenario to the next. This merely shows, however, how the start and end points of different scenarios relate. There is no way to examine the contents of scenarios to, for example, detect interleavings or loops. Glinz [<xref ref-type="bibr" rid="R7" id="226" class="deo:Reference">7</xref>] follows a similar approach, essentially using an AND/OR tree instead of a high-level message sequence chart.<marker type="column" number="2"/><marker type="block"/> Somé &amp; Dssouli [<xref ref-type="bibr" rid="R24" id="228" class="deo:Reference">24</xref>] follow an approach in which timed automata are generated from scenarios. The user must provide message specifications with add and delete lists which maintain a set of currently valid predicates in a strips-like fashion. States are then identified if the set of valid predicates is the same. This approach is similar to the pre/post-condition technique mentioned in Sect. 5.1 and described in [32]. Krüger [<xref ref-type="bibr" rid="R12" id="229" class="deo:Reference">12</xref>] presents a synthesis algorithm for MSCs that include notational extensions for dealing with pre- emption and suspension of scenarios. Sequence diagrams in general turned out to be sufficient to express the requirements scenarios in this case study. However, connecting sequence diagrams would have been easier had high-level message sequence charts been used. Another possibility would be to use a more recent notation, live sequence charts (LSCs) [<xref ref-type="bibr" rid="R5" id="230" class="deo:Reference">5</xref>] for which a s2s-algorithm has been developed [<xref ref-type="bibr" rid="R9" id="231" class="deo:Reference">9</xref>]. In LSCs, object timelines may be marked as solid lines, in which case no further messages are allowed, or as dashed lines, in which case other messages are allowed to be present. This simple notational device provides a neat way of introducing abstraction, but further research is necessary to assess what kinds of abstraction mechanisms are useful for the modeler, and for synthesis algorithms. The relationship between sequence charts and SDL has been investigated in the telecommunications domain. Some tools are available commercially for analyz- ing MSCs (uBET [<xref ref-type="bibr" rid="R2" id="232" class="deo:Reference">2</xref>]) or for synthesizing SDL models from MSCs (Klocwork’s SDL Synthesizer [<xref ref-type="bibr" rid="R11" id="233" class="deo:Reference">11</xref>]). In the lat- ter case, SDL Synthesizer makes no attempt to merge states generated from different MSCs.</region>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="235" page="15" column="2">10 Conclusions</h1>
        <region class="DoCO:TextChunk" id="241" page="15" column="2">In this paper, we have described a real-world industrial application of a state machine synthesis algorithm that allowed end to end code generation from requirements scenarios. This case study has shown that it is possible to generate code mostly automatically from scenarios of the intended behavior. Code was generated that was inserted into an existing system and successfully tested. Interestingly, the engineer in this case study could very easily understand the sequence diagrams but had trouble understanding the state machines generated. The hard- est part of the process was actually integrating the generated code into the CTAS system. This required deep knowledge of the existing CTAS implementation because the messages had to be matched to previously defined method calls. In generating state machines from scenarios, simple algorithms tend to work the best. The more advanced features of our particular algorithm were not used and we would conjecture that other complex mechanisms designed to avoid over-generalization would cause too much confusion. Current s2s-algorithms were generally good <marker type="page" number="16"/><marker type="column" number="1"/><marker type="block"/> enough to do a reasonable job even though they involved some minor massaging of the state machines generated before code generation was successful. The main area that is not currently well supported is in maintaining the consistency of the scenarios and state machines once these modifications have taken place. Although there has been some research on maintaining consistency of views in this way (e.g., [<xref ref-type="bibr" rid="R15" id="239" class="deo:Reference">15</xref>]), this field has not been fully explored. Sequence chart notations are becoming more expres- sive. UML2.0 sequence diagrams have a wide variety of notational constructs inherited either from MSCs or LSCs. Still, however, more constructs are likely to be added as sequence chart usage matures. Synthesis algorithms must keep pace. Moreover, more complex sequence charts lead to more complex synthesis algorithms. In particular, some constructs, for example coregions, may be implemented as state machines in different ways. Initial research has been done as to how to allow customization of the synthesis algorithms, for example, via the application of “state machine implementation” patterns [<xref ref-type="bibr" rid="R4" id="240" class="deo:Reference">4</xref>] that give common, reusable patterns for implementing various scenario concepts as state machines. Based on our experience with this case study, we believe that there are two major application areas for state machine synthesis algorithms. Firstly, as demonstrated in this example, it is possible to use the algorithms to generate complete implementations. This relies on the input scenarios being a complete and consistent set of scenarios that completely define the subsystem under development. We were fortunate in that our requirements provided us with such information. More generally, however, these synthesis algorithms could be used to help develop and validate requirements scenarios. In a related project, we worked with a customer who had only a vague idea of what the scenarios should look like. The use of a synthesis algorithm could provide rapid prototyping in which scenarios can quickly and easily be converted into state machines and simulated/tested. Indeed, this technique could be used in hazard analysis to examine the effects of unwanted scenarios. However, we anticipate that additional research is needed to mature state machine synthesis algorithms to a point where they could be used in this fashion because such scenarios would by their nature be less well-defined. Finally, we wish to restate the characteristics of this case study that led to successful use of the s2s-algorithm – namely, the well-defined nature of the scenario-based requirements; and the fact that some high-level states were defined in the requirements. We believe that s2s- algorithms are much more widely applicable although perhaps the manner in which they are used might be different.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="237" page="16" column="1">86</outsider>
        <outsider class="DoCO:TextBox" type="header" id="238" page="16" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <region class="DoCO:TextChunk" id="242" confidence="possible" page="16" column="1">Acknowledgements. The algorithm used in this case study (described in Sect. 2) was jointly developed with Johann Schumann.</region>
        <region class="DoCO:TextChunk" id="243" confidence="possible" page="16" column="2">We thank Michelle Eshow, NASA Branch Chief for Aviation Oper- ation Systems Development, for allocating resources for this study.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="244" page="16" column="2">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="245" page="16" column="2">1. Alur R, Etessami K, Yannakakis M (2003) Inference of Message Sequence Charts. IEEE Transactions on Software Engineering 29(7), July</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="246" page="16" column="2">2. Alur R, Holzmann GJ, Peled D (1996) An Analyzer for Message Sequence Charts. In: Proceedings of TACAS96, Lecture Notes in Computer Science, vol 1055. Springer Verlag</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="247" page="16" column="2">3. Biermann A, Krishnaswamy R (1976) Constructing programs from example computations. IEEE Transactions on Software Engineering SE-2(3):141–153</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="248" page="16" column="2">4. Bordeleau F, Corriveau J (2002) On the need for state machine implementation design patterns. In: Systä T (ed) Proceedings of the ICSE2002 Workshop on Scenarios amd state machines: models, algorithms, and tools</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="249" page="16" column="2">5. Damm W, Harel D (1999) LSCs : Breathing life into message sequence charts. In: 3rd International Conference on Formal Methods for Open Object-based Distributed Systems (FMOODS99). Kluwer, pp 293–312</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="250" page="16" column="2">6. Denery D, Erzberger H, Davis T, Green S, McNally B (1997) Challenges of air traffic management research: Analysis, simu- lation and field test. In: AIAA Guidance, Navigation and Control Conference</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="251" page="16" column="2">7. Glinz M (1995) An integrated formal model of scenarios based on statecharts. In: 5th European Software Engineering Conference (ESEC), Sitges, Spain, pp 254–271</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="252" page="16" column="2">8. Harel D (1987) Statecharts: A visual formalism for complex systems. Science of Computer Programming 8:231–274</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="253" page="16" column="2">9. Harel D, Kugler H (2000) Synthesizing state-based object systems from LSC specifications. In: Fifth International Conference on Implementation and Application of Automata (CIAA2000), Lecture Notes in Computer Science, vol 2088. Springer-Verlag</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="254" page="16" column="2">10. Khriss I, Elkoutbi M, Keller R (1999) Automating the synthesis of UML statechart diagrams from multiple collaboration diagrams. In: Bézivin J, Muller P (eds) UML98: Beyond the Notation, Lecture Notes in Computer Science, vol 1618. Springer-Verlag, pp 132–147</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="256" page="16" column="2">11. Klockwork SDL Synthesizer (2004) Klockwork, Ottawa, Canada. <ext-link ext-link-type="uri" href="http://www.klocwork.com" id="255">http://www.klocwork.com</ext-link></ref>
          <ref rid="R12" class="deo:BibliographicReference" id="257" page="16" column="2">12. Krüger I (2000) Distributed System Design with Message Sequence Charts. PhD thesis, Technical University of Munich</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="258" page="16" column="2">13. Leue S, Mehrmann L, Rezai M (1998) Synthesizing software architecture descriptions from Message Sequence Chart specifications. In: Automated Software Engineering. Honolulu, Hawaii, pp 192–195</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="259" page="16" column="2">14. Makinen E, Systä T (2001) MAS: An interactive synthe- sizer to support behavioral modeling in UML. In: Proceedings of the International Conference on Software Engineering (ICSE01). IEEE Computer Society, pp 15–24</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="260" page="16" column="2">15. Männistö T, Systä T, Tuomi J (1994) SCED report and user manual. Report A-1994-5, Dept of Computer Science, University of Tampere</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="261" page="16" column="2">16. Message sequence chart (MSC) (2004) ITU-T Recommendation Z.120 (previously CCITT Recommendation), Formal description techniques</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="263" page="16" column="2">17. The Object Management Group (2001) Unified Modeling Language specification version 1.4, September. Available from <ext-link ext-link-type="uri" href="http://www.omg.org" id="262">http://www.omg.org</ext-link></ref>
          <ref rid="R18" class="deo:BibliographicReference" id="265" page="16" column="2">18. The Object Management Group (2004) Unified Modeling Language specification version 2.0, January. Available from <ext-link ext-link-type="uri" href="http://www.omg.org" id="264">http://www.omg.org</ext-link></ref>
          <ref rid="R19" class="deo:BibliographicReference" id="266" page="16" column="2">19. Rational Rose RealTime (2004) IBM Corporation, White Plains, NY</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="267" page="16" column="2">20. In: Systä T (ed) (2000) Proceedings of the OOPSLA2000 Workshop on Scenario-based Round Trip Engineering</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="268" page="16" column="2">21. In: Systä T (ed) (2002) Proceedings of the ICSE2002 Workshop on Scenarios and State Machines: Models, Algorithms, and Tools</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="271" page="17" column="1">22. In: Uchitel S, Whittle J, Zündorf A, Krüger I (eds) (2003) Proceedings of the ICSE2003 Workshop on Scenarios and State Machines: Models, Algorithms, and Tools</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="272" page="17" column="1">23. Schumann J (2000) Automatic debugging support for UML designs. In: Ducasse M (ed) Proceedings of the 4th International Workshop on Automated Debugging (AADEBUG), Munich, Germany</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="273" page="17" column="1">24. Somé S, Dssouli R (1995) From scenarios to timed automata: building specifications from users requirements. In: Asia Pa- cific Software Engineering Conference, pp 48–57</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="274" page="17" column="1">25. Systä T (2000) Incremental construction of dynamic models for object oriented software systems. Journal of Object Ori- ented Programming 13(5):18–27</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="275" page="17" column="1">26. Uchitel S, Kramer J (2001) A workbench for synthesizing behavior models from scenarios. In: Proceedings of the 23rd IEEE International Conference on Software Engineering (ICSE01), Toronto, Canada</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="276" page="17" column="1">27. Uchitel S, Kramer J, Magee J (2001) Detecting implied scenarios in message sequence chart specifications. In: Proceedings of the 9th European Software Engineering Conference (ESEC01), Vienna, Austria</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="277" page="17" column="1">28. van Lamsweerde A, Willemet L (1998) Inferring declarative requirements specifications from operational scenarios. IEEE Transactions on Software Engineering 24(12): 1089–1114</ref>
          <ref rid="R29" class="deo:BibliographicReference" id="278" page="17" column="1">29. Warmer J, Kleppe A (1999) The Object Constraint Language: Precise Modeling with UML. Addison-Wesley Object Technol- ogy Series. Addison-Wesley</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="header" id="269" page="17" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="270" page="17" column="1">87</outsider>
        <region class="DoCO:FigureBox" id="F14">
          <image class="DoCO:Figure" src="62sn.page_017.image_10.png" thmb="62sn.page_017.image_10-thumb.png"/>
          <caption class="deo:Caption" id="280" page="17" column="1">Fig. 14. Sequence Diagram 2.8.2.: periodically check for updated weather information</caption>
        </region>
        <region class="DoCO:TextChunk" id="281" confidence="possible" page="17" column="2">30. Weidenhaupt K, Pohl K, Jarke M, Haumer P (1998) Scenarios in system development: Current practice. IEEE Software, pp 34–45, March/April 1998 31. Whittle J, Saboo J, Kwan R (2003) From scenarios to code: An air traffic control case study. In: Proceedings of the 25th International Conference on Software Engineering (ICSE2003), pp 490–497 32. Whittle J, Schumann J (2000) Generating Statechart Designs From Scenarios. In: Proceedings of the International Conference on Software Engineering (ICSE 2000). Limerick, Ireland, pp 314–323, June 2000</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="282" page="17" column="2">Appendix</h1>
        <region class="DoCO:TextChunk" id="283" page="17" column="2">This appendix is included to give the reader a chance to apply alternative synthesis algorithms. The original requirements document can be obtained from the first author. The scenarios define a two-phase commit pro- tocol in which clients are first sent new weather data (CTAS_GET_NEW_WTHR) and once they have all ac- knowledged, the clients are instructed to begin using the new data (CTAS_USE_NEW_WTHR). Failure to acknowledge results in clients being disconnected.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="284" page="18" column="1">88</outsider>
        <outsider class="DoCO:TextBox" type="header" id="285" page="18" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <region class="DoCO:FigureBox" id="F15">
          <image class="DoCO:Figure" src="62sn.page_018.image_11.png" thmb="62sn.page_018.image_11-thumb.png"/>
          <caption class="deo:Caption" id="287" page="18" column="1">Fig. 15. Sequence Diagram 2.8.3.: initialize the system by notifying all clients</caption>
        </region>
        <region class="DoCO:FigureBox" id="F16">
          <image class="DoCO:Figure" src="62sn.page_018.image_12.png" thmb="62sn.page_018.image_12-thumb.png"/>
          <caption class="deo:Caption" id="289" page="18" column="1">Fig. 16. Sequence Diagram 2.8.5.: newly connected client is instructed to use the weather data</caption>
        </region>
        <region class="DoCO:FigureBox" id="F17">
          <image class="DoCO:Figure" src="62sn.page_018.image_13.png" thmb="62sn.page_018.image_13-thumb.png"/>
          <caption class="deo:Caption" id="291" page="18" column="1">Fig. 17. Sequence Diagram 2.8.6.: if the newly connected client cannot acknowledge, it is disconnected</caption>
        </region>
        <outsider class="DoCO:TextBox" type="header" id="292" page="19" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="293" page="19" column="1">89</outsider>
        <region class="DoCO:FigureBox" id="F18">
          <image class="DoCO:Figure" src="62sn.page_019.image_14.png" thmb="62sn.page_019.image_14-thumb.png"/>
          <caption class="deo:Caption" id="295" page="19" column="1">Fig. 18. Sequence Diagram 2.8.8.: initialization phase succeeds – the new client is successfully connected</caption>
        </region>
        <region class="DoCO:FigureBox" id="F19">
          <image class="DoCO:Figure" src="62sn.page_019.image_15.png" thmb="62sn.page_019.image_15-thumb.png"/>
          <caption class="deo:Caption" id="297" page="19" column="1">Fig. 19. Sequence Diagram 2.8.9.: failure to acknowledge use of the weather data results in disconnect</caption>
        </region>
        <region class="DoCO:FigureBox" id="F20">
          <image class="DoCO:Figure" src="62sn.page_019.image_16.png" thmb="62sn.page_019.image_16-thumb.png"/>
          <caption class="deo:Caption" id="299" page="19" column="1">Fig. 20. Sequence Diagram 2.8.10.: begin updating the weather data by notifying all clients of new data</caption>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="300" page="20" column="1">90</outsider>
        <outsider class="DoCO:TextBox" type="header" id="301" page="20" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <region class="DoCO:FigureBox" id="F21">
          <image class="DoCO:Figure" src="62sn.page_020.image_17.png" thmb="62sn.page_020.image_17-thumb.png"/>
          <caption class="deo:Caption" id="303" page="20" column="1">Fig. 21. Sequence Diagram 2.8.12.: all clients acknowledge the new data and are instructed to use it</caption>
        </region>
        <region class="DoCO:FigureBox" id="F22">
          <image class="DoCO:Figure" src="62sn.page_020.image_18.png" thmb="62sn.page_020.image_18-thumb.png"/>
          <caption class="deo:Caption" id="305" page="20" column="1">Fig. 22. Sequence Diagram 2.8.13.: acknowledgement failure means revert to the old weather data</caption>
        </region>
        <outsider class="DoCO:TextBox" type="header" id="306" page="21" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="307" page="21" column="1">91</outsider>
        <region class="DoCO:FigureBox" id="F23">
          <image class="DoCO:Figure" src="62sn.page_021.image_19.png" thmb="62sn.page_021.image_19-thumb.png"/>
          <caption class="deo:Caption" id="309" page="21" column="1">Fig. 23. Sequence Diagram 2.8.15.: all clients use the new data</caption>
        </region>
        <region class="DoCO:FigureBox" id="F24">
          <image class="DoCO:Figure" src="62sn.page_021.image_20.png" thmb="62sn.page_021.image_20-thumb.png"/>
          <caption class="deo:Caption" id="311" page="21" column="1">Fig. 24. Sequence Diagram 2.8.16.: acknowledgement failure disconnects all clients</caption>
        </region>
        <outsider class="DoCO:TextBox" type="page_nr" id="312" page="22" column="1">92</outsider>
        <outsider class="DoCO:TextBox" type="header" id="313" page="22" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <region class="DoCO:FigureBox" id="F25">
          <image class="DoCO:Figure" src="62sn.page_022.image_21.png" thmb="62sn.page_022.image_21-thumb.png"/>
          <caption class="deo:Caption" id="315" page="22" column="1">Fig. 25. Sequence Diagram 2.8.18.: all clients successfully revert to the old data</caption>
        </region>
        <region class="DoCO:FigureBox" id="F26">
          <image class="DoCO:Figure" src="62sn.page_022.image_22.png" thmb="62sn.page_022.image_22-thumb.png"/>
          <caption class="deo:Caption" id="317" page="22" column="1">Fig. 26. Sequence Diagram 2.8.19.: acknowledgement failure disconnects all clients</caption>
        </region>
        <outsider class="DoCO:TextBox" type="header" id="318" page="23" column="1">J. Whittle et al.: From scenarios to code</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="319" page="23" column="1">93</outsider>
        <region class="DoCO:FigureBox" id="F27">
          <caption class="deo:Caption" id="320" page="23" column="1">Fig. 27. State machine generated for WCL</caption>
          <image class="DoCO:Figure" src="62sn.page_023.image_23.png" thmb="62sn.page_023.image_23-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="321" confidence="possible" page="23" column="1">Jon Whittle is a research scientist at NASA Ames Research Center where he conducts research on software modeling and transformation. He has a PhD from the University of Ed- inburgh, Scotland, and a BA from the University of Oxford. He has published widely and has served on international pro- gramme committees, including that of the 2002 &amp; 2004 Unified Modeling Language Conference. He was also Chair for this Conference in 2003.</region>
        <region class="DoCO:FigureBox" id="Fx322">
          <image class="DoCO:Figure" src="62sn.page_023.image_25.png" thmb="62sn.page_023.image_25-thumb.png"/>
        </region>
        <region class="DoCO:TextChunk" id="323" confidence="possible" page="23" column="1">Richard J. Kwan is a Senior Software Engineer at Lightsaber Computing, in Fremont, California, where his focus is on light-weight distributed comput- ing for vehicular and local area network applications. He is a member of a technical commit- tee (AIAA CSTC), where he is collaborating on guidelines for using commercial off-the-shelf (COTS) software in mission crit-</region>
        <region class="DoCO:TextChunk" id="324" confidence="possible" page="23" column="2">ical systems. He was previously a Senior Research Engineer at Aerospace Computing, in Mountain View, California, and worked next door at NASA Ames on automation for air traffic management.</region>
        <region class="DoCO:TextChunk" id="325" confidence="possible" page="23" column="2">Jyoti Saboo worked as a software development engineer for two years, under the guidance and supervision of Jon Whittle and Johann Schumann at NASA Ames Research Center in Moffett Field, California.</region>
        <region class="DoCO:FigureBox" id="Fx326">
          <image class="DoCO:Figure" src="62sn.page_023.image_24.png" thmb="62sn.page_023.image_24-thumb.png"/>
        </region>
      </section>
    </body>
  </article>
</pdfx>
