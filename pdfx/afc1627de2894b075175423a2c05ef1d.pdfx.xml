<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>c0ff946db135f362b803c1e7dfae8c8cdb260a74f20d7d8d3f672f98939215e5</job>
    <base_name>62pd</base_name>
    <doi>http://dx.doi.org/10.1145/267580.267581</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1" confidence="possible">Classification of Research Efforts in Requirements Engineering</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="2">PAMELA ZAVE</name>
        </contrib>
      </contrib-group>
      <region class="unknown" id="3">AT&amp;T Laboratories—Research</region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="4" confidence="possible" page="1" column="1">1. PURPOSE OF THE CLASSIFICATION SCHEME</h1>
      </section>
      <region class="DoCO:TextChunk" id="13" page="1" column="1">Requirements engineering is the branch of software engineering concerned with the real-world goals for functions of and constraints on software systems. It is also concerned with the relationship of these factors to precise specifications of software behavior, and to their evolution over time and across software families. The subject of requirements engineering is inherently broad, interdiscipli- nary, and open-ended. It concerns translation from informal observations of the real world to mathematical specification languages. For these reasons, it can seem chaotic in comparison to other areas in which computer scientists do research. This article presents a classification scheme for research efforts in requirements engineering. For those readers who are not familiar with requirements engineering, it is intended to provide an overview and a coherent framework for further study. For those readers who do research in requirements engineering, it is offered in the hope that it will: <marker type="block"/> —delineate the area and encourage research coverage of the whole area; —provide structure to encourage the discovery and articulation of new principles; and —assist in grouping similar things, such as competing solutions to the same problem (these groupings would<marker type="column" number="2"/><marker type="block"/> be a great help in comparing, extend- ing, and exploiting results). The great difficulty in constructing such a classification scheme is the het- erogeneity of the topics usually consid- ered part of requirements engineering. They include the following. —Tasks that must be completed: elicitation of information from clients, vali- dation, specification; —Problems that must be solved: barriers to communication, incompleteness, in- consistency; —Solutions to problems: formal languages and analysis algorithms, prototyping, metrics, traceability; —Ways of contributing to knowledge: de- scriptions of current practice, case studies, controlled experiments; and —Types of system: embedded systems, safety-critical systems, distributed systems. A typical list of research topics in requirements engineering contains all these entries and more. It is intended to be comprehensive, but it is also confusing. The obvious way out of this difficulty is a classification scheme with several orthogonal dimensions. The more dimensions the more precision, at the ex- pense of making the scheme too complex to use. I have compromised by settling on two dimensions, which are presented separately in the next two sections. I have referenced a number of papers<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> that illustrate the categories and issues discussed. A reference is nothing more than an example; it is certainly not a claim that the referenced paper is the best or only work in its category! In addition, Section 4 presents some examples that do not fit neatly into the nom- inal categories, and shows how the classification scheme sheds light on them as well.</region>
      <region class="unknown" id="7" page="1" column="1">Permission to make digital / hard copy of part or all of this work for personal or classroom use is granted without fee provided that the copies are not made or distributed for profit or commercial advantage, the copyright notice, the title of the publication, and its date appear, and notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and / or a fee. © 1997 ACM 0360-0300/97/1200–0315 $03.50</region>
      <outsider class="DoCO:TextBox" type="footer" id="9" page="1" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="10" page="2" column="1">316</outsider>
      <outsider class="DoCO:TextBox" type="header" id="11" page="2" column="1">•</outsider>
      <outsider class="DoCO:TextBox" type="header" id="12" page="2" column="1">Pamela Zave</outsider>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="14" confidence="possible" page="2" column="1">2. FIRST DIMENSION: PROBLEMS</h1>
        <region class="DoCO:TextChunk" id="27" page="2" column="1">The first dimension is very particular to requirements engineering. It is an attempt to characterize the work that needs to be done. It must somehow cover necessary tasks, recognizable problems, and proposed solutions without confusing the three. Basing this primary dimension on solutions to problems seems like a bad idea, because it would discourage developing alternative solutions to problems, or comparing different solutions to the same problem. Tasks and problems are both plausi- ble starting points and indeed overlap quite a bit. A task can always be described as a problem (“How can this task be accomplished satisfactorily?”) and a problem can always be described as a task (“Find a solution to this prob- lem.”). I prefer to use problems because they are more stable than tasks. After all, the best solutions to problems make certain tasks unnecessary! In other words, a method is a proposed solution to a problem and a method dictates which tasks are performed. Here is the first dimension of the classification scheme. Explanatory notes are interspersed. (1) Problems of investigating the goals, functions, and constraints of a software system. This topic includes all the problems of gathering information, analyzing information, and generating alternative strategies. The longer requirements engineers work on solving these problems, the bigger the scope of their work because their stock of infor- <marker type="column" number="2"/><marker type="block"/> mation and alternatives is always in- creasing. (1.1) Overcoming barriers to communication. Requirements engineers have to talk to a wide range of people with diverse backgrounds, interests, and personal goals. How can they communicate well with people whose backgrounds, interests, and goals are different from their own? And who may not know what they want from a computer system? Ethnographic techniques are sometimes proposed as a solution to this problem [Goguen and Linde 1992; Sommerville et al. 1992]. (1.2) Generating strategies for con- verting vague goals (e.g., “user-friendli- ness,” “security,” “accuracy,” “reliability”) into specific properties or behavior. For example, prototyping is often proposed for exploring the friendliness of a user interface. There are also product-oriented [Harrison and Barnard 1992] and process-oriented [Chung and Nixon 1995] approaches to this problem (see Section 3 for a definition of these terms). (1.3) Understanding priorities and ranges of satisfaction. Many requirements are not absolute; they can be satisfied partially, or only if resources permit. Requirements engineers must obtain the information necessary to de- cide when and how to satisfy these requirements [Yen and Tiao 1997]. (1.4) Generating strategies for allocat- ing requirements among the system and the various agents of its environment. The true requirements always refer to the real world in which the computer system will become embedded. Before the software can be specified, goals, functions, and constraints must be allo- cated to the various components and agents that will contribute to satisfying them [Alford 1977; Dardenne et al. 1993; Feather 1987; Johnson 1988]. (1.5) Estimating costs, risks, and schedules. This is the other half of the information needed to handle optional<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> requirements, which are generally satisfied depending on development resources. Requirements engineers must estimate the resources needed and be aware of the reliability of their estimates [Matson et al. 1994; Mukho- padhyay and Kekre 1992]. (1.6) Ensuring completeness. How can requirements engineers be sure that they have not left out any important people, viewpoints, issues, facts, etc., out of their investigations? This is “completeness” in an informal sense [Reubenstein and Waters 1991]. (2) Problems of specifying software system behavior. This topic includes all the problems of synthesizing information and choosing among alternatives, to create a precise and minimal software specification. The longer requirements engineers work on solving these problems, the smaller the scope of their work because they are discarding alternatives and irrelevant information. (2.1) Integrating multiple views and representations. The results of investi- gation are likely to be diverse and to contain conflicts. Understanding, communication, and negotiation are useful for reconciling conflicting viewpoints [Easterbrook 1992]. Formal methods are useful for composing diverse nota- tions and for monitoring inconsistencies [Nuseibeh et al. 1994; Zave and Jackson 1993]. (2.2) Evaluating alternative strategies for satisfying requirements. Work on 1.2, 1.3, and 1.4 may generate alternatives, from which the specific system behavior must be chosen. Many of the papers cited in those sections also include evaluation strategies. (2.3) Obtaining complete, consistent, and unambiguous specifications. This is “completeness” in the formal sense of having no missing parts [Heimdahl and Leveson 1996; Heitmeyer et al. 1996]. (2.4) Checking that the specified system will satisfy the requirements. There<marker type="column" number="2"/><marker type="block"/> are a variety of approaches to this well- known problem. They include inspections [Porter et al. 1995], execution and testing of the specification [Zave and Schell 1986], and verification [Coen- Porisini et al. 1994; Du Bois et al. 1997]. (2.5) Obtaining specifications that are well-suited for design and implementation activities. This is the problem of building into the specification qualities that will ensure successful software development. Sometimes designs [Lor and Berry 1991] or test cases [Weyuker et al. 1994] can be generated automatically or semiautomatically from a specification. Designs can also be checked for consistency with the specification [Lefering 1992]. (3) Problems of managing evolution of systems and families of systems. The first two major topics treat requirements engineering as if it were an iso- lated and unique phase of development. Of course, that is untrue. As systems evolve, they undergo many phases of requirements engineering. The requirements engineering of each member of a family should not be independent of other family members. This topic is concerned with the coordination of distinct requirements-engineering phases. It is concerned with how to make the work done in a phase reusable, and how to reuse it in other phases. (3.1) Reusing requirements engineering during evolutionary phases. In other words, this is the problem of en- suring that the artifacts of requirements engineering are maintainable. Some proposed solutions to this problem are traceability (recording the relationship between aspects of system behavior and the requirements that motivated them) [Leite and Oliveira 1995; Ramesh et al. 1995] and specification modular- ity. (3.2) Reusing requirements engineering for developing similar systems. In other words, this is the problem of en- suring that the artifacts of require-<marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> ments engineering apply to families of systems. One example of a solution to this problem is conceptual modeling of an entire application domain [Lam et al. 1997; Maiden and Sutcliffe 1992; Ryan and Mathews 1992]. Another example is separation of user-interface concerns from other concerns, so that the same “look and feel” can be provided across a product line. (3.3) Reconstructing requirements. This problem occurs when you want to reuse the artifacts of requirements engineering, but they are missing. It calls for reverse engineering of requirements. Very little work has been done on this problem.</region>
        <outsider class="DoCO:TextBox" type="footer" id="17" page="2" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
        <outsider class="DoCO:TextBox" type="header" id="18" page="3" column="1">Classification in Requirements Engineering</outsider>
        <outsider class="DoCO:TextBox" type="header" id="19" page="3" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="20" page="3" column="1">317</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="23" page="3" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="24" page="4" column="1">318</outsider>
        <outsider class="DoCO:TextBox" type="header" id="25" page="4" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="26" page="4" column="1">Pamela Zave</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="28" confidence="possible" page="4" column="1">3. SECOND DIMENSION: CONTRIBUTIONS TO SOLUTIONS</h1>
        <region class="DoCO:TextChunk" id="35" page="4" column="1">The second dimension could also apply to other areas of software engineering. It is an attempt to characterize the ways that research can contribute to solving problems. This dimension as- sumes that, as software engineers, we can seek to understand social factors but we can only hope to influence tech- nical practices. (A) Report on the state of the practice. This establishes a baseline from which others can work [Lubars et al. 1992]. (B) Proposed process-oriented solution. Some problems must be solved manually, because we do not know how to solve them automatically. We can contribute to solving these problems by providing orderly methods and heuris- tics for making the decisions involved [Goguen and Linde 1992; Jackson 1983]. These contributions are “process- oriented solutions,” because they focus on the manual process of requirements engineering. (C) Proposed product-oriented solution. Some problems can be solved automatically, in which case the emphasis is on formal representations and algorith- mic manipulations of them. These contributions are “product-oriented solu- <marker type="column" number="2"/><marker type="block"/> tions,” because they focus on representation and manipulation of the products of requirements engineering [Heimdahl and Leveson 1996; Lefering 1992; Reubenstein and Waters 1991]. Research on prototyping user interfaces would be classified 1.2, because it is addressing the problem of how to make a system user-friendly. As an example of the difference between contributions B and C, if the research emphasizes representation and automated implementation of interface choices and policies, then it would be a contribution of type C. If the research emphasizes working with users to determine their preferences, then it would be a contribution of type B. As another example of the difference between B and C, of the two cited solutions to problem 1.1, one [Goguen and Linde 1992] is a contribution of type B, and the other [Sommerville et al. 1992] is a contribution of type C. (D) Case study applying a proposed solution to a substantial example. A case study provides important evidence, but it is necessarily anecdotal [van Lamsweerde et al. 1995]. Ideally it would be done in preparation for a more systematic and objective evaluation of the proposed solution, as in E. (E) Evaluation or comparison of proposed solutions. To belong in this category, evaluation of a single proposed solution should be objective in some way (“I tried it and I liked it” is not enough) [Maiden and Sutcliffe 1992; Zave 1991]. Naturally, a comparison of several solutions is more likely to be systematic and objective. A controlled experiment with quantitative results is the ideal contribution in this category [Porter et al. 1995]. (F) Proposed measurement-oriented solution. It is now widely accepted that an organization can improve its prob- lem-solving simply by monitoring and measuring how well it solves problems, and then tracking those measurements over time. Thus measurement of the<marker type="page" number="5"/><marker type="column" number="1"/><marker type="block"/> success of requirements-engineering activities can be viewed as a problem- solving technique in its own right, as well as a means of comparing other solutions. For example, measurements of previous development projects help solve problem 1.5. Measurements of cus- tomer satisfaction help solve problems 1.1, 1.2, 1.3, and 2.2. A readability met- ric might help solve problem 2.4. Mea- surement can help solve 2.2 by checking the domain assumptions that were and are used to make strategic choices [Fic- kas and Feather 1995].</region>
        <outsider class="DoCO:TextBox" type="footer" id="31" page="4" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
        <outsider class="DoCO:TextBox" type="header" id="32" page="5" column="1">Classification in Requirements Engineering</outsider>
        <outsider class="DoCO:TextBox" type="header" id="33" page="5" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="34" page="5" column="1">319</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="36" confidence="possible" page="5" column="1">4. OTHER EXAMPLES</h1>
        <region class="DoCO:TextChunk" id="38" page="5" column="1">When an article spans many categories in one dimension, it is usually narrowly focused in another dimension. Sometimes the other dimension is also in this classification scheme. For example, Reubenstein and Waters [1991] and Porter et al. [1995] both make contributions of a very specific kind. But their contribu- tions—an intelligent automated assis- tant and rigorous evaluation of inspec- tion techniques, respectively—address many requirements problems simulta- neously and in a wide-spectrum fashion. Sometimes the focused dimension is not in the classification scheme. I have deliberately neglected problem solutions, so an article focused on a solution technique might address several problems. For example, automated translation of natural-language specifications into formal specifications [Ishihara et al. 1992] is a solution that might alleviate problems 1.1, 1.6, 2.1, 2.3, or 2.4. As such, it can be compared for effective- ness to drastically different solutions to these problems, such as ethnography and executable specifications. Another neglected dimension is that of application domain. For example, the A-7 method [Heninger 1980; Parnas and Clements 1986; Parnas and Madey 1995; van Schouwen et al. 1992] is a comprehensive requirements method for real-time process-control systems. It attempts to solve (or at least alleviate) almost all requirements problems <marker type="column" number="2"/><marker type="block"/> within the limits of that application domain.</region>
      </section>
      <section class="deo:Acknowledgements">
        <h1 class="DoCO:SectionTitle" id="39" confidence="possible" page="5" column="2">ACKNOWLEDGMENT</h1>
        <region class="DoCO:TextChunk" id="40" confidence="possible" page="5" column="2">This classification scheme was developed and re- fined while I was program chair of the Second IEEE International Symposium on Requirements Engineering. I would like to thank everyone who participated.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="41" confidence="possible" page="5" column="2">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="42" page="5" column="2">A LFORD , M. W. 1977. A requirements engineering methodology for real-time processing requirements. IEEE Trans. Softw. Eng. III, 1 (Jan.) 60 – 69.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="43" confidence="possible" page="5" column="2">C HUNG , L. AND N IXON , B. A. 1995. Dealing with non-functional requirements: Three experi- mental studies of a process-oriented ap- proach. In Proceedings of the Seventeenth International Conference on Software Engineering, ACM Press, ACM, New York, NY, 25–37.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="44" confidence="possible" page="5" column="2">C OEN -P ORISINI , A., K EMMERER , R. A., AND M AND RIOLI , D. 1994. A formal framework for AS- TRAL intralevel proof obligations. IEEE Trans. Softw. Eng. XX, 8 (Aug.) 548 –561.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="45" confidence="possible" page="5" column="2">D ARDENNE , A., VAN L AMSWEERDE , A., AND F ICKAS , S. 1993. Goal-directed requirements acquisition. Science of Computer Programming XX, 3–50.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="46" confidence="possible" page="5" column="2">D U B OIS , P., D UBOIS , E., AND Z EIPPEN , J.-M. 1997. On the use of a formal RE language: The generalized railroad crossing problem. In Proceedings of the Third IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7740-6, 128 –137.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="47" confidence="possible" page="5" column="2">E ASTERBROOK , S. 1992. Domain modelling with hierarchies of alternative viewpoints. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 65– 72.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="48" confidence="possible" page="5" column="2">F EATHER , M. S. 1987. Language support for the specification and development of composite systems. ACM Trans. Program. Lang. Syst. IX, 2 (Apr.), 198 –234.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="49" confidence="possible" page="5" column="2">F ICKAS , S. AND F EATHER , M. S. 1995. Requirements monitoring in dynamic environments. In Proceedings of the Second IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186- 7017-7, 140 –147.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="50" confidence="possible" page="5" column="2">G OGUEN , J. A. AND L INDE , C. 1992. Techniques for requirements elicitation. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 152–164.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="55" page="6" column="1">H ARRISON , M. AND B ARNARD , P. 1992. On defin- ing requirements for interaction. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 50 –54.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="56" confidence="possible" page="6" column="1">H EIMDAHL , M. P. E. AND L EVESON , N. G. 1996. Completeness and consistency in hierarchical state-based requirements. IEEE Trans. Softw. Eng. XXII, 6 (June), 363–377.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="57" confidence="possible" page="6" column="1">H EITMEYER , C. L., J EFFORDS , R. D., AND L ABAW , B. G. 1996. Automated consistency checking of requirements specifications. ACM Trans. Softw. Eng. Method. V, 3 (July) 231– 261.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="58" confidence="possible" page="6" column="1">H ENINGER , K. L. 1980. Specifying software requirements for complex systems: New techniques and their application. IEEE Trans. Softw. Eng. VI, 1 (Jan.) 2–13.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="59" confidence="possible" page="6" column="1">I SHIHARA , Y., S EKI , H., AND K ASAMI , T. 1992. A translation method from natural language specifications into formal specifications using contextual dependencies. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 232–239.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="60" confidence="possible" page="6" column="1">J ACKSON , M. 1983. System Development. Pren- tice-Hall International.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="61" confidence="possible" page="6" column="1">J OHNSON , W. L. 1988. Deriving specifications from requirements. In Proceedings of the Tenth International Conference on Software Engineering, IEEE Computer Society, ISBN 0-8186-0849-8, 428 – 438.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="62" confidence="possible" page="6" column="1">L AM , W., M C D ERMID , J. A., AND V ICKERS , A. J. 1997. Ten steps towards systematic requirements reuse. In Proceedings of the Third IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7740-6, 6 –15.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="63" page="6" column="1">DO P RADO L EITE , J. C. S. AND DE P ADUA A LBUQUER QUE O LIVEIRA , A. 1995. A client oriented requirements baseline. In Proceedings of the Second IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7017-7, 108 –115.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="64" confidence="possible" page="6" column="1">L EFERING , M. 1992. An incremental integration tool between requirements engineering and programming in the large. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 82– 89.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="65" confidence="possible" page="6" column="1">L OR , K.-W. E. AND B ERRY , D. M. 1991. Auto- matic synthesis of SARA design models from system requirements. IEEE Trans. Softw. Eng. XVII, 12 (Dec.) 1229 –1240.</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="66" confidence="possible" page="6" column="1">L UBARS , M., P OTTS , C., AND R ICHTER , C. 1992. A review of the state of the practice in requirements modeling. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 2–14.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="67" confidence="possible" page="6" column="1">M AIDEN , N. A. M. AND S UTCLIFFE , A. G. 1992.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="68" page="6" column="2">Requirements engineering by example: An empirical study. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 104 –111. M ATSON , J. E., B ARRETT , B. E., AND M ELLICHAMP , J. M. 1994. Software development cost estimation using function points. IEEE Trans. Softw. Eng. XX, 4 (Apr.) 275–287.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="69" confidence="possible" page="6" column="2">M UKHOPADHYAY , T. AND K EKRE , S. 1992. Software effort models for early estimation of process control applications. IEEE Trans. Softw. Eng. XVIII, 10 (Oct.) 915–924.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="70" confidence="possible" page="6" column="2">N USEIBEH , B., K RAMER , J., AND F INKELSTEIN , A. 1994. A framework for expressing the relationships between multiple views in requirements specification. IEEE Trans. Softw. Eng. XX, 10 (Oct.) 760 –773.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="71" confidence="possible" page="6" column="2">P ARNAS , D. L. AND C LEMENTS , P. C. 1986. A rational design process: How and why to fake it. IEEE Trans. Softw. Eng. XII, 2 (Feb.), 251–257.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="72" confidence="possible" page="6" column="2">P ARNAS , D. L. AND M ADEY , J. 1995. Functional documentation for computer systems engineering. Science of Computer Programming XXV (Oct.), 41– 61.</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="73" confidence="possible" page="6" column="2">P ORTER , A. A., V OTTA , J R ., L. G., AND B ASILI , V. R. 1995. Comparing detection methods for software requirements inspections: A rep- licated experiment. IEEE Trans. Softw. Eng. XXI, 6 (June) 563–575.</ref>
          <ref rid="R29" class="deo:BibliographicReference" id="74" confidence="possible" page="6" column="2">R AMESH , B., P OWERS , T., S TUBBS , C., AND E DWARDS , M. 1995. Implementing requirements traceability: A case study. In Proceedings of the Second IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7017-7, 89 –95.</ref>
          <ref rid="R30" class="deo:BibliographicReference" id="75" confidence="possible" page="6" column="2">R EUBENSTEIN , H. B. AND W ATERS , R. C. 1991. The requirements apprentice: Automated as- sistance for requirements acquisition. IEEE Trans. Softw. Eng. XVII, 3 (Mar.) 226 –240.</ref>
          <ref rid="R31" class="deo:BibliographicReference" id="76" confidence="possible" page="6" column="2">R YAN , K. AND M ATHEWS , B. 1992. Matching conceptual graphs as an aid to requirements reuse. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 112–120.</ref>
          <ref rid="R32" class="deo:BibliographicReference" id="77" confidence="possible" page="6" column="2">S OMMERVILLE , I., R ODDEN , T., S AWYER , P., B ENTLEY , R., AND T WIDALE , M. 1992. Integrating ethnography into the requirements engineering process. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186- 3120-1, 165–173.</ref>
          <ref rid="R33" class="deo:BibliographicReference" id="78" confidence="possible" page="6" column="2">VAN S CHOUWEN , A. J., P ARNAS , D. L., AND M ADEY , J. 1992. Documentation of requirements for computer systems. In Proceedings of the IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-3120-1, 198 –207.</ref>
          <ref rid="R34" class="deo:BibliographicReference" id="83" page="7" column="1">VAN L AMSWEERDE , A., D ARIMONT , R., AND M ASSO NET , P. 1995. Goal-directed elaboration of requirements for a meeting scheduler: Problems and lessons learnt. In Proceedings of the Second IEEE International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7017-7, 194 –203.</ref>
          <ref rid="R35" class="deo:BibliographicReference" id="84" confidence="possible" page="7" column="1">W EYUKER , E., G ORADIA , T., AND S INGH , A. 1994. Automatically generating test data from a boolean specification. IEEE Trans. Softw. Eng. XX, 5 (May) 353–363.</ref>
          <ref rid="R36" class="deo:BibliographicReference" id="85" confidence="possible" page="7" column="1">Y EN , J. AND T IAO , W. A. 1997. A systematic tradeoff analysis for conflicting imprecise requirements. In Proceedings of the Third IEEE</ref>
          <ref rid="R37" class="deo:BibliographicReference" id="86" confidence="possible" page="7" column="1">Received December 1995; revised March 1997; accepted October 1997</ref>
          <ref rid="R38" class="deo:BibliographicReference" id="87" page="7" column="2">International Symposium on Requirements Engineering, IEEE Computer Society, ISBN 0-8186-7740-6, 87–96. Z AVE , P. 1991. An insider’s evaluation of PAIS- Ley. IEEE Trans. Softw. Eng. XVII, 3 (Mar.) 212–225.</ref>
          <ref rid="R39" class="deo:BibliographicReference" id="88" confidence="possible" page="7" column="2">Z AVE , P. AND J ACKSON , M. 1993. Conjunction as composition. ACM Trans. Softw. Eng. Method. II, 4 (Oct.) 379 – 411.</ref>
          <ref rid="R40" class="deo:BibliographicReference" id="89" confidence="possible" page="7" column="2">Z AVE , P. AND S CHELL , W. M. 1986. Salient fea- tures of an executable specification language and its environment. IEEE Trans. Softw. Eng. XII, 2 (Feb.) 312–325.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="footer" id="51" page="5" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="52" page="6" column="1">320</outsider>
        <outsider class="DoCO:TextBox" type="header" id="53" page="6" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="header" id="54" page="6" column="1">Pamela Zave</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="79" page="6" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
        <outsider class="DoCO:TextBox" type="header" id="80" page="7" column="1">Classification in Requirements Engineering</outsider>
        <outsider class="DoCO:TextBox" type="header" id="81" page="7" column="1">•</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="82" page="7" column="1">321</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="90" page="7" column="2">ACM Computing Surveys, Vol. 29, No. 4, 1997</outsider>
      </section>
    </body>
  </article>
</pdfx>
