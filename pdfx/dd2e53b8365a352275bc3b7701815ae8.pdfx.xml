<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>a6d0ce898a0e7d38b8fd2db5f715942642ba65398c5012737b6c8670cf98bb48</job>
    <base_name>62nh</base_name>
    <doi>http://dx.doi.org/10.1109/2.910904</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">SOFTWARE MANAGEMENT</outsider>
      <title-group>
        <article-title class="DoCO:Title" id="2">Weaving Together Requirements and Architectures The Open University</article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="3">Bashar Nuseibeh</name>
        </contrib>
      </contrib-group>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="10" page="1" column="1">C justify ompelling standing why of economic stakeholders’ an early arguments under- requirements leads to systems that satisfy their expectations. Equally compelling arguments justify an early understanding and construction of a software-system architecture to provide a basis for discovering further requirements and constraints, evaluat- ing a system’s technical feasibility, and determining alternative design solutions. Software-development organizations often choose between alternative starting points—requirements or architectures. This invariably results in a waterfall development process that produces artificially frozen requirements docu- ments for use in the next step in the development life cycle. Alternatively, this process creates systems with constrained architectures that restrict users and hand- icap developers by resisting inevitable and desirable changes in requirements. The spiral life-cycle model addresses many drawbacks of a waterfall model by providing an incremental development process, in which developers repeatedly evaluate changing project risks to manage unstable requirements and funding. An even finer-grain spiral life cycle reflects both the realities and necessities of mod- ern software development. Such a life cycle acknowledges the need to develop software architectures that are stable, yet adaptable, in the presence of changing requirements. The cornerstone of this process is that developers craft a system’s requirements and its architecture concur- <marker type="column" number="2"/><marker type="block"/> rently, and interleave their development (W. Swartout and R. Balzer, “On the Inevitable Intertwining of Specification and Implementation,” Comm. ACM, vol. 25, no. 7, 1982, pp. 438-440).<marker type="block"/> THE TWIN PEAKS MODEL Except for well-defined problem domains and strict contractual proce- dures, most software-development projects address requirements specification and design issues simultaneously—and justifiably so. Achieving a separation of requirements and design steps is often difficult because their artificial ordering compels developers to focus on either aspect at any given time. In reality, candidate architectures can constrain design- ers from meeting particular requirements, and the choice of requirements can influence the architecture that design- ers select or develop. Based on our experience in industrial software-development projects, my col- leagues and I use an adaptation of the spiral life-cycle model. We informally call this model Twin Peaks to emphasize the equal status we give to requirements and architectures. Although this model develops<marker type="column" number="3"/><marker type="block"/> requirements and architectural specifications concurrently, it continues to sepa- rate problem structure and specification from solution structure and specification, in an iterative process that produces progressively more detailed requirements and design specifications, as <xref ref-type="fig" rid="F1" id="9" class="deo:Reference">Figure 1</xref> suggests. The Twin Peaks model addresses the three management concerns identified by Barry Boehm (“Requirements that Handle IKIWISI, COTS, and Rapid Change,” Computer, July 2000, pp. 99- 102):</region>
      <region class="unknown" id="6" page="1" column="2">Twin Peaks intertwines software requirements and architectures to achieve incremental development and speedy delivery.</region>
      <region class="DoCO:FigureBox" id="Fx7">
        <image class="DoCO:Figure" src="62nh.page_001.image_01.png" thmb="62nh.page_001.image_01-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="11" confidence="possible" page="1" column="3">• I’ll Know It When I See It (IKIWISI). Requirements often emerge only after users have had an oppor- tunity to view and provide feedback on models or prototypes. Twin Peaks explicitly allows the user to explore the solution space early, per- mitting incremental development</region>
      <region class="DoCO:TextChunk" id="12" confidence="possible" page="1" column="3">and consequent risk management. • Commercial off-the-shelf software (COTS). Increasingly, software development is actually a process of identifying and selecting desirable requirements from existing commercially available software pack- ages. With Twin Peaks, developers can identify requirements and match architectures with commercially available products, rapidly and incrementally. The developer bene- fits by quickly narrowing the selec- tions or making key architectural decisions to accommodate existing COTS solutions. • Rapid change. Managing change continues to be a fundamental problem in software development and project management. Focusing on finer-grain development, Twin Peaks is receptive to changes as they occur. Analyzing and identifying a soft-</region>
      <outsider class="DoCO:TextBox" type="footer" id="13" page="1" column="3">March 2001</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="14" page="1" column="3">115</outsider>
      <outsider class="DoCO:TextBox" type="header" id="15" page="2" column="1">Software Management</outsider>
      <region class="unknown" id="16" page="2" column="1">General Specification</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="17" page="2" column="1">Level of detail</h1>
        <region class="unknown" id="18" page="2" column="1">Requirements Detailed Independent</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="19" page="2" column="1">Implementation dependence</h1>
        <region class="DoCO:FigureBox" id="F1">
          <caption class="deo:Caption" id="20" page="2" column="1">Figure 1. The Twin Peaks model develops progressively more detailed requirements and architectural specifications concurrently. This is an adaptation of the model first published in Paul Ward and Stephen Mellor’s Structured Development for Real-Time Systems: Introduction and Tools, vol. 1, Prentice Hall, Upper Saddle River, N.J., 1985, and subsequently adapted by Andrew Vickers in his student lecture notes at the University of York, UK.</caption>
        </region>
        <region class="unknown" id="21" page="2" column="1">Requirements Problem frames Components Design Architectural patterns styles Design</region>
        <region class="DoCO:FigureBox" id="F2">
          <caption class="deo:Caption" id="22" page="2" column="1">Figure 2. Part of the software-development terrain, with requirements, architecture, and design receiving similar attention. Patterns of each affect the kind of system (components) developed, and the relationship between them is a key determinant of the kind of process developers adopt.</caption>
        </region>
        <region class="DoCO:TextChunk" id="23" confidence="possible" page="2" column="1">ware system’s core requirements are requisite to developing a stable software architecture amid changing requirements.</region>
        <region class="DoCO:TextChunk" id="36" page="2" column="1">Developing software systems in these contexts requires considering differ- ent development processes. Addressing IKIWISI means starting design and implementation earlier than usual; using COTS requires considering reuse at an earlier stage of requirements specifica- <marker type="column" number="2"/><marker type="block"/> tion; remaining competitive while adapt- ing to rapid change requires us to per- form all development tasks more quickly.<marker type="block"/> BUILDING MODULAR SOFTWARE INCREMENTALLY Building systems with well-defined component interfaces offers opportuni- ties for effective reuse and maintenance. It is unclear, however, how component- based development approaches fit into the development process. One approach<marker type="column" number="3"/><marker type="block"/> is to consider the use of requirements, architecture, and design patterns. The software design community has already identified design patterns for expressing a range of implementations. The software architectures community has identified suitable architectural styles for meeting various global requirements. The requirements engineering community has promoted the use of Michael Jackson’s problem frames and Martin Fowler’s analysis patterns to identify problems for which solutions exist. What relationships connect these dif- ferent patterns? <xref ref-type="fig" rid="F2" id="29" class="deo:Reference">Figure 2</xref> suggests that we can treat patterns of requirements, designs, and architectures as the starting point for component-based development. For example, a given fixed architecture can limit the kinds of problems that we can address and the possible designs that we can develop, while rigid requirements can limit the candidate architectures and design choices. From a requirements engineering per- spective, achieving a satisfactory problem structuring using problem frames as early as possible is essential. Given that existing architectures can influence how developers structure problems, some problem frames may need to be reverse engineered from existing architectural designs.<marker type="block"/> WEAVING THE DEVELOPMENT PROCESS Twin Peaks shares much in common with Kent Beck’s Extreme Programming, such as the goal of exploring implementation possibilities early and iteratively. Twin Peaks is complementary to XP in that it focuses on software-development front-end activities—requirements and architectures. This potentially addresses some of the issues of scale that are often claimed to be XP’s weaknesses. Early understanding of requirements and choice of architecture are key to man- aging large-scale systems and projects. XP focuses on producing code—sometimes at the expense of the wider picture of requirements and architectures. Of course, focusing on requirements and architectures in itself is not sufficient to achieve scalability. Modularity and iter- ation are also crucial. Twin Peaks is inher- ently iterative, and combining it with tried<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> and tested components derived from well- understood patterns can facilitate incremental development of large-scale systems. The resultant overall software- development process inevitably takes a more complex path from problem to solution. Although the conceptual differences between requirements and design are now much better understood and articulated, the process of moving between the problem world and the solution world is not as well recognized (Michael Goedicke and<marker type="block"/> Bashar Nuseibeh, “The Process Road between Requirements and Design,” Proc. 2nd World Conf. Integrated Design and Process Technology, SDPS, Austin, Texas, 1996, pp. 176-177). Researchers and practitioners are struggling to develop processes that allow rapid development in a competitive market, combined with the improved analysis and planning that is necessary to produce high-quality systems within tight time and budget constraints. A more robust and realistic development process allows both requirements engineers and system architects to work concurrently and iteratively to describe the artifacts they wish to produce. This process allows developers to better understand problems through consider- ation of architectural constraints, and they can develop and adapt architectures based on requirements. Many difficult questions remain unan- swered:</region>
        <region class="unknown" id="25" page="2" column="2">Architecture Dependent</region>
        <region class="unknown" id="26" page="2" column="2">Architecture</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="32" page="2" column="3">116</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="33" page="2" column="3">Computer</outsider>
        <region class="unknown" id="35" page="3" column="1">The Twin Peaks model represents much of the existing, but implicit, state of the practice in software development.</region>
        <region class="DoCO:TextChunk" id="37" confidence="possible" page="3" column="1">• What software architectures (or architectural styles) are stable in the presence of changing requirements, and how do we select them? • What classes of requirements are more stable than others, and how do we identify them? • What kinds of changes are systems likely to experience in their lifetime,</region>
        <region class="DoCO:TextChunk" id="38" confidence="possible" page="3" column="2">and how do we manage requirements and architectures (and their development processes) in order to minimize the impact of these changes?</region>
        <region class="DoCO:TextChunk" id="39" page="3" column="2">The answers to these questions will influence key emerging software-development contexts including</region>
        <region class="DoCO:TextChunk" id="40" confidence="possible" page="3" column="2">• product lines and product families, which need stable architectures that tolerate changing requirements; • COTS systems, which require identifying and matching existing architectures to requirements (as opposed to developing system requirements from scratch); and • legacy systems, which can incorpo- rate existing system constraints into requirements specifications.</region>
        <region class="DoCO:TextChunk" id="42" page="3" column="2">Processes that embody Twin Peaks characteristics are the first steps in tack- ling the need for architectural stability in the face of inevitable requirements volatility. <marker type="block"/> evelopment processes that facilitate D fast, tial for incremental software delivery systems are that essen- need to be developed quickly, with progressively shorter times-to-market as a key requirement. The Twin Peaks model represents much of the existing, but implicit, state of the practice in software development. While it is based on accepted research in its evolutionary development, the software-development community has not yet recognized that such a model represents acceptable practice. ✸</region>
        <region class="DoCO:TextChunk" id="46" confidence="possible" page="3" column="2">Bashar Nuseibeh is a professor of com- puting at The Open University, United Kingdom, and director of the Centre for Systems Requirements Engineering at the Department of Computing, Imperial Col- lege, London. Contact him at B.A. <email id="43">Nuseibeh@open.ac.uk</email> or visit <ext-link ext-link-type="uri" href="http://mcs" id="44">http://mcs</ext-link>. open.ac.uk/ban25. Editor: Barry Boehm, Computer Science Department, University of Southern Califor- nia, Los Angeles, CA 90089; <email id="45">boehm@sunset</email>. usc.edu</region>
        <region class="unknown" id="47" page="3" column="3">www.ipdps.org</region>
        <region class="DoCO:FigureBox" id="Fx48">
          <image class="DoCO:Figure" src="62nh.page_003.image_02.png" thmb="62nh.page_003.image_02-thumb.png"/>
        </region>
        <region class="unknown" id="49" page="3" column="3">Presenting Six Tutorials Tailored To IPDPS 2001 Attendees MONDAY, April 23rd #1 High Performance Computing in Java: ALL Compiler, Language, and Application DAY Solutions #2 Introduction to Effective Parallel Com- AM puting #3 Parallel and Distributed Data Mining PM FRIDAY, April 27th #4 Grid Computing, Globus, and Java ALL Interface to the Grid DAY #5 SGI Pro64 Open Source Compiler AM Infrastructure #6 Distributed Object Computing with PM Java/ORB For more information, to download advance program, and to register by March 31st, visit www.ipdps.org. Sponsored by: IEEE Computer Society</region>
        <region class="DoCO:FigureBox" id="Fx50">
          <image class="DoCO:Figure" src="62nh.page_003.image_03.png" thmb="62nh.page_003.image_03-thumb.png"/>
        </region>
        <outsider class="DoCO:TextBox" type="footer" id="51" page="3" column="3">March 2001</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="52" page="3" column="3">117</outsider>
      </section>
    </body>
  </article>
</pdfx>
