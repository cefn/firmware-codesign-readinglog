<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>What is Software Design?</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    </head>
    <body>
        <h1>
            <a href="../papers/b224de5b1766c60599a2c9b9ee3b83c7.pdf">What is Software Design?</a>
        </h1>
        <h2>Authors</h2>
        <p>Jack Reeves</p>
        <h2>Year</h2>
        <h2>Notes</h2>
        <p>Makes the claim that source code is the only candidate for an 'engineering specification' - e.g. equivalent to a blueprint.</p>
        <p>His follow up piece '13 years later' comments...</p>
        <p>"the most common criticism...If source code is the design, then programmers are designers; but obviously they are not, therefore source code cannot be the design.”...circular arguments that start with the assumption that programming/coding is a manufacturing type of activity."</p>
        <p>"Everybody that has been in this business any length of time has seen plenty of examples where someone obviously sat down and coded the first thing that popped into their mind. Later, when it became obvious that there were shortcomings with the approach, there was too much blood, sweat, and “skin” invested in the code to scrap it and do something better.</p>
        <p>"Traditional development project with its strict rules forbidding the writing of a single line of code until the “design” is completed and reviewed and approved, etc. knows you can waste a hell of a lot of time producing documents that are out of date literally days after the actual coding starts. Why bother?"</p>
        <p>"properly using tools such as UML involves a considerable<br/>level of expertise and experience in its own right."</p>
        <p>"so, while it might be true that a lot of engineers do things besides producing<br/>design documents, anyone who calls himself an engineer knows what a design document in<br/>his field looks like, and probably produces such more often than not. Can we say the same<br/>for “software engineers”?"</p>
        <p>"The generally accepted definition is that a “specification” states the what, which is followed<br/>by a design document that details the how."</p>
        <p>"When the document is detailed<br/>enough, complete enough, and unambiguous enough that it can be interpreted<br/>mechanistically, whether by a computer or by an assembly line worker, then you have a<br/>design document. If it still requires creative human interpretation, then you don’t.</p>
        <p>In software development, the design document is a source code listing."</p>
        <h2>Tags</h2>
        <h2>Relevance</h2>
        <h2>Quotations</h2>
        <p>"The final goal of any engineering activity is the some type of documentation. When a design effort is complete, the design documentation is turned over to the manufacturing team. This is a completely different group with completely different skills from the design team. If the design documents truly represent a complete design, the manufacturing team can proceed to build the product. In fact, they can proceed to build lots of the product, all without any further intervention of the designers. After reviewing the software development life cycle as I understood it, I concluded that the only software documentation that actually seems to satisfy the criteria of an engineering design is the source code listings."</p>
        <p>"Major microprocessors have been shipped with errors in their logic, bridges collapsed, dams broken, airliners fallen out of the sky, and thousands of automobiles and other consumer products have been recalled - all within recent memory and all the result of design errors."</p>
        <p>"The general consensus is that when real engineers get through with a design, no matter<br/>how complex, they are pretty sure it will work. They are also pretty sure it can be built using<br/>accepted construction techniques."</p>
        <p>"Software designers do not have or use more formal methods of validating their designs because of the simple economics of the software build cycle...it is cheaper and simpler to just build the design and test it than to do anything else."</p>
        <p>"Hardware engineers of complex systems often build models (or at least they visually render their designs using computer graphics). This allows them to get a "feel" for the design that is not possible by just reviewing the design itself."</p>
        <p>"For example, no other modern industry would tolerate a rework rate of over 100% in its manufacturing process. ...In software, even the smallest piece of code is likely to be revised or completely rewritten during testing and debugging. We accept this sort of refinement during a creative process like design, not as part of a manufacturing process.</p>
        <p>"The overwhelming problem with software development is that everything is part of the design process. Coding is design, testing and debugging are part of design, and what we typically call software design is still part of design. Software may be cheap to build, but it is incredibly expensive to design. Software is so complex that there are plenty of different design aspects and their resulting design views. The problem is that all the different aspects interrelate (just like they do in hardware engineering). It would be nice if top level designers could ignore the details of module algorithm design. Likewise, it would be nice if programmers did not have to worry about top level design issues when designing the internal algorithms of a module. Unfortunately, the aspects of one design layer intrude into the others."</p>
        <p>"We have very limited capabilities for rigorously validating a high level design. The detailed design will ultimately influence (or should be allowed to influence) the high level design at least as much as other factors."</p>
        <p>"If any aspect of the design is frozen out of the refinement process, it is hardly surprising that the final design will be poor or even unworkable."</p>
        <p>"These are the kinds of problems discovered during testing (if we do a good job of testing), for the simple reason that there was no way to discover them earlier. When they are discovered, they force a change in the design. If we are lucky, the design changes are local."</p>
        <p>"writing the software design documents after the code instead of before, produces much more accurate documents."</p>
        <h2>Boundary Objects</h2>
        <h2>Concepts</h2>
        <h2>Field of Study</h2>
        <h2>Methodology</h2>
        <h2>References</h2>
        <!-- UNIQUE HASH b224de5b1766c60599a2c9b9ee3b83c7 -->
    </body>
</html>
