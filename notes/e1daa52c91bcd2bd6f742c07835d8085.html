<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Intentional Software</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    </head>
    <body>
        <h1>
            <a href="../papers/e1daa52c91bcd2bd6f742c07835d8085.pdf">Intentional Software</a>
        </h1>
        <h2>Authors</h2>
        <p>Charles Simonyi, Magnus Christerson, Shane Clifford</p>
        <h2>Year</h2>
        <h2>Notes</h2>
        <p>Linked to a company (see Chris Bull - interviewed for them) which develops toolkits for models to be maintained in collaboration with domain experts (non-programmers) as a means of managing software development.</p>
        <p>Their phrases about creating a domain schema and then producing domain code, which maps to target code sounds an awful lot like BT Rules, and the intentional tree is almost identical.</p>
        <p>They discuss allowing ambiguity within domain representations, and contrast 'notation' with 'syntax'</p>
        <h2>Tags</h2>
        <h2>Relevance</h2>
        <h2>Quotations</h2>
        <p>"domain experts can work in parallel with programmers in their respective areas of expertise; and the repeated intermingling can be automated"</p>
        <p>"Because programs are the only precise (i.e. machine processable) artifacts that record the programmers’ work, any change (whether maintenance or extension) has to be done to the program, which is encoded in a way that does not clearly express the problem that was to be solved."</p>
        <p>"The goal of software is to implement a solution to a problem that is defined by human intent alone. Some people have expertise in the problem domain - they are domain experts. Some people have expertise in software creation – they are programmers. Together they create software, perhaps with some people in both roles."</p>
        <p>"For the creation of any software, two kinds of contributions need to be combined even though they are not at all similar: those of the domain providing the problem statement and those of software engineering providing the implementation. They need to be woven together to form the program."</p>
        <p>"The direct development workflow in use today (Figure 1) is the following: The domain expert communicates the problemstatement to the programmer. This is done in forms that can not be automatically transformed into code, such as specs, use cases, stories, and sketches. The programmer then weaves these intentions together with software engineering knowledge and implementation decisions and creates the source code that can run on a computer."</p>
        <p>"The domain expert need not make a decision whether the domain concept is an object, a quality, an action, a goal, or anything else. The need is just to establish an identity for it, whatever it may be, and that can be accomplished always in the same way—by a def in the schema."</p>
        <h2>Boundary Objects</h2>
        <h2>Concepts</h2>
        <p>Domain specific languages</p>
        <p>Domain mapping</p>
        <p>Abstract syntax trees</p>
        <p>Projection</p>
        <p>Ambiguity</p>
        <p>Workbenches</p>
        <p>Generative Programming</p>
        <p>Conceptions [credited to William James]</p>
        <p>Acquaintance Objects [Peter Naur]</p>
        <h2>Field of Study</h2>
        <h2>Methodology</h2>
        <h2>References</h2>
        <p>Brooks, Fredrick, No Silver Bullet – Essence and Accidents of Software Engineering, Computer Magazine, 1987. quoted as follows... "Much of the complexity [the programmer] must master is arbitrary complexity, forced without rhyme or reason by the many human institutions and systems"</p>
        <!-- HASH e1daa52c91bcd2bd6f742c07835d8085 -->
    </body>
</html>
